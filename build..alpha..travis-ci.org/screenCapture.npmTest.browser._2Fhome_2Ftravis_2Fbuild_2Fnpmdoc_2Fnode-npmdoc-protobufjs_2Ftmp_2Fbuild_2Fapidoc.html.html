<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://dcode.io/protobuf.js">protobufjs (v6.7.0)</a>
</h1>
<h4>Protocol Buffers for JavaScript (&amp; TypeScript).</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs">module protobufjs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.BufferReader">
            function <span class="apidocSignatureSpan">protobufjs.</span>BufferReader
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.BufferWriter">
            function <span class="apidocSignatureSpan">protobufjs.</span>BufferWriter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Class">
            function <span class="apidocSignatureSpan">protobufjs.</span>Class
            <span class="apidocSignatureSpan">(type, ctor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Enum">
            function <span class="apidocSignatureSpan">protobufjs.</span>Enum
            <span class="apidocSignatureSpan">(name, values, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Field">
            function <span class="apidocSignatureSpan">protobufjs.</span>Field
            <span class="apidocSignatureSpan">(name, id, type, rule, extend, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.MapField">
            function <span class="apidocSignatureSpan">protobufjs.</span>MapField
            <span class="apidocSignatureSpan">(name, id, keyType, type, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Message">
            function <span class="apidocSignatureSpan">protobufjs.</span>Message
            <span class="apidocSignatureSpan">(properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Method">
            function <span class="apidocSignatureSpan">protobufjs.</span>Method
            <span class="apidocSignatureSpan">(name, type, requestType, responseType, requestStream, responseStream, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Namespace">
            function <span class="apidocSignatureSpan">protobufjs.</span>Namespace
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.OneOf">
            function <span class="apidocSignatureSpan">protobufjs.</span>OneOf
            <span class="apidocSignatureSpan">(name, fieldNames, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader">
            function <span class="apidocSignatureSpan">protobufjs.</span>Reader
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.ReflectionObject">
            function <span class="apidocSignatureSpan">protobufjs.</span>ReflectionObject
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Root">
            function <span class="apidocSignatureSpan">protobufjs.</span>Root
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Service">
            function <span class="apidocSignatureSpan">protobufjs.</span>Service
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type">
            function <span class="apidocSignatureSpan">protobufjs.</span>Type
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer">
            function <span class="apidocSignatureSpan">protobufjs.</span>Writer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.common">
            function <span class="apidocSignatureSpan">protobufjs.</span>common
            <span class="apidocSignatureSpan">(name, json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.configure">
            function <span class="apidocSignatureSpan">protobufjs.</span>configure
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.decoder">
            function <span class="apidocSignatureSpan">protobufjs.</span>decoder
            <span class="apidocSignatureSpan">(mtype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.encoder">
            function <span class="apidocSignatureSpan">protobufjs.</span>encoder
            <span class="apidocSignatureSpan">(mtype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.load">
            function <span class="apidocSignatureSpan">protobufjs.</span>load
            <span class="apidocSignatureSpan">(filename, root, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.loadSync">
            function <span class="apidocSignatureSpan">protobufjs.</span>loadSync
            <span class="apidocSignatureSpan">(filename, root)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.parse">
            function <span class="apidocSignatureSpan">protobufjs.</span>parse
            <span class="apidocSignatureSpan">(source, root, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.rpc.Service">
            function <span class="apidocSignatureSpan">protobufjs.</span>rpc.Service
            <span class="apidocSignatureSpan">(rpcImpl, requestDelimited, responseDelimited)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.tokenize">
            function <span class="apidocSignatureSpan">protobufjs.</span>tokenize
            <span class="apidocSignatureSpan">(source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer">
            function <span class="apidocSignatureSpan">protobufjs.</span>util.Buffer
            <span class="apidocSignatureSpan">(arg, encodingOrOffset, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.EventEmitter">
            function <span class="apidocSignatureSpan">protobufjs.</span>util.EventEmitter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long">
            function <span class="apidocSignatureSpan">protobufjs.</span>util.Long
            <span class="apidocSignatureSpan">(low, high, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.LongBits">
            function <span class="apidocSignatureSpan">protobufjs.</span>util.LongBits
            <span class="apidocSignatureSpan">(lo, hi)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.ProtocolError">
            function <span class="apidocSignatureSpan">protobufjs.</span>util.ProtocolError
            <span class="apidocSignatureSpan">(message, properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.codegen">
            function <span class="apidocSignatureSpan">protobufjs.</span>util.codegen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.fetch">
            function <span class="apidocSignatureSpan">protobufjs.</span>util.fetch
            <span class="apidocSignatureSpan">(filename, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.float">
            function <span class="apidocSignatureSpan">protobufjs.</span>util.float
            <span class="apidocSignatureSpan">(exports)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.verifier">
            function <span class="apidocSignatureSpan">protobufjs.</span>verifier
            <span class="apidocSignatureSpan">(mtype)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>BufferReader.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>BufferWriter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>Enum.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>Field.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>MapField.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>Message.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>Method.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>Namespace.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>OneOf.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>Reader.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>ReflectionObject.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>Root.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>Service.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>Type.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>Writer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>converter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>debug</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>roots</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>rpc</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>rpc.Service.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>types</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>util.Buffer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>util.EventEmitter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>util.Long.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>util.LongBits.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>util.ProtocolError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>util.base64</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>util.path</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>util.toJSONOptions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>util.toJSONOptions.longs.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.</span>util.utf8</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">protobufjs.</span>build</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.BufferReader">module protobufjs.BufferReader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.BufferReader.BufferReader">
            function <span class="apidocSignatureSpan">protobufjs.</span>BufferReader
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.BufferReader.prototype">module protobufjs.BufferReader.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.BufferReader.prototype._slice">
            function <span class="apidocSignatureSpan">protobufjs.BufferReader.prototype.</span>_slice
            <span class="apidocSignatureSpan">(start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.BufferReader.prototype.constructor">
            function <span class="apidocSignatureSpan">protobufjs.BufferReader.prototype.</span>constructor
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.BufferReader.prototype.string">
            function <span class="apidocSignatureSpan">protobufjs.BufferReader.prototype.</span>string
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.BufferWriter">module protobufjs.BufferWriter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.BufferWriter.BufferWriter">
            function <span class="apidocSignatureSpan">protobufjs.</span>BufferWriter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.BufferWriter.alloc">
            function <span class="apidocSignatureSpan">protobufjs.BufferWriter.</span>alloc
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.BufferWriter.prototype">module protobufjs.BufferWriter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.BufferWriter.prototype.bytes">
            function <span class="apidocSignatureSpan">protobufjs.BufferWriter.prototype.</span>bytes
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.BufferWriter.prototype.constructor">
            function <span class="apidocSignatureSpan">protobufjs.BufferWriter.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.BufferWriter.prototype.string">
            function <span class="apidocSignatureSpan">protobufjs.BufferWriter.prototype.</span>string
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Class">module protobufjs.Class</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Class.Class">
            function <span class="apidocSignatureSpan">protobufjs.</span>Class
            <span class="apidocSignatureSpan">(type, ctor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Class.create">
            function <span class="apidocSignatureSpan">protobufjs.Class.</span>create
            <span class="apidocSignatureSpan">(type, ctor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Class.generate">
            function <span class="apidocSignatureSpan">protobufjs.Class.</span>generate
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Enum">module protobufjs.Enum</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Enum.Enum">
            function <span class="apidocSignatureSpan">protobufjs.</span>Enum
            <span class="apidocSignatureSpan">(name, values, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Enum.fromJSON">
            function <span class="apidocSignatureSpan">protobufjs.Enum.</span>fromJSON
            <span class="apidocSignatureSpan">(name, json)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">protobufjs.Enum.</span>className</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Enum.prototype">module protobufjs.Enum.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Enum.prototype.add">
            function <span class="apidocSignatureSpan">protobufjs.Enum.prototype.</span>add
            <span class="apidocSignatureSpan">(name, id, comment)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Enum.prototype.constructor">
            function <span class="apidocSignatureSpan">protobufjs.Enum.prototype.</span>constructor
            <span class="apidocSignatureSpan">(name, values, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Enum.prototype.remove">
            function <span class="apidocSignatureSpan">protobufjs.Enum.prototype.</span>remove
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Enum.prototype.toJSON">
            function <span class="apidocSignatureSpan">protobufjs.Enum.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Field">module protobufjs.Field</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Field.Field">
            function <span class="apidocSignatureSpan">protobufjs.</span>Field
            <span class="apidocSignatureSpan">(name, id, type, rule, extend, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Field.fromJSON">
            function <span class="apidocSignatureSpan">protobufjs.Field.</span>fromJSON
            <span class="apidocSignatureSpan">(name, json)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">protobufjs.Field.</span>className</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Field.prototype">module protobufjs.Field.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Field.prototype.constructor">
            function <span class="apidocSignatureSpan">protobufjs.Field.prototype.</span>constructor
            <span class="apidocSignatureSpan">(name, id, type, rule, extend, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Field.prototype.resolve">
            function <span class="apidocSignatureSpan">protobufjs.Field.prototype.</span>resolve
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Field.prototype.setOption">
            function <span class="apidocSignatureSpan">protobufjs.Field.prototype.</span>setOption
            <span class="apidocSignatureSpan">(name, value, ifNotSet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Field.prototype.toJSON">
            function <span class="apidocSignatureSpan">protobufjs.Field.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.MapField">module protobufjs.MapField</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.MapField.MapField">
            function <span class="apidocSignatureSpan">protobufjs.</span>MapField
            <span class="apidocSignatureSpan">(name, id, keyType, type, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.MapField.fromJSON">
            function <span class="apidocSignatureSpan">protobufjs.MapField.</span>fromJSON
            <span class="apidocSignatureSpan">(name, json)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">protobufjs.MapField.</span>className</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.MapField.prototype">module protobufjs.MapField.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.MapField.prototype.constructor">
            function <span class="apidocSignatureSpan">protobufjs.MapField.prototype.</span>constructor
            <span class="apidocSignatureSpan">(name, id, keyType, type, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.MapField.prototype.resolve">
            function <span class="apidocSignatureSpan">protobufjs.MapField.prototype.</span>resolve
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.MapField.prototype.toJSON">
            function <span class="apidocSignatureSpan">protobufjs.MapField.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Message">module protobufjs.Message</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Message.Message">
            function <span class="apidocSignatureSpan">protobufjs.</span>Message
            <span class="apidocSignatureSpan">(properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Message.decode">
            function <span class="apidocSignatureSpan">protobufjs.Message.</span>decode
            <span class="apidocSignatureSpan">(reader)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Message.decodeDelimited">
            function <span class="apidocSignatureSpan">protobufjs.Message.</span>decodeDelimited
            <span class="apidocSignatureSpan">(reader)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Message.encode">
            function <span class="apidocSignatureSpan">protobufjs.Message.</span>encode
            <span class="apidocSignatureSpan">(message, writer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Message.encodeDelimited">
            function <span class="apidocSignatureSpan">protobufjs.Message.</span>encodeDelimited
            <span class="apidocSignatureSpan">(message, writer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Message.from">
            function <span class="apidocSignatureSpan">protobufjs.Message.</span>from
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Message.fromObject">
            function <span class="apidocSignatureSpan">protobufjs.Message.</span>fromObject
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Message.toObject">
            function <span class="apidocSignatureSpan">protobufjs.Message.</span>toObject
            <span class="apidocSignatureSpan">(message, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Message.verify">
            function <span class="apidocSignatureSpan">protobufjs.Message.</span>verify
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Message.prototype">module protobufjs.Message.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Message.prototype.toJSON">
            function <span class="apidocSignatureSpan">protobufjs.Message.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Message.prototype.toObject">
            function <span class="apidocSignatureSpan">protobufjs.Message.prototype.</span>toObject
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Method">module protobufjs.Method</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Method.Method">
            function <span class="apidocSignatureSpan">protobufjs.</span>Method
            <span class="apidocSignatureSpan">(name, type, requestType, responseType, requestStream, responseStream, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Method.fromJSON">
            function <span class="apidocSignatureSpan">protobufjs.Method.</span>fromJSON
            <span class="apidocSignatureSpan">(name, json)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">protobufjs.Method.</span>className</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Method.prototype">module protobufjs.Method.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Method.prototype.constructor">
            function <span class="apidocSignatureSpan">protobufjs.Method.prototype.</span>constructor
            <span class="apidocSignatureSpan">(name, type, requestType, responseType, requestStream, responseStream, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Method.prototype.resolve">
            function <span class="apidocSignatureSpan">protobufjs.Method.prototype.</span>resolve
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Method.prototype.toJSON">
            function <span class="apidocSignatureSpan">protobufjs.Method.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Namespace">module protobufjs.Namespace</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Namespace.Namespace">
            function <span class="apidocSignatureSpan">protobufjs.</span>Namespace
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Namespace._configure">
            function <span class="apidocSignatureSpan">protobufjs.Namespace.</span>_configure
            <span class="apidocSignatureSpan">(Type_, Service_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Namespace.arrayToJSON">
            function <span class="apidocSignatureSpan">protobufjs.Namespace.</span>arrayToJSON
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Namespace.fromJSON">
            function <span class="apidocSignatureSpan">protobufjs.Namespace.</span>fromJSON
            <span class="apidocSignatureSpan">(name, json)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">protobufjs.Namespace.</span>className</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Namespace.prototype">module protobufjs.Namespace.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Namespace.prototype.add">
            function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>add
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Namespace.prototype.addJSON">
            function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>addJSON
            <span class="apidocSignatureSpan">(nestedJson)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Namespace.prototype.constructor">
            function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>constructor
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Namespace.prototype.define">
            function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>define
            <span class="apidocSignatureSpan">(path, json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Namespace.prototype.get">
            function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>get
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Namespace.prototype.getEnum">
            function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>getEnum
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Namespace.prototype.lookup">
            function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>lookup
            <span class="apidocSignatureSpan">(path, filterTypes, parentAlreadyChecked)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Namespace.prototype.lookupEnum">
            function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>lookupEnum
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Namespace.prototype.lookupService">
            function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>lookupService
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Namespace.prototype.lookupType">
            function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>lookupType
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Namespace.prototype.lookupTypeOrEnum">
            function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>lookupTypeOrEnum
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Namespace.prototype.remove">
            function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>remove
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Namespace.prototype.resolveAll">
            function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>resolveAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Namespace.prototype.toJSON">
            function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.OneOf">module protobufjs.OneOf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.OneOf.OneOf">
            function <span class="apidocSignatureSpan">protobufjs.</span>OneOf
            <span class="apidocSignatureSpan">(name, fieldNames, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.OneOf.fromJSON">
            function <span class="apidocSignatureSpan">protobufjs.OneOf.</span>fromJSON
            <span class="apidocSignatureSpan">(name, json)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">protobufjs.OneOf.</span>className</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.OneOf.prototype">module protobufjs.OneOf.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.OneOf.prototype.add">
            function <span class="apidocSignatureSpan">protobufjs.OneOf.prototype.</span>add
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.OneOf.prototype.constructor">
            function <span class="apidocSignatureSpan">protobufjs.OneOf.prototype.</span>constructor
            <span class="apidocSignatureSpan">(name, fieldNames, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.OneOf.prototype.onAdd">
            function <span class="apidocSignatureSpan">protobufjs.OneOf.prototype.</span>onAdd
            <span class="apidocSignatureSpan">(parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.OneOf.prototype.onRemove">
            function <span class="apidocSignatureSpan">protobufjs.OneOf.prototype.</span>onRemove
            <span class="apidocSignatureSpan">(parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.OneOf.prototype.remove">
            function <span class="apidocSignatureSpan">protobufjs.OneOf.prototype.</span>remove
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.OneOf.prototype.toJSON">
            function <span class="apidocSignatureSpan">protobufjs.OneOf.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Reader">module protobufjs.Reader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader.Reader">
            function <span class="apidocSignatureSpan">protobufjs.</span>Reader
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader._configure">
            function <span class="apidocSignatureSpan">protobufjs.Reader.</span>_configure
            <span class="apidocSignatureSpan">(BufferReader_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader.create">
            function <span class="apidocSignatureSpan">protobufjs.Reader.</span>create
            <span class="apidocSignatureSpan">(buffer)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Reader.prototype">module protobufjs.Reader.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader.prototype._slice">
            function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>_slice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader.prototype.bool">
            function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>bool
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader.prototype.bytes">
            function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>bytes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader.prototype.double">
            function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>double
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader.prototype.fixed32">
            function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>fixed32
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader.prototype.fixed64">
            function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>fixed64
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader.prototype.float">
            function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>float
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader.prototype.int32">
            function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>int32
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader.prototype.int64">
            function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>int64
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader.prototype.sfixed32">
            function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>sfixed32
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader.prototype.sfixed64">
            function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>sfixed64
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader.prototype.sint32">
            function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>sint32
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader.prototype.sint64">
            function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>sint64
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader.prototype.skip">
            function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>skip
            <span class="apidocSignatureSpan">(length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader.prototype.skipType">
            function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>skipType
            <span class="apidocSignatureSpan">(wireType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader.prototype.string">
            function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>string
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader.prototype.uint32">
            function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>uint32
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Reader.prototype.uint64">
            function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>uint64
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.ReflectionObject">module protobufjs.ReflectionObject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.ReflectionObject.ReflectionObject">
            function <span class="apidocSignatureSpan">protobufjs.</span>ReflectionObject
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.ReflectionObject._configure">
            function <span class="apidocSignatureSpan">protobufjs.ReflectionObject.</span>_configure
            <span class="apidocSignatureSpan">(Root_)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">protobufjs.ReflectionObject.</span>className</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.ReflectionObject.prototype">module protobufjs.ReflectionObject.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.ReflectionObject.prototype.getOption">
            function <span class="apidocSignatureSpan">protobufjs.ReflectionObject.prototype.</span>getOption
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.ReflectionObject.prototype.onAdd">
            function <span class="apidocSignatureSpan">protobufjs.ReflectionObject.prototype.</span>onAdd
            <span class="apidocSignatureSpan">(parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.ReflectionObject.prototype.onRemove">
            function <span class="apidocSignatureSpan">protobufjs.ReflectionObject.prototype.</span>onRemove
            <span class="apidocSignatureSpan">(parent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.ReflectionObject.prototype.resolve">
            function <span class="apidocSignatureSpan">protobufjs.ReflectionObject.prototype.</span>resolve
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.ReflectionObject.prototype.setOption">
            function <span class="apidocSignatureSpan">protobufjs.ReflectionObject.prototype.</span>setOption
            <span class="apidocSignatureSpan">(name, value, ifNotSet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.ReflectionObject.prototype.setOptions">
            function <span class="apidocSignatureSpan">protobufjs.ReflectionObject.prototype.</span>setOptions
            <span class="apidocSignatureSpan">(options, ifNotSet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.ReflectionObject.prototype.toJSON">
            function <span class="apidocSignatureSpan">protobufjs.ReflectionObject.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.ReflectionObject.prototype.toString">
            function <span class="apidocSignatureSpan">protobufjs.ReflectionObject.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Root">module protobufjs.Root</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Root.Root">
            function <span class="apidocSignatureSpan">protobufjs.</span>Root
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Root._configure">
            function <span class="apidocSignatureSpan">protobufjs.Root.</span>_configure
            <span class="apidocSignatureSpan">(Type_, parse_, common_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Root.fromJSON">
            function <span class="apidocSignatureSpan">protobufjs.Root.</span>fromJSON
            <span class="apidocSignatureSpan">(json, root)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">protobufjs.Root.</span>className</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Root.prototype">module protobufjs.Root.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Root.prototype._handleAdd">
            function <span class="apidocSignatureSpan">protobufjs.Root.prototype.</span>_handleAdd
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Root.prototype._handleRemove">
            function <span class="apidocSignatureSpan">protobufjs.Root.prototype.</span>_handleRemove
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Root.prototype.constructor">
            function <span class="apidocSignatureSpan">protobufjs.Root.prototype.</span>constructor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Root.prototype.load">
            function <span class="apidocSignatureSpan">protobufjs.Root.prototype.</span>load
            <span class="apidocSignatureSpan">(filename, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Root.prototype.loadSync">
            function <span class="apidocSignatureSpan">protobufjs.Root.prototype.</span>loadSync
            <span class="apidocSignatureSpan">(filename, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Root.prototype.resolveAll">
            function <span class="apidocSignatureSpan">protobufjs.Root.prototype.</span>resolveAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Root.prototype.resolvePath">
            function <span class="apidocSignatureSpan">protobufjs.Root.prototype.</span>resolvePath
            <span class="apidocSignatureSpan">(originPath, includePath, alreadyNormalized)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Service">module protobufjs.Service</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Service.Service">
            function <span class="apidocSignatureSpan">protobufjs.</span>Service
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Service.fromJSON">
            function <span class="apidocSignatureSpan">protobufjs.Service.</span>fromJSON
            <span class="apidocSignatureSpan">(name, json)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">protobufjs.Service.</span>className</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Service.prototype">module protobufjs.Service.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Service.prototype.add">
            function <span class="apidocSignatureSpan">protobufjs.Service.prototype.</span>add
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Service.prototype.constructor">
            function <span class="apidocSignatureSpan">protobufjs.Service.prototype.</span>constructor
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Service.prototype.create">
            function <span class="apidocSignatureSpan">protobufjs.Service.prototype.</span>create
            <span class="apidocSignatureSpan">(rpcImpl, requestDelimited, responseDelimited)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Service.prototype.get">
            function <span class="apidocSignatureSpan">protobufjs.Service.prototype.</span>get
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Service.prototype.remove">
            function <span class="apidocSignatureSpan">protobufjs.Service.prototype.</span>remove
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Service.prototype.resolveAll">
            function <span class="apidocSignatureSpan">protobufjs.Service.prototype.</span>resolveAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Service.prototype.toJSON">
            function <span class="apidocSignatureSpan">protobufjs.Service.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Type">module protobufjs.Type</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type.Type">
            function <span class="apidocSignatureSpan">protobufjs.</span>Type
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type.fromJSON">
            function <span class="apidocSignatureSpan">protobufjs.Type.</span>fromJSON
            <span class="apidocSignatureSpan">(name, json)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">protobufjs.Type.</span>className</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Type.prototype">module protobufjs.Type.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type.prototype.add">
            function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>add
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type.prototype.constructor">
            function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>constructor
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type.prototype.create">
            function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>create
            <span class="apidocSignatureSpan">(properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type.prototype.decode">
            function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>decode
            <span class="apidocSignatureSpan">(reader, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type.prototype.decodeDelimited">
            function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>decodeDelimited
            <span class="apidocSignatureSpan">(reader)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type.prototype.encode">
            function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>encode
            <span class="apidocSignatureSpan">(message, writer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type.prototype.encodeDelimited">
            function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>encodeDelimited
            <span class="apidocSignatureSpan">(message, writer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type.prototype.from">
            function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>from
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type.prototype.fromObject">
            function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>fromObject
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type.prototype.get">
            function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>get
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type.prototype.isReservedId">
            function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>isReservedId
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type.prototype.isReservedName">
            function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>isReservedName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type.prototype.remove">
            function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>remove
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type.prototype.resolveAll">
            function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>resolveAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type.prototype.setup">
            function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>setup
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type.prototype.toJSON">
            function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type.prototype.toObject">
            function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>toObject
            <span class="apidocSignatureSpan">(message, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Type.prototype.verify">
            function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>verify
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Writer">module protobufjs.Writer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.Writer">
            function <span class="apidocSignatureSpan">protobufjs.</span>Writer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer._configure">
            function <span class="apidocSignatureSpan">protobufjs.Writer.</span>_configure
            <span class="apidocSignatureSpan">(BufferWriter_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.alloc">
            function <span class="apidocSignatureSpan">protobufjs.Writer.</span>alloc
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.create">
            function <span class="apidocSignatureSpan">protobufjs.Writer.</span>create
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.Writer.prototype">module protobufjs.Writer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.prototype.bool">
            function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>bool
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.prototype.bytes">
            function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>bytes
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.prototype.double">
            function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>double
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.prototype.finish">
            function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>finish
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.prototype.fixed32">
            function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>fixed32
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.prototype.fixed64">
            function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>fixed64
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.prototype.float">
            function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>float
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.prototype.fork">
            function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>fork
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.prototype.int32">
            function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>int32
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.prototype.int64">
            function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>int64
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.prototype.ldelim">
            function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>ldelim
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.prototype.push">
            function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>push
            <span class="apidocSignatureSpan">(fn, len, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.prototype.reset">
            function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.prototype.sfixed32">
            function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>sfixed32
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.prototype.sfixed64">
            function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>sfixed64
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.prototype.sint32">
            function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>sint32
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.prototype.sint64">
            function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>sint64
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.prototype.string">
            function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>string
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.prototype.uint32">
            function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>uint32
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.Writer.prototype.uint64">
            function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>uint64
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.converter">module protobufjs.converter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.converter.fromObject">
            function <span class="apidocSignatureSpan">protobufjs.converter.</span>fromObject
            <span class="apidocSignatureSpan">(mtype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.converter.toObject">
            function <span class="apidocSignatureSpan">protobufjs.converter.</span>toObject
            <span class="apidocSignatureSpan">(mtype)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.rpc">module protobufjs.rpc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.rpc.Service">
            function <span class="apidocSignatureSpan">protobufjs.rpc.</span>Service
            <span class="apidocSignatureSpan">(rpcImpl, requestDelimited, responseDelimited)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.rpc.Service">module protobufjs.rpc.Service</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.rpc.Service.Service">
            function <span class="apidocSignatureSpan">protobufjs.rpc.</span>Service
            <span class="apidocSignatureSpan">(rpcImpl, requestDelimited, responseDelimited)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.rpc.Service.prototype">module protobufjs.rpc.Service.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.rpc.Service.prototype.constructor">
            function <span class="apidocSignatureSpan">protobufjs.rpc.Service.prototype.</span>constructor
            <span class="apidocSignatureSpan">(rpcImpl, requestDelimited, responseDelimited)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.rpc.Service.prototype.end">
            function <span class="apidocSignatureSpan">protobufjs.rpc.Service.prototype.</span>end
            <span class="apidocSignatureSpan">(endedByRPC)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.rpc.Service.prototype.rpcCall">
            function <span class="apidocSignatureSpan">protobufjs.rpc.Service.prototype.</span>rpcCall
            <span class="apidocSignatureSpan">(method, requestCtor, responseCtor, request, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.tokenize">module protobufjs.tokenize</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.tokenize.tokenize">
            function <span class="apidocSignatureSpan">protobufjs.</span>tokenize
            <span class="apidocSignatureSpan">(source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.tokenize.unescape">
            function <span class="apidocSignatureSpan">protobufjs.tokenize.</span>unescape
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.util">module protobufjs.util</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">protobufjs.util.</span>isNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Array">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>Array
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>Buffer
            <span class="apidocSignatureSpan">(arg, encodingOrOffset, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.EventEmitter">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>EventEmitter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>Long
            <span class="apidocSignatureSpan">(low, high, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.LongBits">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>LongBits
            <span class="apidocSignatureSpan">(lo, hi)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.ProtocolError">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>ProtocolError
            <span class="apidocSignatureSpan">(message, properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util._Buffer_allocUnsafe">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>_Buffer_allocUnsafe
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util._Buffer_from">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>_Buffer_from
            <span class="apidocSignatureSpan">(value, encodingOrOffset, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util._configure">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>_configure
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.asPromise">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>asPromise
            <span class="apidocSignatureSpan">(fn, ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.codegen">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>codegen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.compareFieldsById">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>compareFieldsById
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.fetch">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>fetch
            <span class="apidocSignatureSpan">(filename, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.float">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>float
            <span class="apidocSignatureSpan">(exports)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.inquire">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>inquire
            <span class="apidocSignatureSpan">(moduleName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.isInteger">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>isInteger
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.isObject">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>isObject
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.isSet">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>isSet
            <span class="apidocSignatureSpan">(obj, prop)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.isString">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>isString
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.isset">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>isset
            <span class="apidocSignatureSpan">(obj, prop)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.lazyResolve">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>lazyResolve
            <span class="apidocSignatureSpan">(root, lazyTypes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.lcFirst">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>lcFirst
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.longFromHash">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>longFromHash
            <span class="apidocSignatureSpan">(hash, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.longToHash">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>longToHash
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.merge">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>merge
            <span class="apidocSignatureSpan">(dst, src, ifNotSet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.newBuffer">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>newBuffer
            <span class="apidocSignatureSpan">(sizeOrArray)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.newError">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>newError
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.oneOfGetter">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>oneOfGetter
            <span class="apidocSignatureSpan">(fieldNames)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.oneOfSetter">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>oneOfSetter
            <span class="apidocSignatureSpan">(fieldNames)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.pool">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>pool
            <span class="apidocSignatureSpan">(alloc, slice, size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.safeProp">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>safeProp
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.toArray">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>toArray
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.ucFirst">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>ucFirst
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.util.</span>base64</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.util.</span>emptyArray</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.util.</span>emptyObject</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.util.</span>key2Re</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.util.</span>key32Re</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.util.</span>key64Re</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.util.</span>path</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.util.</span>toJSONOptions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.util.</span>utf8</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.util.Buffer">module protobufjs.util.Buffer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.Buffer">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>Buffer
            <span class="apidocSignatureSpan">(arg, encodingOrOffset, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.alloc">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.</span>alloc
            <span class="apidocSignatureSpan">(size, fill, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.allocUnsafe">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.</span>allocUnsafe
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.allocUnsafeSlow">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.</span>allocUnsafeSlow
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.byteLength">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.</span>byteLength
            <span class="apidocSignatureSpan">(string, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.compare">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.</span>compare
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.concat">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.</span>concat
            <span class="apidocSignatureSpan">(list, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.from">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.</span>from
            <span class="apidocSignatureSpan">(value, encodingOrOffset, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.isBuffer">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.</span>isBuffer
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.isEncoding">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.</span>isEncoding
            <span class="apidocSignatureSpan">(encoding)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">protobufjs.util.Buffer.</span>poolSize</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.util.Buffer.prototype">module protobufjs.util.Buffer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.asciiSlice">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>asciiSlice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.asciiWrite">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>asciiWrite
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.base64Slice">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>base64Slice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.base64Write">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>base64Write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.compare">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>compare
            <span class="apidocSignatureSpan">(target, start, end, thisStart, thisEnd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.copy">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>copy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.equals">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>equals
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.fill">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>fill
            <span class="apidocSignatureSpan">(val, start, end, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.hexSlice">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>hexSlice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.hexWrite">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>hexWrite
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.includes">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>includes
            <span class="apidocSignatureSpan">(val, byteOffset, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.indexOf">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>indexOf
            <span class="apidocSignatureSpan">(val, byteOffset, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.inspect">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.lastIndexOf">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>lastIndexOf
            <span class="apidocSignatureSpan">(val, byteOffset, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.latin1Slice">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>latin1Slice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.latin1Write">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>latin1Write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.readDoubleBE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readDoubleBE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.readDoubleLE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readDoubleLE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.readFloatBE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readFloatBE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.readFloatLE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readFloatLE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.readInt16BE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readInt16BE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.readInt16LE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readInt16LE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.readInt32BE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readInt32BE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.readInt32LE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readInt32LE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.readInt8">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readInt8
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.readIntBE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readIntBE
            <span class="apidocSignatureSpan">(offset, byteLength, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.readIntLE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readIntLE
            <span class="apidocSignatureSpan">(offset, byteLength, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.readUInt16BE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readUInt16BE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.readUInt16LE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readUInt16LE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.readUInt32BE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readUInt32BE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.readUInt32LE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readUInt32LE
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.readUInt8">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readUInt8
            <span class="apidocSignatureSpan">(offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.readUIntBE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readUIntBE
            <span class="apidocSignatureSpan">(offset, byteLength, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.readUIntLE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readUIntLE
            <span class="apidocSignatureSpan">(offset, byteLength, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.slice">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>slice
            <span class="apidocSignatureSpan">(start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.swap16">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>swap16
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.swap32">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>swap32
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.swap64">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>swap64
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.toJSON">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.toString">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.ucs2Slice">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>ucs2Slice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.ucs2Write">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>ucs2Write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.utf8Slice">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>utf8Slice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.utf8Write">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>utf8Write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.write">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>write
            <span class="apidocSignatureSpan">(string, offset, length, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.writeDoubleBE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeDoubleBE
            <span class="apidocSignatureSpan">(val, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.writeDoubleLE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeDoubleLE
            <span class="apidocSignatureSpan">(val, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.writeFloatBE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeFloatBE
            <span class="apidocSignatureSpan">(val, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.writeFloatLE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeFloatLE
            <span class="apidocSignatureSpan">(val, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.writeInt16BE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeInt16BE
            <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.writeInt16LE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeInt16LE
            <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.writeInt32BE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeInt32BE
            <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.writeInt32LE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeInt32LE
            <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.writeInt8">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeInt8
            <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.writeIntBE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeIntBE
            <span class="apidocSignatureSpan">(value, offset, byteLength, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.writeIntLE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeIntLE
            <span class="apidocSignatureSpan">(value, offset, byteLength, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.writeUInt16BE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeUInt16BE
            <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.writeUInt16LE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeUInt16LE
            <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.writeUInt32BE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeUInt32BE
            <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.writeUInt32LE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeUInt32LE
            <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.writeUInt8">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeUInt8
            <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.writeUIntBE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeUIntBE
            <span class="apidocSignatureSpan">(value, offset, byteLength, noAssert)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Buffer.prototype.writeUIntLE">
            function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeUIntLE
            <span class="apidocSignatureSpan">(value, offset, byteLength, noAssert)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.util.EventEmitter">module protobufjs.util.EventEmitter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.EventEmitter.EventEmitter">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>EventEmitter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.util.EventEmitter.prototype">module protobufjs.util.EventEmitter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.EventEmitter.prototype.emit">
            function <span class="apidocSignatureSpan">protobufjs.util.EventEmitter.prototype.</span>emit
            <span class="apidocSignatureSpan">(evt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.EventEmitter.prototype.off">
            function <span class="apidocSignatureSpan">protobufjs.util.EventEmitter.prototype.</span>off
            <span class="apidocSignatureSpan">(evt, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.EventEmitter.prototype.on">
            function <span class="apidocSignatureSpan">protobufjs.util.EventEmitter.prototype.</span>on
            <span class="apidocSignatureSpan">(evt, fn, ctx)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.util.Long">module protobufjs.util.Long</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.Long">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>Long
            <span class="apidocSignatureSpan">(low, high, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.fromBits">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.</span>fromBits
            <span class="apidocSignatureSpan">(lowBits, highBits, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.fromInt">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.</span>fromInt
            <span class="apidocSignatureSpan">(value, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.fromNumber">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.</span>fromNumber
            <span class="apidocSignatureSpan">(value, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.fromString">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.</span>fromString
            <span class="apidocSignatureSpan">(str, unsigned, radix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.fromValue">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.</span>fromValue
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.isLong">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.</span>isLong
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.util.Long.</span>MAX_UNSIGNED_VALUE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.util.Long.</span>MAX_VALUE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.util.Long.</span>MIN_VALUE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.util.Long.</span>NEG_ONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.util.Long.</span>ONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.util.Long.</span>UONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.util.Long.</span>UZERO</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.util.Long.</span>ZERO</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.util.Long.prototype">module protobufjs.util.Long.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.add">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>add
            <span class="apidocSignatureSpan">(addend)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.and">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>and
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.comp">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>comp
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.compare">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>compare
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.div">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>div
            <span class="apidocSignatureSpan">(divisor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.divide">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>divide
            <span class="apidocSignatureSpan">(divisor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.eq">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>eq
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.equals">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>equals
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.getHighBits">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>getHighBits
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.getHighBitsUnsigned">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>getHighBitsUnsigned
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.getLowBits">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>getLowBits
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.getLowBitsUnsigned">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>getLowBitsUnsigned
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.getNumBitsAbs">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>getNumBitsAbs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.greaterThan">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>greaterThan
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.greaterThanOrEqual">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>greaterThanOrEqual
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.gt">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>gt
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.gte">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>gte
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.isEven">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>isEven
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.isNegative">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>isNegative
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.isOdd">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>isOdd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.isPositive">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>isPositive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.isZero">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>isZero
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.lessThan">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>lessThan
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.lessThanOrEqual">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>lessThanOrEqual
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.lt">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>lt
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.lte">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>lte
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.mod">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>mod
            <span class="apidocSignatureSpan">(divisor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.modulo">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>modulo
            <span class="apidocSignatureSpan">(divisor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.mul">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>mul
            <span class="apidocSignatureSpan">(multiplier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.multiply">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>multiply
            <span class="apidocSignatureSpan">(multiplier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.neg">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>neg
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.negate">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>negate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.neq">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>neq
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.not">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>not
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.notEquals">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>notEquals
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.or">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>or
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.shiftLeft">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>shiftLeft
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.shiftRight">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>shiftRight
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.shiftRightUnsigned">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>shiftRightUnsigned
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.shl">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>shl
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.shr">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>shr
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.shru">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>shru
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.sub">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>sub
            <span class="apidocSignatureSpan">(subtrahend)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.subtract">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>subtract
            <span class="apidocSignatureSpan">(subtrahend)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.toBytes">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>toBytes
            <span class="apidocSignatureSpan">(le)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.toBytesBE">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>toBytesBE
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.toBytesLE">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>toBytesLE
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.toInt">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>toInt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.toNumber">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>toNumber
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.toSigned">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>toSigned
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.toString">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>toString
            <span class="apidocSignatureSpan">(radix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.toUnsigned">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>toUnsigned
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.Long.prototype.xor">
            function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>xor
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.util.LongBits">module protobufjs.util.LongBits</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.LongBits.LongBits">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>LongBits
            <span class="apidocSignatureSpan">(lo, hi)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.LongBits.from">
            function <span class="apidocSignatureSpan">protobufjs.util.LongBits.</span>from
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.LongBits.fromHash">
            function <span class="apidocSignatureSpan">protobufjs.util.LongBits.</span>fromHash
            <span class="apidocSignatureSpan">(hash)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.LongBits.fromNumber">
            function <span class="apidocSignatureSpan">protobufjs.util.LongBits.</span>fromNumber
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">protobufjs.util.LongBits.</span>zero</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">protobufjs.util.LongBits.</span>zeroHash</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.util.LongBits.prototype">module protobufjs.util.LongBits.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.LongBits.prototype.length">
            function <span class="apidocSignatureSpan">protobufjs.util.LongBits.prototype.</span>length
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.LongBits.prototype.toHash">
            function <span class="apidocSignatureSpan">protobufjs.util.LongBits.prototype.</span>toHash
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.LongBits.prototype.toLong">
            function <span class="apidocSignatureSpan">protobufjs.util.LongBits.prototype.</span>toLong
            <span class="apidocSignatureSpan">(unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.LongBits.prototype.toNumber">
            function <span class="apidocSignatureSpan">protobufjs.util.LongBits.prototype.</span>toNumber
            <span class="apidocSignatureSpan">(unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.LongBits.prototype.zzDecode">
            function <span class="apidocSignatureSpan">protobufjs.util.LongBits.prototype.</span>zzDecode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.LongBits.prototype.zzEncode">
            function <span class="apidocSignatureSpan">protobufjs.util.LongBits.prototype.</span>zzEncode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.util.ProtocolError">module protobufjs.util.ProtocolError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.ProtocolError.ProtocolError">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>ProtocolError
            <span class="apidocSignatureSpan">(message, properties)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.util.ProtocolError.prototype">module protobufjs.util.ProtocolError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.ProtocolError.prototype.constructor">
            function <span class="apidocSignatureSpan">protobufjs.util.ProtocolError.prototype.</span>constructor
            <span class="apidocSignatureSpan">(message, properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.ProtocolError.prototype.toString">
            function <span class="apidocSignatureSpan">protobufjs.util.ProtocolError.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.util.base64">module protobufjs.util.base64</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.base64.decode">
            function <span class="apidocSignatureSpan">protobufjs.util.base64.</span>decode
            <span class="apidocSignatureSpan">(string, buffer, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.base64.encode">
            function <span class="apidocSignatureSpan">protobufjs.util.base64.</span>encode
            <span class="apidocSignatureSpan">(buffer, start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.base64.length">
            function <span class="apidocSignatureSpan">protobufjs.util.base64.</span>length
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.base64.test">
            function <span class="apidocSignatureSpan">protobufjs.util.base64.</span>test
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.util.codegen">module protobufjs.util.codegen</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">protobufjs.util.codegen.</span>supported</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">protobufjs.util.codegen.</span>verbose</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.codegen.codegen">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>codegen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.codegen.sprintf">
            function <span class="apidocSignatureSpan">protobufjs.util.codegen.</span>sprintf
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.util.fetch">module protobufjs.util.fetch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.fetch.fetch">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>fetch
            <span class="apidocSignatureSpan">(filename, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.fetch.xhr">
            function <span class="apidocSignatureSpan">protobufjs.util.fetch.</span>xhr
            <span class="apidocSignatureSpan">(filename, options, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.util.float">module protobufjs.util.float</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.float.float">
            function <span class="apidocSignatureSpan">protobufjs.util.</span>float
            <span class="apidocSignatureSpan">(exports)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.float.readDoubleBE">
            function <span class="apidocSignatureSpan">protobufjs.util.float.</span>readDoubleBE
            <span class="apidocSignatureSpan">(buf, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.float.readDoubleLE">
            function <span class="apidocSignatureSpan">protobufjs.util.float.</span>readDoubleLE
            <span class="apidocSignatureSpan">(buf, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.float.readFloatBE">
            function <span class="apidocSignatureSpan">protobufjs.util.float.</span>readFloatBE
            <span class="apidocSignatureSpan">(buf, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.float.readFloatLE">
            function <span class="apidocSignatureSpan">protobufjs.util.float.</span>readFloatLE
            <span class="apidocSignatureSpan">(buf, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.float.writeDoubleBE">
            function <span class="apidocSignatureSpan">protobufjs.util.float.</span>writeDoubleBE
            <span class="apidocSignatureSpan">(val, buf, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.float.writeDoubleLE">
            function <span class="apidocSignatureSpan">protobufjs.util.float.</span>writeDoubleLE
            <span class="apidocSignatureSpan">(val, buf, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.float.writeFloatBE">
            function <span class="apidocSignatureSpan">protobufjs.util.float.</span>writeFloatBE
            <span class="apidocSignatureSpan">(val, buf, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.float.writeFloatLE">
            function <span class="apidocSignatureSpan">protobufjs.util.float.</span>writeFloatLE
            <span class="apidocSignatureSpan">(val, buf, pos)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.util.path">module protobufjs.util.path</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.path.isAbsolute">
            function <span class="apidocSignatureSpan">protobufjs.util.path.</span>isAbsolute
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.path.normalize">
            function <span class="apidocSignatureSpan">protobufjs.util.path.</span>normalize
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.path.resolve">
            function <span class="apidocSignatureSpan">protobufjs.util.path.</span>resolve
            <span class="apidocSignatureSpan">(originPath, includePath, alreadyNormalized)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.util.toJSONOptions">module protobufjs.util.toJSONOptions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.toJSONOptions.bytes">
            function <span class="apidocSignatureSpan">protobufjs.util.toJSONOptions.</span>bytes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.toJSONOptions.enums">
            function <span class="apidocSignatureSpan">protobufjs.util.toJSONOptions.</span>enums
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.toJSONOptions.longs">
            function <span class="apidocSignatureSpan">protobufjs.util.toJSONOptions.</span>longs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.util.toJSONOptions.longs.prototype">module protobufjs.util.toJSONOptions.longs.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.toJSONOptions.longs.prototype.entityify">
            function <span class="apidocSignatureSpan">protobufjs.util.toJSONOptions.longs.prototype.</span>entityify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.toJSONOptions.longs.prototype.isAlpha">
            function <span class="apidocSignatureSpan">protobufjs.util.toJSONOptions.longs.prototype.</span>isAlpha
            <span class="apidocSignatureSpan">( )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.toJSONOptions.longs.prototype.isDigit">
            function <span class="apidocSignatureSpan">protobufjs.util.toJSONOptions.longs.prototype.</span>isDigit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.toJSONOptions.longs.prototype.supplant">
            function <span class="apidocSignatureSpan">protobufjs.util.toJSONOptions.longs.prototype.</span>supplant
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.protobufjs.util.utf8">module protobufjs.util.utf8</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.utf8.length">
            function <span class="apidocSignatureSpan">protobufjs.util.utf8.</span>length
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.utf8.read">
            function <span class="apidocSignatureSpan">protobufjs.util.utf8.</span>read
            <span class="apidocSignatureSpan">(buffer, start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.protobufjs.util.utf8.write">
            function <span class="apidocSignatureSpan">protobufjs.util.utf8.</span>write
            <span class="apidocSignatureSpan">(string, buffer, offset)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs" id="apidoc.module.protobufjs">module protobufjs</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.BufferReader" id="apidoc.element.protobufjs.BufferReader">
        function <span class="apidocSignatureSpan">protobufjs.</span>BufferReader
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.BufferWriter" id="apidoc.element.protobufjs.BufferWriter">
        function <span class="apidocSignatureSpan">protobufjs.</span>BufferWriter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BufferWriter() {
    Writer.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Class" id="apidoc.element.protobufjs.Class">
        function <span class="apidocSignatureSpan">protobufjs.</span>Class
        <span class="apidocSignatureSpan">(type, ctor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Class(type, ctor) {
    if (!Type)
        Type = require("./type");

    if (!(type instanceof Type))
        throw TypeError("type must be a Type");

    if (ctor) {
        if (typeof ctor !== "function")
            throw TypeError("ctor must be a function");
    } else
        ctor = Class.generate(type).eof(type.name); // named constructor function (codegen is required anyway)

    // Let's pretend...
    ctor.constructor = Class;

    // new Class() -&gt; Message.prototype
    (ctor.prototype = new Message()).constructor = ctor;

    // Static methods on Message are instance methods on Class and vice versa
    util.merge(ctor, Message, true);

    // Classes and messages reference their reflected type
    ctor.$type = type;
    ctor.prototype.$type = type;

    // Messages have non-enumerable default values on their prototype
    var i = 0;
    for (; i &lt; /* initializes */ type.fieldsArray.length; ++i) {
        // objects on the prototype must be immmutable. users must assign a new object instance and
        // cannot use Array#push on empty arrays on the prototype for example, as this would modify
        // the value on the prototype for ALL messages of this type. Hence, these objects are frozen.
        ctor.prototype[type._fieldsArray[i].name] = Array.isArray(type._fieldsArray[i].resolve().defaultValue)
            ? util.emptyArray
            : util.isObject(type._fieldsArray[i].defaultValue) &amp;&amp; !type._fieldsArray[i].long
              ? util.emptyObject
              : type._fieldsArray[i].defaultValue; // if a long, it is frozen when initialized
    }

    // Messages have non-enumerable getters and setters for each virtual oneof field
    var ctorProperties = {};
    for (i = 0; i &lt; /* initializes */ type.oneofsArray.length; ++i)
        ctorProperties[type._oneofsArray[i].resolve().name] = {
            get: util.oneOfGetter(type._oneofsArray[i].oneof),
            set: util.oneOfSetter(type._oneofsArray[i].oneof)
        };
    if (i)
        Object.defineProperties(ctor.prototype, ctorProperties);

    // Register
    type.ctor = ctor;

    return ctor.prototype;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Enum" id="apidoc.element.protobufjs.Enum">
        function <span class="apidocSignatureSpan">protobufjs.</span>Enum
        <span class="apidocSignatureSpan">(name, values, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Enum(name, values, options) {
    ReflectionObject.call(this, name, options);

    if (values &amp;&amp; typeof values !== "object")
        throw TypeError("values must be an object");

    /**
     * Enum values by id.
     * @type {Object.&lt;number,string&gt;}
     */
    this.valuesById = {};

    /**
     * Enum values by name.
     * @type {Object.&lt;string,number&gt;}
     */
    this.values = Object.create(this.valuesById); // toJSON, marker

    /**
     * Value comment texts, if any.
     * @type {Object.&lt;string,string&gt;}
     */
    this.comments = {};

    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
    // compatible enum. This is used by pbts to write actual enum definitions that work for
    // static and reflection code alike instead of emitting generic object definitions.

    if (values)
        for (var keys = Object.keys(values), i = 0; i &lt; keys.length; ++i)
            this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Field" id="apidoc.element.protobufjs.Field">
        function <span class="apidocSignatureSpan">protobufjs.</span>Field
        <span class="apidocSignatureSpan">(name, id, type, rule, extend, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Field(name, id, type, rule, extend, options) {

    if (util.isObject(rule)) {
        options = rule;
        rule = extend = undefined;
    } else if (util.isObject(extend)) {
        options = extend;
        extend = undefined;
    }

    ReflectionObject.call(this, name, options);

    if (!util.isInteger(id) || id &lt; 0)
        throw TypeError("id must be a non-negative integer");

    if (!util.isString(type))
        throw TypeError("type must be a string");

    if (rule !== undefined &amp;&amp; !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");

    if (extend !== undefined &amp;&amp; !util.isString(extend))
        throw TypeError("extend must be a string");

    /**
     * Field rule, if any.
     * @type {string|undefined}
     */
    this.rule = rule &amp;&amp; rule !== "optional" ? rule : undefined; // toJSON

    /**
     * Field type.
     * @type {string}
     */
    this.type = type; // toJSON

    /**
     * Unique field id.
     * @type {number}
     */
    this.id = id; // toJSON, marker

    /**
     * Extended type if different from parent.
     * @type {string|undefined}
     */
    this.extend = extend || undefined; // toJSON

    /**
     * Whether this field is required.
     * @type {boolean}
     */
    this.required = rule === "required";

    /**
     * Whether this field is optional.
     * @type {boolean}
     */
    this.optional = !this.required;

    /**
     * Whether this field is repeated.
     * @type {boolean}
     */
    this.repeated = rule === "repeated";

    /**
     * Whether this field is a map or not.
     * @type {boolean}
     */
    this.map = false;

    /**
     * Message this field belongs to.
     * @type {?Type}
     */
    this.message = null;

    /**
     * OneOf this field belongs to, if any,
     * @type {?OneOf}
     */
    this.partOf = null;

    /**
     * The field type's default value.
     * @type {*}
     */
    this.typeDefault = null;

    /**
     * The field's default value on prototypes.
     * @type {*}
     */
    this.defaultValue = null;

    /**
     * Whether this field's value should be treated as a long.
     * @type {boolean}
     */
    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

    /**
     * Whether this field's value is a buffer.
     * @type {boolean}
     */
    this.bytes = type === "bytes";

    /**
     * Resolved type if not a basic type.
     * @type {?(Type|Enum)}
     */
    this.resolvedType = null;

    /**
     * Sister-field within the extended type if a declaring extension field.
     * @type {?Field}
     */
    this.extensionField = null;

    /**
     * Sister-field within the declaring namespace if an extended field.
     * @type {?Field}
     */
    this.declaringField = null;

    /**
     * Internally remembers whether this field is packed.
     * @type {?boolean}
     * @private
     */
    this._packed = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.MapField" id="apidoc.element.protobufjs.MapField">
        function <span class="apidocSignatureSpan">protobufjs.</span>MapField
        <span class="apidocSignatureSpan">(name, id, keyType, type, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MapField(name, id, keyType, type, options) {
    Field.call(this, name, id, type, options);

    /* istanbul ignore if */
    if (!util.isString(keyType))
        throw TypeError("keyType must be a string");

    /**
     * Key type.
     * @type {string}
     */
    this.keyType = keyType; // toJSON, marker

    /**
     * Resolved key type if not a basic type.
     * @type {?ReflectionObject}
     */
    this.resolvedKeyType = null;

    // Overrides Field#map
    this.map = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Message" id="apidoc.element.protobufjs.Message">
        function <span class="apidocSignatureSpan">protobufjs.</span>Message
        <span class="apidocSignatureSpan">(properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Message(properties) {
    // not used internally
    if (properties)
        for (var keys = Object.keys(properties), i = 0; i &lt; keys.length; ++i)
            this[keys[i]] = properties[keys[i]];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Method" id="apidoc.element.protobufjs.Method">
        function <span class="apidocSignatureSpan">protobufjs.</span>Method
        <span class="apidocSignatureSpan">(name, type, requestType, responseType, requestStream, responseStream, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Method(name, type, requestType, responseType, requestStream, responseStream, options) {

    /* istanbul ignore next */
    if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = undefined;
    } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = undefined;
    }

    /* istanbul ignore if */
    if (!(type === undefined || util.isString(type)))
        throw TypeError("type must be a string");

    /* istanbul ignore if */
    if (!util.isString(requestType))
        throw TypeError("requestType must be a string");

    /* istanbul ignore if */
    if (!util.isString(responseType))
        throw TypeError("responseType must be a string");

    ReflectionObject.call(this, name, options);

    /**
     * Method type.
     * @type {string}
     */
    this.type = type || "rpc"; // toJSON

    /**
     * Request type.
     * @type {string}
     */
    this.requestType = requestType; // toJSON, marker

    /**
     * Whether requests are streamed or not.
     * @type {boolean|undefined}
     */
    this.requestStream = requestStream ? true : undefined; // toJSON

    /**
     * Response type.
     * @type {string}
     */
    this.responseType = responseType; // toJSON

    /**
     * Whether responses are streamed or not.
     * @type {boolean|undefined}
     */
    this.responseStream = responseStream ? true : undefined; // toJSON

    /**
     * Resolved request type.
     * @type {?Type}
     */
    this.resolvedRequestType = null;

    /**
     * Resolved response type.
     * @type {?Type}
     */
    this.resolvedResponseType = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Namespace" id="apidoc.element.protobufjs.Namespace">
        function <span class="apidocSignatureSpan">protobufjs.</span>Namespace
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Namespace(name, options) {
    ReflectionObject.call(this, name, options);

    /**
     * Nested objects by name.
     * @type {Object.&lt;string,ReflectionObject&gt;|undefined}
     */
    this.nested = undefined; // toJSON

    /**
     * Cached nested objects as an array.
     * @type {?ReflectionObject[]}
     * @private
     */
    this._nestedArray = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.OneOf" id="apidoc.element.protobufjs.OneOf">
        function <span class="apidocSignatureSpan">protobufjs.</span>OneOf
        <span class="apidocSignatureSpan">(name, fieldNames, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OneOf(name, fieldNames, options) {
    if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = undefined;
    }
    ReflectionObject.call(this, name, options);

    /* istanbul ignore if */
    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");

    /**
     * Field names that belong to this oneof.
     * @type {string[]}
     */
    this.oneof = fieldNames || []; // toJSON, marker

    /**
     * Fields that belong to this oneof as an array for iteration.
     * @type {Field[]}
     * @readonly
     */
    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Reader" id="apidoc.element.protobufjs.Reader">
        function <span class="apidocSignatureSpan">protobufjs.</span>Reader
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (process.argv.length &gt; 3 &amp;&amp; /^\d+$/.test(process.argv[3]))
count = parseInt(process.argv[3], 10);
process.stdout.write(" x " + count + "\n");

function setupBrowser() {
protobuf.Writer.create = function create_browser() { return new protobuf.Writer(); };
protobuf.Reader.create = function create_browser(buf) { return new protobuf.<span class="apidocCodeKeywordSpan">Reader</span>(buf
); };
}

switch (process.argv[2]) {
case "encode-browser":
    setupBrowser();
    // eslint-disable-line no-fallthrough
case "encode":
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.ReflectionObject" id="apidoc.element.protobufjs.ReflectionObject">
        function <span class="apidocSignatureSpan">protobufjs.</span>ReflectionObject
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReflectionObject(name, options) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (options &amp;&amp; !util.isObject(options))
        throw TypeError("options must be an object");

    /**
     * Options.
     * @type {Object.&lt;string,*&gt;|undefined}
     */
    this.options = options; // toJSON

    /**
     * Unique name within its namespace.
     * @type {string}
     */
    this.name = name;

    /**
     * Parent namespace.
     * @type {?Namespace}
     */
    this.parent = null;

    /**
     * Whether already resolved or not.
     * @type {boolean}
     */
    this.resolved = false;

    /**
     * Comment text, if any.
     * @type {?string}
     */
    this.comment = null;

    /**
     * Defining file name.
     * @type {?string}
     */
    this.filename = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Root" id="apidoc.element.protobufjs.Root">
        function <span class="apidocSignatureSpan">protobufjs.</span>Root
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Root(options) {
    Namespace.call(this, "", options);

    /**
     * Deferred extension fields.
     * @type {Field[]}
     */
    this.deferred = [];

    /**
     * Resolved file names of loaded files.
     * @type {string[]}
     */
    this.files = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Service" id="apidoc.element.protobufjs.Service">
        function <span class="apidocSignatureSpan">protobufjs.</span>Service
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Service(name, options) {
    Namespace.call(this, name, options);

    /**
     * Service methods.
     * @type {Object.&lt;string,Method&gt;}
     */
    this.methods = {}; // toJSON, marker

    /**
     * Cached methods as an array.
     * @type {?Method[]}
     * @private
     */
    this._methodsArray = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Type" id="apidoc.element.protobufjs.Type">
        function <span class="apidocSignatureSpan">protobufjs.</span>Type
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Type(name, options) {
    Namespace.call(this, name, options);

    /**
     * Message fields.
     * @type {Object.&lt;string,Field&gt;}
     */
    this.fields = {};  // toJSON, marker

    /**
     * Oneofs declared within this namespace, if any.
     * @type {Object.&lt;string,OneOf&gt;}
     */
    this.oneofs = undefined; // toJSON

    /**
     * Extension ranges, if any.
     * @type {number[][]}
     */
    this.extensions = undefined; // toJSON

    /**
     * Reserved ranges, if any.
     * @type {Array.&lt;number[]|string&gt;}
     */
    this.reserved = undefined; // toJSON

    /*?
     * Whether this type is a legacy group.
     * @type {boolean|undefined}
     */
    this.group = undefined; // toJSON

    /**
     * Cached fields by id.
     * @type {?Object.&lt;number,Field&gt;}
     * @private
     */
    this._fieldsById = null;

    /**
     * Cached fields as an array.
     * @type {?Field[]}
     * @private
     */
    this._fieldsArray = null;

    /**
     * Cached oneofs as an array.
     * @type {?OneOf[]}
     * @private
     */
    this._oneofsArray = null;

    /**
     * Cached constructor.
     * @type {*}
     * @private
     */
    this._ctor = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer" id="apidoc.element.protobufjs.Writer">
        function <span class="apidocSignatureSpan">protobufjs.</span>Writer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {?Object}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (process.argv.length &gt; 3 &amp;&amp; /^\d+$/.test(process.argv[3]))
count = parseInt(process.argv[3], 10);
process.stdout.write(" x " + count + "\n");

function setupBrowser() {
protobuf.Writer.create = function create_browser() { return new protobuf.<span class="apidocCodeKeywordSpan">Writer</span>(); };
protobuf.Reader.create = function create_browser(buf) { return new protobuf.Reader(buf); };
}

switch (process.argv[2]) {
case "encode-browser":
    setupBrowser();
    // eslint-disable-line no-fallthrough
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.common" id="apidoc.element.protobufjs.common">
        function <span class="apidocSignatureSpan">protobufjs.</span>common
        <span class="apidocSignatureSpan">(name, json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function common(name, json) {
    if (!commonRe.test(name)) {
        name = "google/protobuf/" + name + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
    }
    common[name] = json;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @property {Object.&lt;string,*&gt;} google/protobuf/duration.proto Duration
 * @property {Object.&lt;string,*&gt;} google/protobuf/empty.proto Empty
 * @property {Object.&lt;string,*&gt;} google/protobuf/struct.proto Struct, Value, NullValue and ListValue
 * @property {Object.&lt;string,*&gt;} google/protobuf/timestamp.proto Timestamp
 * @property {Object.&lt;string,*&gt;} google/protobuf/wrappers.proto Wrappers
 * @example
 * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)
 * protobuf.<span class="apidocCodeKeywordSpan">common</span>("descriptor", descriptorJson);
 *
 * // manually provides a custom definition (uses my.foo namespace)
 * protobuf.common("my/foo/bar.proto", myFooBarJson);
 */
function common(name, json) {
if (!commonRe.test(name)) {
    name = "google/protobuf/" + name + ".proto";
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.configure" id="apidoc.element.protobufjs.configure">
        function <span class="apidocSignatureSpan">protobufjs.</span>configure
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function configure() {
    protobuf.Reader._configure(protobuf.BufferReader);
    protobuf.util._configure();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var protobuf = global.protobuf = $require(entries[0]);

// Be nice to AMD
if (typeof define === "function" &amp;&amp; define.amd)
    define(["long"], function(Long) {
        if (Long &amp;&amp; Long.isLong) {
            protobuf.util.Long = Long;
            protobuf.<span class="apidocCodeKeywordSpan">configure</span>();
        }
        return protobuf;
    });

// Be nice to CommonJS
if (typeof module === "object" &amp;&amp; module &amp;&amp; module.exports)
    module.exports = protobuf;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.decoder" id="apidoc.element.protobufjs.decoder">
        function <span class="apidocSignatureSpan">protobufjs.</span>decoder
        <span class="apidocSignatureSpan">(mtype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decoder(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen("r", "l")
    ("if(!(r instanceof Reader))")
        ("r=Reader.create(r)")
    ("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length
 ? ",k" : ""))
    ("while(r.pos&lt;c){")
        ("var t=r.uint32()");
    if (mtype.group) gen
        ("if((t&amp;7)===4)")
            ("break");
    gen
        ("switch(t&gt;&gt;&gt;3){");

    var i = 0;
    for (; i &lt; /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            type  = field.resolvedType instanceof Enum ? "uint32" : field.type,
            ref   = "m" + util.safeProp(field.name); gen
            ("case %d:", field.id);

        // Map fields
        if (field.map) { gen
                ("r.skip().pos++") // assumes id 1 + key wireType
                ("if(%s===util.emptyObject)", ref)
                    ("%s={}", ref)
                ("k=r.%s()", field.keyType)
                ("r.pos++"); // assumes id 2 + value wireType
            if (types.long[field.keyType] !== undefined) {
                if (types.basic[type] === undefined) gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=types[%d].decode(r,r.uint32())", ref, i); // can't be groups
                else gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=r.%s()", ref, type);
            } else {
                if (types.basic[type] === undefined) gen
                ("%s[k]=types[%d].decode(r,r.uint32())", ref, i); // can't be groups
                else gen
                ("%s[k]=r.%s()", ref, type);
            }

        // Repeated fields
        } else if (field.repeated) { gen

                ("if(!(%s&amp;&amp;%s.length))", ref, ref)
                    ("%s=[]", ref);

            // Packable (always check for forward and backward compatiblity)
            if (types.packed[type] !== undefined) gen
                ("if((t&amp;7)===2){")
                    ("var c2=r.uint32()+r.pos")
                    ("while(r.pos&lt;c2)")
                        ("%s.push(r.%s())", ref, type)
                ("}else");

            // Non-packed
            if (types.basic[type] === undefined) gen(field.resolvedType.group
                    ? "%s.push(types[%d].decode(r))"
                    : "%s.push(types[%d].decode(r,r.uint32()))", ref, i);
            else gen
                    ("%s.push(r.%s())", ref, type);

        // Non-repeated
        } else if (types.basic[type] === undefined) gen(field.resolvedType.group
                ? "%s=types[%d].decode(r)"
                : "%s=types[%d].decode(r,r.uint32())", ref, i);
        else gen
                ("%s=r.%s()", ref, type);
        gen
                ("break");
    // Unknown fields
    } gen
            ("default:")
                ("r.skipType(t&amp;7)")
                ("break")

        ("}")
    ("}");

    // Field presence
    for (i = 0; i &lt; mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required) gen
    ("if(!m.hasOwnProperty(%j))", rfield.name)
        ("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
    }

    return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline */
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.encoder" id="apidoc.element.protobufjs.encoder">
        function <span class="apidocSignatureSpan">protobufjs.</span>encoder
        <span class="apidocSignatureSpan">(mtype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encoder(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var gen = util.codegen("m", "w")
    ("if(!w)")
        ("w=Writer.create()");

    var i, ref;

    // "when a message is serialized its known fields should be written sequentially by field number"
    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);

    for (var i = 0; i &lt; fields.length; ++i) {
        var field    = fields[i].resolve(),
            index    = mtype._fieldsArray.indexOf(field),
            type     = field.resolvedType instanceof Enum ? "uint32" : field.type,
            wireType = types.basic[type];
            ref      = "m" + util.safeProp(field.name);

        // Map fields
        if (field.map) {
            gen
    ("if(%s&amp;&amp;m.hasOwnProperty(%j)){", ref, field.name)
        ("for(var ks=Object.keys(%s),i=0;i&lt;ks.length;++i){", ref)
            ("w.uint32(%d).fork().uint32(%d).%s(ks[i])", (field.id &lt;&lt; 3 | 2) &gt;&gt;&gt; 0, 8 | types.mapKey[field.keyType], field.keyType
);
            if (wireType === undefined) gen
            ("types[%d].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
            else gen
            (".uint32(%d).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
            gen
        ("}")
    ("}");

            // Repeated fields
        } else if (field.repeated) { gen
    ("if(%s&amp;&amp;%s.length){", ref, ref);

            // Packed repeated
            if (field.packed &amp;&amp; types.packed[type] !== undefined) { gen

        ("w.uint32(%d).fork()", (field.id &lt;&lt; 3 | 2) &gt;&gt;&gt; 0)
        ("for(var i=0;i&lt;%s.length;++i)", ref)
            ("w.%s(%s[i])", type, ref)
        ("w.ldelim()");

            // Non-packed
            } else { gen

        ("for(var i=0;i&lt;%s.length;++i)", ref);
                if (wireType === undefined)
            genTypePartial(gen, field, index, ref + "[i]");
                else gen
            ("w.uint32(%d).%s(%s[i])", (field.id &lt;&lt; 3 | wireType) &gt;&gt;&gt; 0, type, ref);

            } gen
    ("}");

        // Non-repeated
        } else {
            if (field.optional) {

                if (field.bytes || field.resolvedType &amp;&amp; !(field.resolvedType instanceof Enum)) gen
    ("if(%s&amp;&amp;m.hasOwnProperty(%j))", ref, field.name);
                else gen
    ("if(%s!=null&amp;&amp;m.hasOwnProperty(%j))", ref, field.name); // !== undefined &amp;&amp; !== null

            }

            if (wireType === undefined)
        genTypePartial(gen, field, index, ref);
            else gen
        ("w.uint32(%d).%s(%s)", (field.id &lt;&lt; 3 | wireType) &gt;&gt;&gt; 0, type, ref);

        }
    }

    return gen
    ("return w");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.load" id="apidoc.element.protobufjs.load">
        function <span class="apidocSignatureSpan">protobufjs.</span>load
        <span class="apidocSignatureSpan">(filename, root, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function load(filename, root, callback) {
    if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
    } else if (!root)
        root = new protobuf.Root();
    return root.load(filename, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

message AwesomeMessage {
string awesome_field = 1; // becomes awesomeField
}
```

```js
protobuf.<span class="apidocCodeKeywordSpan">load</span>("awesome.proto", function(err, root) {
if (err)
    throw err;

// Obtain a message type
var AwesomeMessage = root.lookupType("awesomepackage.AwesomeMessage");

// Exemplary payload
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.loadSync" id="apidoc.element.protobufjs.loadSync">
        function <span class="apidocSignatureSpan">protobufjs.</span>loadSync
        <span class="apidocSignatureSpan">(filename, root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadSync(filename, root) {
    if (!root)
        root = new protobuf.Root();
    return root.loadSync(filename);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.parse" id="apidoc.element.protobufjs.parse">
        function <span class="apidocSignatureSpan">protobufjs.</span>parse
        <span class="apidocSignatureSpan">(source, root, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(source, root, options) {
    /* eslint-disable callback-return */
    if (!(root instanceof Root)) {
        options = root;
        root = new Root();
    }
    if (!options)
        options = parse.defaults;

    var tn = tokenize(source),
        next = tn.next,
        push = tn.push,
        peek = tn.peek,
        skip = tn.skip,
        cmnt = tn.cmnt;

    var head = true,
        pkg,
        imports,
        weakImports,
        syntax,
        isProto3 = false;

    var ptr = root;

    var applyCase = options.keepCase ? function(name) { return name; } : camelCase;

    /* istanbul ignore next */
    function illegal(token, name, insideTryCatch) {
        var filename = parse.filename;
        if (!insideTryCatch)
            parse.filename = null;
        return Error("illegal " + (name || "token") + " '" + token + "' (" + (filename ? filename + ", " : "") + "line " + tn.line
() + ")");
    }

    function readString() {
        var values = [],
            token;
        do {
            /* istanbul ignore if */
            if ((token = next()) !== "\"" &amp;&amp; token !== "'")
                throw illegal(token);

            values.push(next());
            skip(token);
            token = peek();
        } while (token === "\"" || token === "'");
        return values.join("");
    }

    function readValue(acceptTypeRef) {
        var token = next();
        switch (token) {
            case "'":
            case "\"":
                push(token);
                return readString();
            case "true": case "TRUE":
                return true;
            case "false": case "FALSE":
                return false;
        }
        try {
            return parseNumber(token, /* insideTryCatch */ true);
        } catch (e) {

            /* istanbul ignore else */
            if (acceptTypeRef &amp;&amp; typeRefRe.test(token))
                return token;

            /* istanbul ignore next */
            throw illegal(token, "value");
        }
    }

    function readRanges(target, acceptStrings) {
        var token, start;
        do {
            if (acceptStrings &amp;&amp; ((token = peek()) === "\"" || token === "'"))
                target.push(readString());
            else
                target.push([ start = parseId(next()), skip("to", true) ? parseId(next()) : start ]);
        } while (skip(",", true));
        skip(";");
    }

    function parseNumber(token, insideTryCatch) {
        var sign = 1;
        if (token.charAt(0) === "-") {
            sign = -1;
            token = token.substring(1);
        }
        switch (token) {
            case "inf": case "INF": case "Inf":
                return sign * Infinity;
            case "nan": case "NAN": case "Nan": case "NaN":
                return NaN;
            case "0":
                return 0;
        }
        if (base10Re.test(token))
            return sign * parseInt(token, 10);
        if (base16Re.test(token))
            return sign * parseInt(token, 16);
        if (base8Re.test(token))
            return sign * parseInt(token, 8);

        /* istanbul ignore else */
        if (numberRe.test(token))
            return sign * parseFloat(token);

        /* istanbul ignore next */
        throw illegal(token, "number", insideTryCatch);
    }

    function parseId(token, acceptNegative) {
        switch (token) {
            case "max": case "MAX": case "Max":
                return 536870911;
            case "0":
                return 0;
        }

        /* istanbul ignore if */
        if (!acceptNegative &amp;&amp; token.charAt(0) === "-")
            throw illegal(token, "id");

        if (base10NegRe.test(token))
            return parseInt(token, 10);
        if (base16NegRe.test(token))
            return parseInt(token, 16);

        /* istanbul ignore else */
        if (base8NegRe.test(token))
            return parseInt(token, 8);

        /* istanbul ignore next */
        throw illeg ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        protobuf.Root.fromJSON(json).resolveAll();
return;
}

var Test, data, count;

if (process.argv.indexOf("--alt") &lt; 0) {
root = protobuf.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(require.resolve("../bench/bench.proto"
;)).toString("utf8")).root;
Test = root.lookup("Test");
json = JSON.stringify(root);
data = require("../bench/bench.json");
count = 10000000;
process.stdout.write("bench.proto");
} else {
root = protobuf.parse(fs.readFileSync(require.resolve("../tests/data/mapbox/vector_tile.proto")).toString("utf8&amp;#
x22;)).root;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.rpc.Service" id="apidoc.element.protobufjs.rpc.Service">
        function <span class="apidocSignatureSpan">protobufjs.</span>rpc.Service
        <span class="apidocSignatureSpan">(rpcImpl, requestDelimited, responseDelimited)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {?RPCImpl}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.tokenize" id="apidoc.element.protobufjs.tokenize">
        function <span class="apidocSignatureSpan">protobufjs.</span>tokenize
        <span class="apidocSignatureSpan">(source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tokenize(source) {
    /* eslint-disable callback-return */
    source = source.toString();

    var offset = 0,
        length = source.length,
        line = 1,
        commentType = null,
        commentText = null,
        commentLine = 0;

    var stack = [];

    var stringDelim = null;

    /* istanbul ignore next */
    /**
     * Creates an error for illegal syntax.
     * @param {string} subject Subject
     * @returns {Error} Error created
     * @inner
     */
    function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
    }

    /**
     * Reads a string till its end.
     * @returns {string} String read
     * @inner
     */
    function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
            throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape(match[1]);
    }

    /**
     * Gets the character at `pos` within the source.
     * @param {number} pos Position
     * @returns {string} Character
     * @inner
     */
    function charAt(pos) {
        return source.charAt(pos);
    }

    /**
     * Sets the current comment text.
     * @param {number} start Start offset
     * @param {number} end End offset
     * @returns {undefined}
     * @inner
     */
    function setComment(start, end) {
        commentType = source.charAt(start++);
        commentLine = line;
        var lines = source
            .substring(start, end)
            .split(setCommentSplitRe);
        for (var i = 0; i &lt; lines.length; ++i)
            lines[i] = lines[i].replace(setCommentRe, "").trim();
        commentText = lines
            .join("\n")
            .trim();
    }

    /**
     * Obtains the next token.
     * @returns {?string} Next token or `null` on eof
     * @inner
     */
    function next() {
        if (stack.length &gt; 0)
            return stack.shift();
        if (stringDelim)
            return readString();
        var repeat,
            prev,
            curr,
            start,
            isComment;
        do {
            if (offset === length)
                return null;
            repeat = false;
            while (whitespaceRe.test(curr = charAt(offset))) {
                if (curr === "\n")
                    ++line;
                if (++offset === length)
                    return null;
            }
            if (charAt(offset) === "/") {
                if (++offset === length)
                    throw illegal("comment");
                if (charAt(offset) === "/") { // Line
                    isComment = charAt(start = offset + 1) === "/";
                    while (charAt(++offset) !== "\n")
                        if (offset === length)
                            return null;
                    ++offset;
                    if (isComment)
                        setComment(start, offset - 1);
                    ++line;
                    repeat = true;
                } else if ((curr = charAt(offset)) === "*") { /* Block */
                    isComment = charAt(start = offset + 1) === "*";
                    do {
                        if (curr === "\n")
                            ++line;
                        if (++offset === length)
                            throw illegal("comment");
                        prev = curr;
                        curr = charAt(offset);
                    } while (prev !== "*" || curr !== "/");
                    ++offset;
                    if (isComment)
                        setComment(start, offset - 2);
                    repeat = true;
                } else
                    return "/";
            }
        } while (repeat);

        // offset !== length if we got here

        var end = offset;
        delimRe.lastIndex = 0; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer" id="apidoc.element.protobufjs.util.Buffer">
        function <span class="apidocSignatureSpan">protobufjs.</span>util.Buffer
        <span class="apidocSignatureSpan">(arg, encodingOrOffset, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      );
    }
    return Buffer.allocUnsafe(arg);
  }
  return Buffer.from(arg, encodingOrOffset, length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.EventEmitter" id="apidoc.element.protobufjs.util.EventEmitter">
        function <span class="apidocSignatureSpan">protobufjs.</span>util.EventEmitter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.&lt;string,*&gt;}
     * @private
     */
    this._listeners = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long" id="apidoc.element.protobufjs.util.Long">
        function <span class="apidocSignatureSpan">protobufjs.</span>util.Long
        <span class="apidocSignatureSpan">(low, high, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.LongBits" id="apidoc.element.protobufjs.util.LongBits">
        function <span class="apidocSignatureSpan">protobufjs.</span>util.LongBits
        <span class="apidocSignatureSpan">(lo, hi)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo &gt;&gt;&gt; 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi &gt;&gt;&gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.ProtocolError" id="apidoc.element.protobufjs.util.ProtocolError">
        function <span class="apidocSignatureSpan">protobufjs.</span>util.ProtocolError
        <span class="apidocSignatureSpan">(message, properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CustomError(message, properties) {

    if (!(this instanceof CustomError))
        return new CustomError(message, properties);

    // Error.call(this, message);
    // ^ just returns a new error instance because the ctor can be called as a function

    Object.defineProperty(this, "message", { get: function() { return message; } });

    /* istanbul ignore next */
    if (Error.captureStackTrace) // node
        Error.captureStackTrace(this, CustomError);
    else
        Object.defineProperty(this, "stack", { value: (new Error()).stack || "" });

    if (properties)
        merge(this, properties);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.codegen" id="apidoc.element.protobufjs.util.codegen">
        function <span class="apidocSignatureSpan">protobufjs.</span>util.codegen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function codegen() {
    var params = [],
        src    = [],
        indent = 1,
        inCase = false;
    for (var i = 0; i &lt; arguments.length;)
        params.push(arguments[i++]);

    /**
     * A codegen instance as returned by {@link codegen}, that also is a sprintf-like appender function.
     * @typedef Codegen
     * @type {function}
     * @param {string} format Format string
     * @param {...*} args Replacements
     * @returns {Codegen} Itself
     * @property {function(string=):string} str Stringifies the so far generated function source.
     * @property {function(string=, Object=):function} eof Ends generation and builds the function whilst applying a scope.
     */
    /**/
    function gen() {
        var args = [],
            i = 0;
        for (; i &lt; arguments.length;)
            args.push(arguments[i++]);
        var line = sprintf.apply(null, args);
        var level = indent;
        if (src.length) {
            var prev = src[src.length - 1];

            // block open or one time branch
            if (blockOpenRe.test(prev))
                level = ++indent; // keep
            else if (branchRe.test(prev))
                ++level; // once

            // casing
            if (casingRe.test(prev) &amp;&amp; !casingRe.test(line)) {
                level = ++indent;
                inCase = true;
            } else if (inCase &amp;&amp; breakRe.test(prev)) {
                level = --indent;
                inCase = false;
            }

            // block close
            if (blockCloseRe.test(line))
                level = --indent;
        }
        for (i = 0; i &lt; level; ++i)
            line = "\t" + line;
        src.push(line);
        return gen;
    }

    /**
     * Stringifies the so far generated function source.
     * @param {string} [name] Function name, defaults to generate an anonymous function
     * @returns {string} Function source using tabs for indentation
     * @inner
     */
    function str(name) {
        return "function" + (name ? " " + name.replace(/[^\w_$]/g, "_") : "") + "(" + params.join(",") + ") {\n" + src.join("\n") + "\n}";
    }

    gen.str = str;

    /**
     * Ends generation and builds the function whilst applying a scope.
     * @param {string} [name] Function name, defaults to generate an anonymous function
     * @param {Object.&lt;string,*&gt;} [scope] Function scope
     * @returns {function} The generated function, with scope applied if specified
     * @inner
     */
    function eof(name, scope) {
        if (typeof name === "object") {
            scope = name;
            name = undefined;
        }
        var source = gen.str(name);
        if (codegen.verbose)
            console.log("--- codegen ---\n" + source.replace(/^/mg, "&gt; ").replace(/\t/g, "  ")); // eslint-disable-line no-console
        var keys = Object.keys(scope || (scope = {}));
        return Function.apply(null, keys.concat("return " + source)).apply(null, keys.map(function(key) { return scope[key]; })); //
eslint-disable-line no-new-func
        //     ^ Creates a wrapper function with the scoped variable names as its parameters,
        //       calls it with the respective scoped variable values ^
        //       and returns our brand-new properly scoped function.
        //
        // This works because "Invoking the Function constructor as a function (without using the
        // new operator) has the same effect as invoking it as a constructor."
        // https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Function
    }

    gen.eof = eof;

    return gen;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.fetch" id="apidoc.element.protobufjs.util.fetch">
        function <span class="apidocSignatureSpan">protobufjs.</span>util.fetch
        <span class="apidocSignatureSpan">(filename, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fetch(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    } else if (!options)
        options = {};

    if (!callback)
        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
    if (!options.xhr &amp;&amp; fs &amp;&amp; fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
            return err &amp;&amp; typeof XMLHttpRequest !== "undefined"
                ? fetch.xhr(filename, options, callback)
                : err
                ? callback(err)
                : callback(null, options.binary ? contents : contents.toString("utf8"));
        });

    // use the XHR version otherwise.
    return fetch.xhr(filename, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.float" id="apidoc.element.protobufjs.util.float">
        function <span class="apidocSignatureSpan">protobufjs.</span>util.float
        <span class="apidocSignatureSpan">(exports)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val &lt; 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val &gt; 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val &gt; 3.4028234663852886e+38) // +-Infinity
                writeUint((sign &lt;&lt; 31 | 2139095040) &gt;&gt;&gt; 0, buf, pos);
            else if (val &lt; 1.1754943508222875e-38) // denormal
                writeUint((sign &lt;&lt; 31 | Math.round(val / 1.401298464324817e-45)) &gt;&gt;&gt; 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) &amp; 8388607;
                writeUint((sign &lt;&lt; 31 | exponent + 127 &lt;&lt; 23 | mantissa) &gt;&gt;&gt; 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint &gt;&gt; 31) * 2 + 1,
                exponent = uint &gt;&gt;&gt; 23 &amp; 255,
                mantissa = uint &amp; 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6] ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.verifier" id="apidoc.element.protobufjs.verifier">
        function <span class="apidocSignatureSpan">protobufjs.</span>verifier
        <span class="apidocSignatureSpan">(mtype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function verifier(mtype) {
    /* eslint-disable no-unexpected-multiline */

    var gen = util.codegen("m")
    ("if(typeof m!==\"object\"||m===null)")
        ("return%j", "object expected");
    var oneofs = mtype.oneofsArray,
        seenFirstField = {};
    if (oneofs.length) gen
    ("var p={}");

    for (var i = 0; i &lt; /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            ref   = "m" + util.safeProp(field.name);

        // map fields
        if (field.map) { gen
            ("if(%s!=null){", ref) // !== undefined &amp;&amp; !== null
                ("if(!util.isObject(%s))", ref)
                    ("return%j", invalid(field, "object"))
                ("var k=Object.keys(%s)", ref)
                ("for(var i=0;i&lt;k.length;++i){");
                    genVerifyKey(gen, field, "k[i]");
                    genVerifyValue(gen, field, i, ref + "[k[i]]")
                ("}")
            ("}");

        // repeated fields
        } else if (field.repeated) { gen
            ("if(%s!=null){", ref) // !== undefined &amp;&amp; !== null
                ("if(!Array.isArray(%s))", ref)
                    ("return%j", invalid(field, "array"))
                ("for(var i=0;i&lt;%s.length;++i){", ref);
                    genVerifyValue(gen, field, i, ref + "[i]")
                ("}")
            ("}");

        // required or present fields
        } else {
            if (field.optional) gen
            ("if(%s!=null){", ref); // !== undefined &amp;&amp; !== null
            if (field.partOf) {
                var oneofProp = util.safeProp(field.partOf.name);
                if (seenFirstField[field.partOf.name] === 1) gen
            ("if(p%s===1)", oneofProp)
                ("return%j", field.partOf.name + ": multiple values");
                seenFirstField[field.partOf.name] = 1;
                gen
            ("p%s=1", oneofProp);
            }
                genVerifyValue(gen, field, i, ref);
            if (field.optional) gen
            ("}");
        }
    } return gen
    ("return null");
    /* eslint-enable no-unexpected-multiline */
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.BufferReader" id="apidoc.module.protobufjs.BufferReader">module protobufjs.BufferReader</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.BufferReader.BufferReader" id="apidoc.element.protobufjs.BufferReader.BufferReader">
        function <span class="apidocSignatureSpan">protobufjs.</span>BufferReader
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.BufferReader.prototype" id="apidoc.module.protobufjs.BufferReader.prototype">module protobufjs.BufferReader.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.BufferReader.prototype._slice" id="apidoc.element.protobufjs.BufferReader.prototype._slice">
        function <span class="apidocSignatureSpan">protobufjs.BufferReader.prototype.</span>_slice
        <span class="apidocSignatureSpan">(start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function slice(start, end) {
  const srcLength = this.length;
  start = adjustOffset(start, srcLength);
  end = end !== undefined ? adjustOffset(end, srcLength) : srcLength;
  const newLength = end &gt; start ? end - start : 0;
  return new FastBuffer(this.buffer, this.byteOffset + start, newLength);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.BufferReader.prototype.constructor" id="apidoc.element.protobufjs.BufferReader.prototype.constructor">
        function <span class="apidocSignatureSpan">protobufjs.BufferReader.prototype.</span>constructor
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.BufferReader.prototype.string" id="apidoc.element.protobufjs.BufferReader.prototype.string">
        function <span class="apidocSignatureSpan">protobufjs.BufferReader.prototype.</span>string
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.BufferWriter" id="apidoc.module.protobufjs.BufferWriter">module protobufjs.BufferWriter</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.BufferWriter.BufferWriter" id="apidoc.element.protobufjs.BufferWriter.BufferWriter">
        function <span class="apidocSignatureSpan">protobufjs.</span>BufferWriter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BufferWriter() {
    Writer.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.BufferWriter.alloc" id="apidoc.element.protobufjs.BufferWriter.alloc">
        function <span class="apidocSignatureSpan">protobufjs.BufferWriter.</span>alloc
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function alloc_buffer(size) {
    return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.BufferWriter.prototype" id="apidoc.module.protobufjs.BufferWriter.prototype">module protobufjs.BufferWriter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.BufferWriter.prototype.bytes" id="apidoc.element.protobufjs.BufferWriter.prototype.bytes">
        function <span class="apidocSignatureSpan">protobufjs.BufferWriter.prototype.</span>bytes
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length &gt;&gt;&gt; 0;
    this.uint32(len);
    if (len)
        this.push(writeBytesBuffer, len, value);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.BufferWriter.prototype.constructor" id="apidoc.element.protobufjs.BufferWriter.prototype.constructor">
        function <span class="apidocSignatureSpan">protobufjs.BufferWriter.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BufferWriter() {
    Writer.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.BufferWriter.prototype.string" id="apidoc.element.protobufjs.BufferWriter.prototype.string">
        function <span class="apidocSignatureSpan">protobufjs.BufferWriter.prototype.</span>string
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write_string_buffer(value) {
    var len = Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this.push(writeStringBuffer, len, value);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Class" id="apidoc.module.protobufjs.Class">module protobufjs.Class</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Class.Class" id="apidoc.element.protobufjs.Class.Class">
        function <span class="apidocSignatureSpan">protobufjs.</span>Class
        <span class="apidocSignatureSpan">(type, ctor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Class(type, ctor) {
    if (!Type)
        Type = require("./type");

    if (!(type instanceof Type))
        throw TypeError("type must be a Type");

    if (ctor) {
        if (typeof ctor !== "function")
            throw TypeError("ctor must be a function");
    } else
        ctor = Class.generate(type).eof(type.name); // named constructor function (codegen is required anyway)

    // Let's pretend...
    ctor.constructor = Class;

    // new Class() -&gt; Message.prototype
    (ctor.prototype = new Message()).constructor = ctor;

    // Static methods on Message are instance methods on Class and vice versa
    util.merge(ctor, Message, true);

    // Classes and messages reference their reflected type
    ctor.$type = type;
    ctor.prototype.$type = type;

    // Messages have non-enumerable default values on their prototype
    var i = 0;
    for (; i &lt; /* initializes */ type.fieldsArray.length; ++i) {
        // objects on the prototype must be immmutable. users must assign a new object instance and
        // cannot use Array#push on empty arrays on the prototype for example, as this would modify
        // the value on the prototype for ALL messages of this type. Hence, these objects are frozen.
        ctor.prototype[type._fieldsArray[i].name] = Array.isArray(type._fieldsArray[i].resolve().defaultValue)
            ? util.emptyArray
            : util.isObject(type._fieldsArray[i].defaultValue) &amp;&amp; !type._fieldsArray[i].long
              ? util.emptyObject
              : type._fieldsArray[i].defaultValue; // if a long, it is frozen when initialized
    }

    // Messages have non-enumerable getters and setters for each virtual oneof field
    var ctorProperties = {};
    for (i = 0; i &lt; /* initializes */ type.oneofsArray.length; ++i)
        ctorProperties[type._oneofsArray[i].resolve().name] = {
            get: util.oneOfGetter(type._oneofsArray[i].oneof),
            set: util.oneOfSetter(type._oneofsArray[i].oneof)
        };
    if (i)
        Object.defineProperties(ctor.prototype, ctorProperties);

    // Register
    type.ctor = ctor;

    return ctor.prototype;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Class.create" id="apidoc.element.protobufjs.Class.create">
        function <span class="apidocSignatureSpan">protobufjs.Class.</span>create
        <span class="apidocSignatureSpan">(type, ctor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Class(type, ctor) {
    if (!Type)
        Type = require("./type");

    if (!(type instanceof Type))
        throw TypeError("type must be a Type");

    if (ctor) {
        if (typeof ctor !== "function")
            throw TypeError("ctor must be a function");
    } else
        ctor = Class.generate(type).eof(type.name); // named constructor function (codegen is required anyway)

    // Let's pretend...
    ctor.constructor = Class;

    // new Class() -&gt; Message.prototype
    (ctor.prototype = new Message()).constructor = ctor;

    // Static methods on Message are instance methods on Class and vice versa
    util.merge(ctor, Message, true);

    // Classes and messages reference their reflected type
    ctor.$type = type;
    ctor.prototype.$type = type;

    // Messages have non-enumerable default values on their prototype
    var i = 0;
    for (; i &lt; /* initializes */ type.fieldsArray.length; ++i) {
        // objects on the prototype must be immmutable. users must assign a new object instance and
        // cannot use Array#push on empty arrays on the prototype for example, as this would modify
        // the value on the prototype for ALL messages of this type. Hence, these objects are frozen.
        ctor.prototype[type._fieldsArray[i].name] = Array.isArray(type._fieldsArray[i].resolve().defaultValue)
            ? util.emptyArray
            : util.isObject(type._fieldsArray[i].defaultValue) &amp;&amp; !type._fieldsArray[i].long
              ? util.emptyObject
              : type._fieldsArray[i].defaultValue; // if a long, it is frozen when initialized
    }

    // Messages have non-enumerable getters and setters for each virtual oneof field
    var ctorProperties = {};
    for (i = 0; i &lt; /* initializes */ type.oneofsArray.length; ++i)
        ctorProperties[type._oneofsArray[i].resolve().name] = {
            get: util.oneOfGetter(type._oneofsArray[i].oneof),
            set: util.oneOfSetter(type._oneofsArray[i].oneof)
        };
    if (i)
        Object.defineProperties(ctor.prototype, ctorProperties);

    // Register
    type.ctor = ctor;

    return ctor.prototype;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* **Message.decodeDelimited**(reader: `Reader|Uint8Array`): `Message`&lt;br /&gt;
works like `Message.decode` but additionally reads the length of the message prepended as a varint.

* **Message.create**(properties: `Object`): `Message`&lt;br /&gt;
quickly creates a new runtime message from known to be valid properties without any conversion being performed. Where applicable
, it is recommended to prefer `Message.create` over `Message.fromObject`.

```js
var message = AwesomeMessage.<span class="apidocCodeKeywordSpan">create</span>({ awesomeField: "AwesomeString" });
```

* **Message.fromObject**(object: `Object`): `Message`&lt;br /&gt;
converts any plain object to a runtime message. Tries to convert whatever is specified (use `Message.verify` before if necessary
).

```js
var message = AwesomeMessage.fromObject({ awesomeField: 42 });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Class.generate" id="apidoc.element.protobufjs.Class.generate">
        function <span class="apidocSignatureSpan">protobufjs.Class.</span>generate
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generate(type) { // eslint-disable-line no-unused-vars
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen("p");
    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
    for (var i = 0, field; i &lt; type.fieldsArray.length; ++i)
        if ((field = type._fieldsArray[i]).map) gen
            ("this%s={}", util.safeProp(field.name));
        else if (field.repeated) gen
            ("this%s=[]", util.safeProp(field.name));
    return gen
    ("if(p){")
        ("for(var ks=Object.keys(p),i=0;i&lt;ks.length;++i)")
            ("this[ks[i]]=p[ks[i]];")
    ("}");
    /* eslint-enable no-unexpected-multiline */
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Enum" id="apidoc.module.protobufjs.Enum">module protobufjs.Enum</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Enum.Enum" id="apidoc.element.protobufjs.Enum.Enum">
        function <span class="apidocSignatureSpan">protobufjs.</span>Enum
        <span class="apidocSignatureSpan">(name, values, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Enum(name, values, options) {
    ReflectionObject.call(this, name, options);

    if (values &amp;&amp; typeof values !== "object")
        throw TypeError("values must be an object");

    /**
     * Enum values by id.
     * @type {Object.&lt;number,string&gt;}
     */
    this.valuesById = {};

    /**
     * Enum values by name.
     * @type {Object.&lt;string,number&gt;}
     */
    this.values = Object.create(this.valuesById); // toJSON, marker

    /**
     * Value comment texts, if any.
     * @type {Object.&lt;string,string&gt;}
     */
    this.comments = {};

    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
    // compatible enum. This is used by pbts to write actual enum definitions that work for
    // static and reflection code alike instead of emitting generic object definitions.

    if (values)
        for (var keys = Object.keys(values), i = 0; i &lt; keys.length; ++i)
            this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Enum.fromJSON" id="apidoc.element.protobufjs.Enum.fromJSON">
        function <span class="apidocSignatureSpan">protobufjs.Enum.</span>fromJSON
        <span class="apidocSignatureSpan">(name, json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromJSON(name, json) {
    return new Enum(name, json.values, json.options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| Field              | *ReflectionObject* | rule, **type**, **id**
| MapField           | Field              | **keyType**
| OneOf              | *ReflectionObject* | **oneof** (array of field names)
| Service            | *Namespace*        | **methods**
| Method             | *ReflectionObject* | type, **requestType**, **responseType**, requestStream, responseStream

* **Bold properties** are required. *Italic types* are abstract.
* `T.<span class="apidocCodeKeywordSpan">fromJSON</span>(name, json)` creates the respective reflection object from a JSON descriptor
* `T#toJSON()` creates a JSON descriptor from the respective reflection object (its name is used as the key within the parent)

Exclusively using JSON descriptors instead of .proto files enables the use of just the light library (the parser isn't required
 in this case).

A JSON descriptor can either be loaded the usual way:

```js
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Enum.prototype" id="apidoc.module.protobufjs.Enum.prototype">module protobufjs.Enum.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Enum.prototype.add" id="apidoc.element.protobufjs.Enum.prototype.add">
        function <span class="apidocSignatureSpan">protobufjs.Enum.prototype.</span>add
        <span class="apidocSignatureSpan">(name, id, comment)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (name, id, comment) {
    // utilized by the parser but not by .fromJSON

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (!util.isInteger(id))
        throw TypeError("id must be an integer");

    if (this.values[name] !== undefined)
        throw Error("duplicate name");

    if (this.valuesById[id] !== undefined) {
        if (!(this.options &amp;&amp; this.options.allow_alias))
            throw Error("duplicate id");
        this.values[name] = id;
    } else
        this.valuesById[this.values[name] = id] = name;

    this.comments[name] = comment || null;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
...
var Root  = protobuf.Root,
    Type  = protobuf.Type,
    Field = protobuf.Field;

var AwesomeMessage = new Type("AwesomeMessage").<span class="apidocCodeKeywordSpan">add</span>(new Field("awesomeField
", 1, "string"));

var root = new Root().define("awesomepackage").add(AwesomeMessage);

// Continue at "Create a new message" above
...
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Enum.prototype.constructor" id="apidoc.element.protobufjs.Enum.prototype.constructor">
        function <span class="apidocSignatureSpan">protobufjs.Enum.prototype.</span>constructor
        <span class="apidocSignatureSpan">(name, values, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Enum(name, values, options) {
    ReflectionObject.call(this, name, options);

    if (values &amp;&amp; typeof values !== "object")
        throw TypeError("values must be an object");

    /**
     * Enum values by id.
     * @type {Object.&lt;number,string&gt;}
     */
    this.valuesById = {};

    /**
     * Enum values by name.
     * @type {Object.&lt;string,number&gt;}
     */
    this.values = Object.create(this.valuesById); // toJSON, marker

    /**
     * Value comment texts, if any.
     * @type {Object.&lt;string,string&gt;}
     */
    this.comments = {};

    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
    // compatible enum. This is used by pbts to write actual enum definitions that work for
    // static and reflection code alike instead of emitting generic object definitions.

    if (values)
        for (var keys = Object.keys(values), i = 0; i &lt; keys.length; ++i)
            this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Enum.prototype.remove" id="apidoc.element.protobufjs.Enum.prototype.remove">
        function <span class="apidocSignatureSpan">protobufjs.Enum.prototype.</span>remove
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (name) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    var val = this.values[name];
    if (val === undefined)
        throw Error("name does not exist");

    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Enum.prototype.toJSON" id="apidoc.element.protobufjs.Enum.prototype.toJSON">
        function <span class="apidocSignatureSpan">protobufjs.Enum.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toJSON() {
    return {
        options : this.options,
        values  : this.values
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Field" id="apidoc.module.protobufjs.Field">module protobufjs.Field</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Field.Field" id="apidoc.element.protobufjs.Field.Field">
        function <span class="apidocSignatureSpan">protobufjs.</span>Field
        <span class="apidocSignatureSpan">(name, id, type, rule, extend, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Field(name, id, type, rule, extend, options) {

    if (util.isObject(rule)) {
        options = rule;
        rule = extend = undefined;
    } else if (util.isObject(extend)) {
        options = extend;
        extend = undefined;
    }

    ReflectionObject.call(this, name, options);

    if (!util.isInteger(id) || id &lt; 0)
        throw TypeError("id must be a non-negative integer");

    if (!util.isString(type))
        throw TypeError("type must be a string");

    if (rule !== undefined &amp;&amp; !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");

    if (extend !== undefined &amp;&amp; !util.isString(extend))
        throw TypeError("extend must be a string");

    /**
     * Field rule, if any.
     * @type {string|undefined}
     */
    this.rule = rule &amp;&amp; rule !== "optional" ? rule : undefined; // toJSON

    /**
     * Field type.
     * @type {string}
     */
    this.type = type; // toJSON

    /**
     * Unique field id.
     * @type {number}
     */
    this.id = id; // toJSON, marker

    /**
     * Extended type if different from parent.
     * @type {string|undefined}
     */
    this.extend = extend || undefined; // toJSON

    /**
     * Whether this field is required.
     * @type {boolean}
     */
    this.required = rule === "required";

    /**
     * Whether this field is optional.
     * @type {boolean}
     */
    this.optional = !this.required;

    /**
     * Whether this field is repeated.
     * @type {boolean}
     */
    this.repeated = rule === "repeated";

    /**
     * Whether this field is a map or not.
     * @type {boolean}
     */
    this.map = false;

    /**
     * Message this field belongs to.
     * @type {?Type}
     */
    this.message = null;

    /**
     * OneOf this field belongs to, if any,
     * @type {?OneOf}
     */
    this.partOf = null;

    /**
     * The field type's default value.
     * @type {*}
     */
    this.typeDefault = null;

    /**
     * The field's default value on prototypes.
     * @type {*}
     */
    this.defaultValue = null;

    /**
     * Whether this field's value should be treated as a long.
     * @type {boolean}
     */
    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

    /**
     * Whether this field's value is a buffer.
     * @type {boolean}
     */
    this.bytes = type === "bytes";

    /**
     * Resolved type if not a basic type.
     * @type {?(Type|Enum)}
     */
    this.resolvedType = null;

    /**
     * Sister-field within the extended type if a declaring extension field.
     * @type {?Field}
     */
    this.extensionField = null;

    /**
     * Sister-field within the declaring namespace if an extended field.
     * @type {?Field}
     */
    this.declaringField = null;

    /**
     * Internally remembers whether this field is packed.
     * @type {?boolean}
     * @private
     */
    this._packed = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Field.fromJSON" id="apidoc.element.protobufjs.Field.fromJSON">
        function <span class="apidocSignatureSpan">protobufjs.Field.</span>fromJSON
        <span class="apidocSignatureSpan">(name, json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromJSON(name, json) {
    return new Field(name, json.id, json.type, json.rule, json.extend, json.options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| Field              | *ReflectionObject* | rule, **type**, **id**
| MapField           | Field              | **keyType**
| OneOf              | *ReflectionObject* | **oneof** (array of field names)
| Service            | *Namespace*        | **methods**
| Method             | *ReflectionObject* | type, **requestType**, **responseType**, requestStream, responseStream

* **Bold properties** are required. *Italic types* are abstract.
* `T.<span class="apidocCodeKeywordSpan">fromJSON</span>(name, json)` creates the respective reflection object from a JSON descriptor
* `T#toJSON()` creates a JSON descriptor from the respective reflection object (its name is used as the key within the parent)

Exclusively using JSON descriptors instead of .proto files enables the use of just the light library (the parser isn't required
 in this case).

A JSON descriptor can either be loaded the usual way:

```js
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Field.prototype" id="apidoc.module.protobufjs.Field.prototype">module protobufjs.Field.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Field.prototype.constructor" id="apidoc.element.protobufjs.Field.prototype.constructor">
        function <span class="apidocSignatureSpan">protobufjs.Field.prototype.</span>constructor
        <span class="apidocSignatureSpan">(name, id, type, rule, extend, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Field(name, id, type, rule, extend, options) {

    if (util.isObject(rule)) {
        options = rule;
        rule = extend = undefined;
    } else if (util.isObject(extend)) {
        options = extend;
        extend = undefined;
    }

    ReflectionObject.call(this, name, options);

    if (!util.isInteger(id) || id &lt; 0)
        throw TypeError("id must be a non-negative integer");

    if (!util.isString(type))
        throw TypeError("type must be a string");

    if (rule !== undefined &amp;&amp; !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");

    if (extend !== undefined &amp;&amp; !util.isString(extend))
        throw TypeError("extend must be a string");

    /**
     * Field rule, if any.
     * @type {string|undefined}
     */
    this.rule = rule &amp;&amp; rule !== "optional" ? rule : undefined; // toJSON

    /**
     * Field type.
     * @type {string}
     */
    this.type = type; // toJSON

    /**
     * Unique field id.
     * @type {number}
     */
    this.id = id; // toJSON, marker

    /**
     * Extended type if different from parent.
     * @type {string|undefined}
     */
    this.extend = extend || undefined; // toJSON

    /**
     * Whether this field is required.
     * @type {boolean}
     */
    this.required = rule === "required";

    /**
     * Whether this field is optional.
     * @type {boolean}
     */
    this.optional = !this.required;

    /**
     * Whether this field is repeated.
     * @type {boolean}
     */
    this.repeated = rule === "repeated";

    /**
     * Whether this field is a map or not.
     * @type {boolean}
     */
    this.map = false;

    /**
     * Message this field belongs to.
     * @type {?Type}
     */
    this.message = null;

    /**
     * OneOf this field belongs to, if any,
     * @type {?OneOf}
     */
    this.partOf = null;

    /**
     * The field type's default value.
     * @type {*}
     */
    this.typeDefault = null;

    /**
     * The field's default value on prototypes.
     * @type {*}
     */
    this.defaultValue = null;

    /**
     * Whether this field's value should be treated as a long.
     * @type {boolean}
     */
    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

    /**
     * Whether this field's value is a buffer.
     * @type {boolean}
     */
    this.bytes = type === "bytes";

    /**
     * Resolved type if not a basic type.
     * @type {?(Type|Enum)}
     */
    this.resolvedType = null;

    /**
     * Sister-field within the extended type if a declaring extension field.
     * @type {?Field}
     */
    this.extensionField = null;

    /**
     * Sister-field within the declaring namespace if an extended field.
     * @type {?Field}
     */
    this.declaringField = null;

    /**
     * Internally remembers whether this field is packed.
     * @type {?boolean}
     * @private
     */
    this._packed = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Field.prototype.resolve" id="apidoc.element.protobufjs.Field.prototype.resolve">
        function <span class="apidocSignatureSpan">protobufjs.Field.prototype.</span>resolve
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolve() {

    if (this.resolved)
        return this;

    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it

        /* istanbul ignore if */
        if (!Type)
            Type = require("./type");

        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
            this.typeDefault = null;
        else // instanceof Enum
            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
    }

    // use explicitly set default value if present
    if (this.options &amp;&amp; this.options["default"] !== undefined) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum &amp;&amp; typeof this.typeDefault === "string")
            this.typeDefault = this.resolvedType.values[this.typeDefault];
    }

    // remove unnecessary packed option (parser adds this) if not referencing an enum
    if (this.options &amp;&amp; this.options.packed !== undefined &amp;&amp; this.resolvedType &amp;&amp; !(this.resolvedType instanceof Enum))
        delete this.options.packed;

    // convert to internal data type if necesssary
    if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");

        /* istanbul ignore else */
        if (Object.freeze)
            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even
 requires it)

    } else if (this.bytes &amp;&amp; typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
    }

    // take special care of maps and repeated fields
    if (this.map)
        this.defaultValue = util.emptyObject;
    else if (this.repeated)
        this.defaultValue = util.emptyArray;
    else
        this.defaultValue = this.typeDefault;

    return ReflectionObject.prototype.resolve.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        protobuf.Root.fromJSON(json).resolveAll();
return;
}

var Test, data, count;

if (process.argv.indexOf("--alt") &lt; 0) {
root = protobuf.parse(fs.readFileSync(require.<span class="apidocCodeKeywordSpan">resolve</span>("../bench/bench.proto"
;)).toString("utf8")).root;
Test = root.lookup("Test");
json = JSON.stringify(root);
data = require("../bench/bench.json");
count = 10000000;
process.stdout.write("bench.proto");
} else {
root = protobuf.parse(fs.readFileSync(require.resolve("../tests/data/mapbox/vector_tile.proto")).toString("utf8&amp;#
x22;)).root;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Field.prototype.setOption" id="apidoc.element.protobufjs.Field.prototype.setOption">
        function <span class="apidocSignatureSpan">protobufjs.Field.prototype.</span>setOption
        <span class="apidocSignatureSpan">(name, value, ifNotSet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setOption(name, value, ifNotSet) {
    if (name === "packed") // clear cached before setting
        this._packed = null;
    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
parent.add(field);

// JSON defaults to packed=true if not set so we have to set packed=false explicity when
// parsing proto2 descriptors without the option, where applicable. This must be done for
// any type (not just packable types) because enums also use varint encoding and it is not
// yet known whether a type is an enum or not.
if (!isProto3 &amp;&amp; field.repeated)
    field.<span class="apidocCodeKeywordSpan">setOption</span>("packed", false, /* ifNotSet */ true);
    }

    function parseGroup(parent, rule) {
var name = next();

/* istanbul ignore if */
if (!nameRe.test(name))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Field.prototype.toJSON" id="apidoc.element.protobufjs.Field.prototype.toJSON">
        function <span class="apidocSignatureSpan">protobufjs.Field.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toJSON() {
    return {
        rule    : this.rule !== "optional" &amp;&amp; this.rule || undefined,
        type    : this.type,
        id      : this.id,
        extend  : this.extend,
        options : this.options
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.MapField" id="apidoc.module.protobufjs.MapField">module protobufjs.MapField</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.MapField.MapField" id="apidoc.element.protobufjs.MapField.MapField">
        function <span class="apidocSignatureSpan">protobufjs.</span>MapField
        <span class="apidocSignatureSpan">(name, id, keyType, type, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MapField(name, id, keyType, type, options) {
    Field.call(this, name, id, type, options);

    /* istanbul ignore if */
    if (!util.isString(keyType))
        throw TypeError("keyType must be a string");

    /**
     * Key type.
     * @type {string}
     */
    this.keyType = keyType; // toJSON, marker

    /**
     * Resolved key type if not a basic type.
     * @type {?ReflectionObject}
     */
    this.resolvedKeyType = null;

    // Overrides Field#map
    this.map = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.MapField.fromJSON" id="apidoc.element.protobufjs.MapField.fromJSON">
        function <span class="apidocSignatureSpan">protobufjs.MapField.</span>fromJSON
        <span class="apidocSignatureSpan">(name, json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromJSON(name, json) {
    return new MapField(name, json.id, json.keyType, json.type, json.options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| Field              | *ReflectionObject* | rule, **type**, **id**
| MapField           | Field              | **keyType**
| OneOf              | *ReflectionObject* | **oneof** (array of field names)
| Service            | *Namespace*        | **methods**
| Method             | *ReflectionObject* | type, **requestType**, **responseType**, requestStream, responseStream

* **Bold properties** are required. *Italic types* are abstract.
* `T.<span class="apidocCodeKeywordSpan">fromJSON</span>(name, json)` creates the respective reflection object from a JSON descriptor
* `T#toJSON()` creates a JSON descriptor from the respective reflection object (its name is used as the key within the parent)

Exclusively using JSON descriptors instead of .proto files enables the use of just the light library (the parser isn't required
 in this case).

A JSON descriptor can either be loaded the usual way:

```js
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.MapField.prototype" id="apidoc.module.protobufjs.MapField.prototype">module protobufjs.MapField.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.MapField.prototype.constructor" id="apidoc.element.protobufjs.MapField.prototype.constructor">
        function <span class="apidocSignatureSpan">protobufjs.MapField.prototype.</span>constructor
        <span class="apidocSignatureSpan">(name, id, keyType, type, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MapField(name, id, keyType, type, options) {
    Field.call(this, name, id, type, options);

    /* istanbul ignore if */
    if (!util.isString(keyType))
        throw TypeError("keyType must be a string");

    /**
     * Key type.
     * @type {string}
     */
    this.keyType = keyType; // toJSON, marker

    /**
     * Resolved key type if not a basic type.
     * @type {?ReflectionObject}
     */
    this.resolvedKeyType = null;

    // Overrides Field#map
    this.map = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.MapField.prototype.resolve" id="apidoc.element.protobufjs.MapField.prototype.resolve">
        function <span class="apidocSignatureSpan">protobufjs.MapField.prototype.</span>resolve
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolve() {
    if (this.resolved)
        return this;

    // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
    if (types.mapKey[this.keyType] === undefined)
        throw Error("invalid key type: " + this.keyType);

    return Field.prototype.resolve.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        protobuf.Root.fromJSON(json).resolveAll();
return;
}

var Test, data, count;

if (process.argv.indexOf("--alt") &lt; 0) {
root = protobuf.parse(fs.readFileSync(require.<span class="apidocCodeKeywordSpan">resolve</span>("../bench/bench.proto"
;)).toString("utf8")).root;
Test = root.lookup("Test");
json = JSON.stringify(root);
data = require("../bench/bench.json");
count = 10000000;
process.stdout.write("bench.proto");
} else {
root = protobuf.parse(fs.readFileSync(require.resolve("../tests/data/mapbox/vector_tile.proto")).toString("utf8&amp;#
x22;)).root;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.MapField.prototype.toJSON" id="apidoc.element.protobufjs.MapField.prototype.toJSON">
        function <span class="apidocSignatureSpan">protobufjs.MapField.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toJSON() {
    return {
        keyType : this.keyType,
        type    : this.type,
        id      : this.id,
        extend  : this.extend,
        options : this.options
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Message" id="apidoc.module.protobufjs.Message">module protobufjs.Message</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Message.Message" id="apidoc.element.protobufjs.Message.Message">
        function <span class="apidocSignatureSpan">protobufjs.</span>Message
        <span class="apidocSignatureSpan">(properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Message(properties) {
    // not used internally
    if (properties)
        for (var keys = Object.keys(properties), i = 0; i &lt; keys.length; ++i)
            this[keys[i]] = properties[keys[i]];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Message.decode" id="apidoc.element.protobufjs.Message.decode">
        function <span class="apidocSignatureSpan">protobufjs.Message.</span>decode
        <span class="apidocSignatureSpan">(reader)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decode(reader) {
    return this.$type.decode(reader);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
works like `Message.encode` but additionally prepends the length of the message as a varint.

* **Message.decode**(reader: `Reader|Uint8Array`): `Message`&lt;br /&gt;
is an automatically generated message specific decoder. If required fields are missing, it throws a `util.ProtocolError` with an
 `instance` property set to the so far decoded message. If the wire format is invalid, it throws an `Error`. The result is a runtime
 message.

```js
try {
  var decodedMessage = AwesomeMessage.<span class="apidocCodeKeywordSpan">decode</span>(buffer);
} catch (e) {
    if (e instanceof protobuf.util.ProtocolError) {
      // e.instance holds the so far decoded message with missing required fields
    } else {
      // wire format is invalid
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Message.decodeDelimited" id="apidoc.element.protobufjs.Message.decodeDelimited">
        function <span class="apidocSignatureSpan">protobufjs.Message.</span>decodeDelimited
        <span class="apidocSignatureSpan">(reader)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decodeDelimited(reader) {
    return this.$type.decodeDelimited(reader);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Message.encode" id="apidoc.element.protobufjs.Message.encode">
        function <span class="apidocSignatureSpan">protobufjs.Message.</span>encode
        <span class="apidocSignatureSpan">(message, writer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encode(message, writer) {
    return this.$type.encode(message, writer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  throw Error(err);
```

* **Message.encode**(message: `Message|Object` [, writer: `Writer`]): `Writer`&lt;br /&gt;
is an automatically generated message specific encoder expecting a valid message or plain object. Note that this method does not
 implicitly verify the message and that it's up to the user to make sure that the data can actually be encoded properly.

```js
var buffer = AwesomeMessage.<span class="apidocCodeKeywordSpan">encode</span>(message).finish();
```

* **Message.encodeDelimited**(message: `Message|Object` [, writer: `Writer`]): `Writer`&lt;br /&gt;
works like `Message.encode` but additionally prepends the length of the message as a varint.

* **Message.decode**(reader: `Reader|Uint8Array`): `Message`&lt;br /&gt;
is an automatically generated message specific decoder. If required fields are missing, it throws a `util.ProtocolError` with an
 `instance` property set to the so far decoded message. If the wire format is invalid, it throws an `Error`. The result is a runtime
 message.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Message.encodeDelimited" id="apidoc.element.protobufjs.Message.encodeDelimited">
        function <span class="apidocSignatureSpan">protobufjs.Message.</span>encodeDelimited
        <span class="apidocSignatureSpan">(message, writer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encodeDelimited(message, writer) {
    return this.$type.encodeDelimited(message, writer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Message.from" id="apidoc.element.protobufjs.Message.from">
        function <span class="apidocSignatureSpan">protobufjs.Message.</span>from
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromObject(object) {
    return this.$type.fromObject(object);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Message.fromObject" id="apidoc.element.protobufjs.Message.fromObject">
        function <span class="apidocSignatureSpan">protobufjs.Message.</span>fromObject
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromObject(object) {
    return this.$type.fromObject(object);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var message = AwesomeMessage.create({ awesomeField: "AwesomeString" });
```

* **Message.fromObject**(object: `Object`): `Message`&lt;br /&gt;
converts any plain object to a runtime message. Tries to convert whatever is specified (use `Message.verify` before if necessary
).

```js
var message = AwesomeMessage.<span class="apidocCodeKeywordSpan">fromObject</span>({ awesomeField: 42 });
// converts awesomeField to a string
```

* **Message.toObject**(message: `Message` [, options: `ConversionOptions`]): `Object`&lt;br /&gt;
converts a runtime message to a plain object.

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Message.toObject" id="apidoc.element.protobufjs.Message.toObject">
        function <span class="apidocSignatureSpan">protobufjs.Message.</span>toObject
        <span class="apidocSignatureSpan">(message, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toObject(message, options) {
    return this.$type.toObject(message, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// converts awesomeField to a string
```

* **Message.toObject**(message: `Message` [, options: `ConversionOptions`]): `Object`&lt;br /&gt;
converts a runtime message to a plain object.

```js
var object = AwesomeMessage.<span class="apidocCodeKeywordSpan">toObject</span>(message, {
  enums: String,  // enums as string names
  longs: String,  // longs as strings (requires long.js)
  bytes: String,  // bytes as base64 encoded strings
  defaults: true, // includes default values
  arrays: true,   // populates empty arrays (repeated fields) even if defaults=false
  objects: true,  // populates empty objects (map fields) even if defaults=false
  oneofs: true    // includes virtual oneof fields set to the present field's name
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Message.verify" id="apidoc.element.protobufjs.Message.verify">
        function <span class="apidocSignatureSpan">protobufjs.Message.</span>verify
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function verify(message) {
    return this.$type.verify(message);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Note that **Message** below refers to any message type. See the next section for the definition of a [valid message](#valid-message
).

* **Message.verify**(message: `Object`): `null|string`&lt;br /&gt;
explicitly performs verification prior to encoding a plain object. Instead of throwing, it returns the error message as a string
, if any.

```js
var payload = "invalid (not an object)";
var err = AwesomeMessage.<span class="apidocCodeKeywordSpan">verify</span>(payload);
if (err)
  throw Error(err);
```

* **Message.encode**(message: `Message|Object` [, writer: `Writer`]): `Writer`&lt;br /&gt;
is an automatically generated message specific encoder expecting a valid message or plain object. Note that this method does not
 implicitly verify the message and that it's up to the user to make sure that the data can actually be encoded properly.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Message.prototype" id="apidoc.module.protobufjs.Message.prototype">module protobufjs.Message.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Message.prototype.toJSON" id="apidoc.element.protobufjs.Message.prototype.toJSON">
        function <span class="apidocSignatureSpan">protobufjs.Message.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toJSON() {
    return this.$type.toObject(this, util.toJSONOptions);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Message.prototype.toObject" id="apidoc.element.protobufjs.Message.prototype.toObject">
        function <span class="apidocSignatureSpan">protobufjs.Message.prototype.</span>toObject
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toObject(options) {
    return this.$type.toObject(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// converts awesomeField to a string
```

* **Message.toObject**(message: `Message` [, options: `ConversionOptions`]): `Object`&lt;br /&gt;
converts a runtime message to a plain object.

```js
var object = AwesomeMessage.<span class="apidocCodeKeywordSpan">toObject</span>(message, {
  enums: String,  // enums as string names
  longs: String,  // longs as strings (requires long.js)
  bytes: String,  // bytes as base64 encoded strings
  defaults: true, // includes default values
  arrays: true,   // populates empty arrays (repeated fields) even if defaults=false
  objects: true,  // populates empty objects (map fields) even if defaults=false
  oneofs: true    // includes virtual oneof fields set to the present field's name
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Method" id="apidoc.module.protobufjs.Method">module protobufjs.Method</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Method.Method" id="apidoc.element.protobufjs.Method.Method">
        function <span class="apidocSignatureSpan">protobufjs.</span>Method
        <span class="apidocSignatureSpan">(name, type, requestType, responseType, requestStream, responseStream, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Method(name, type, requestType, responseType, requestStream, responseStream, options) {

    /* istanbul ignore next */
    if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = undefined;
    } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = undefined;
    }

    /* istanbul ignore if */
    if (!(type === undefined || util.isString(type)))
        throw TypeError("type must be a string");

    /* istanbul ignore if */
    if (!util.isString(requestType))
        throw TypeError("requestType must be a string");

    /* istanbul ignore if */
    if (!util.isString(responseType))
        throw TypeError("responseType must be a string");

    ReflectionObject.call(this, name, options);

    /**
     * Method type.
     * @type {string}
     */
    this.type = type || "rpc"; // toJSON

    /**
     * Request type.
     * @type {string}
     */
    this.requestType = requestType; // toJSON, marker

    /**
     * Whether requests are streamed or not.
     * @type {boolean|undefined}
     */
    this.requestStream = requestStream ? true : undefined; // toJSON

    /**
     * Response type.
     * @type {string}
     */
    this.responseType = responseType; // toJSON

    /**
     * Whether responses are streamed or not.
     * @type {boolean|undefined}
     */
    this.responseStream = responseStream ? true : undefined; // toJSON

    /**
     * Resolved request type.
     * @type {?Type}
     */
    this.resolvedRequestType = null;

    /**
     * Resolved response type.
     * @type {?Type}
     */
    this.resolvedResponseType = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Method.fromJSON" id="apidoc.element.protobufjs.Method.fromJSON">
        function <span class="apidocSignatureSpan">protobufjs.Method.</span>fromJSON
        <span class="apidocSignatureSpan">(name, json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromJSON(name, json) {
    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options
);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| Field              | *ReflectionObject* | rule, **type**, **id**
| MapField           | Field              | **keyType**
| OneOf              | *ReflectionObject* | **oneof** (array of field names)
| Service            | *Namespace*        | **methods**
| Method             | *ReflectionObject* | type, **requestType**, **responseType**, requestStream, responseStream

* **Bold properties** are required. *Italic types* are abstract.
* `T.<span class="apidocCodeKeywordSpan">fromJSON</span>(name, json)` creates the respective reflection object from a JSON descriptor
* `T#toJSON()` creates a JSON descriptor from the respective reflection object (its name is used as the key within the parent)

Exclusively using JSON descriptors instead of .proto files enables the use of just the light library (the parser isn't required
 in this case).

A JSON descriptor can either be loaded the usual way:

```js
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Method.prototype" id="apidoc.module.protobufjs.Method.prototype">module protobufjs.Method.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Method.prototype.constructor" id="apidoc.element.protobufjs.Method.prototype.constructor">
        function <span class="apidocSignatureSpan">protobufjs.Method.prototype.</span>constructor
        <span class="apidocSignatureSpan">(name, type, requestType, responseType, requestStream, responseStream, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Method(name, type, requestType, responseType, requestStream, responseStream, options) {

    /* istanbul ignore next */
    if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = undefined;
    } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = undefined;
    }

    /* istanbul ignore if */
    if (!(type === undefined || util.isString(type)))
        throw TypeError("type must be a string");

    /* istanbul ignore if */
    if (!util.isString(requestType))
        throw TypeError("requestType must be a string");

    /* istanbul ignore if */
    if (!util.isString(responseType))
        throw TypeError("responseType must be a string");

    ReflectionObject.call(this, name, options);

    /**
     * Method type.
     * @type {string}
     */
    this.type = type || "rpc"; // toJSON

    /**
     * Request type.
     * @type {string}
     */
    this.requestType = requestType; // toJSON, marker

    /**
     * Whether requests are streamed or not.
     * @type {boolean|undefined}
     */
    this.requestStream = requestStream ? true : undefined; // toJSON

    /**
     * Response type.
     * @type {string}
     */
    this.responseType = responseType; // toJSON

    /**
     * Whether responses are streamed or not.
     * @type {boolean|undefined}
     */
    this.responseStream = responseStream ? true : undefined; // toJSON

    /**
     * Resolved request type.
     * @type {?Type}
     */
    this.resolvedRequestType = null;

    /**
     * Resolved response type.
     * @type {?Type}
     */
    this.resolvedResponseType = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Method.prototype.resolve" id="apidoc.element.protobufjs.Method.prototype.resolve">
        function <span class="apidocSignatureSpan">protobufjs.Method.prototype.</span>resolve
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolve() {

    /* istanbul ignore if */
    if (this.resolved)
        return this;

    this.resolvedRequestType = this.parent.lookupType(this.requestType);
    this.resolvedResponseType = this.parent.lookupType(this.responseType);

    return ReflectionObject.prototype.resolve.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        protobuf.Root.fromJSON(json).resolveAll();
return;
}

var Test, data, count;

if (process.argv.indexOf("--alt") &lt; 0) {
root = protobuf.parse(fs.readFileSync(require.<span class="apidocCodeKeywordSpan">resolve</span>("../bench/bench.proto"
;)).toString("utf8")).root;
Test = root.lookup("Test");
json = JSON.stringify(root);
data = require("../bench/bench.json");
count = 10000000;
process.stdout.write("bench.proto");
} else {
root = protobuf.parse(fs.readFileSync(require.resolve("../tests/data/mapbox/vector_tile.proto")).toString("utf8&amp;#
x22;)).root;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Method.prototype.toJSON" id="apidoc.element.protobufjs.Method.prototype.toJSON">
        function <span class="apidocSignatureSpan">protobufjs.Method.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toJSON() {
    return {
        type           : this.type !== "rpc" &amp;&amp; /* istanbul ignore next */ this.type || undefined,
        requestType    : this.requestType,
        requestStream  : this.requestStream,
        responseType   : this.responseType,
        responseStream : this.responseStream,
        options        : this.options
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Namespace" id="apidoc.module.protobufjs.Namespace">module protobufjs.Namespace</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Namespace.Namespace" id="apidoc.element.protobufjs.Namespace.Namespace">
        function <span class="apidocSignatureSpan">protobufjs.</span>Namespace
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Namespace(name, options) {
    ReflectionObject.call(this, name, options);

    /**
     * Nested objects by name.
     * @type {Object.&lt;string,ReflectionObject&gt;|undefined}
     */
    this.nested = undefined; // toJSON

    /**
     * Cached nested objects as an array.
     * @type {?ReflectionObject[]}
     * @private
     */
    this._nestedArray = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Namespace._configure" id="apidoc.element.protobufjs.Namespace._configure">
        function <span class="apidocSignatureSpan">protobufjs.Namespace.</span>_configure
        <span class="apidocSignatureSpan">(Type_, Service_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_configure = function (Type_, Service_) {
    Type    = Type_;
    Service = Service_;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Namespace.arrayToJSON" id="apidoc.element.protobufjs.Namespace.arrayToJSON">
        function <span class="apidocSignatureSpan">protobufjs.Namespace.</span>arrayToJSON
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function arrayToJSON(array) {
    if (!(array &amp;&amp; array.length))
        return undefined;
    var obj = {};
    for (var i = 0; i &lt; array.length; ++i)
        obj[array[i].name] = array[i].toJSON();
    return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Namespace.fromJSON" id="apidoc.element.protobufjs.Namespace.fromJSON">
        function <span class="apidocSignatureSpan">protobufjs.Namespace.</span>fromJSON
        <span class="apidocSignatureSpan">(name, json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromJSON(name, json) {
    return new Namespace(name, json.options).addJSON(json.nested);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| Field              | *ReflectionObject* | rule, **type**, **id**
| MapField           | Field              | **keyType**
| OneOf              | *ReflectionObject* | **oneof** (array of field names)
| Service            | *Namespace*        | **methods**
| Method             | *ReflectionObject* | type, **requestType**, **responseType**, requestStream, responseStream

* **Bold properties** are required. *Italic types* are abstract.
* `T.<span class="apidocCodeKeywordSpan">fromJSON</span>(name, json)` creates the respective reflection object from a JSON descriptor
* `T#toJSON()` creates a JSON descriptor from the respective reflection object (its name is used as the key within the parent)

Exclusively using JSON descriptors instead of .proto files enables the use of just the light library (the parser isn't required
 in this case).

A JSON descriptor can either be loaded the usual way:

```js
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Namespace.prototype" id="apidoc.module.protobufjs.Namespace.prototype">module protobufjs.Namespace.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Namespace.prototype.add" id="apidoc.element.protobufjs.Namespace.prototype.add">
        function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>add
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(object) {

    if (!(object instanceof Field &amp;&amp; object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof
 Service || object instanceof Namespace))
        throw TypeError("object must be a valid nested object");

    if (!this.nested)
        this.nested = {};
    else {
        var prev = this.get(object.name);
        if (prev) {
            if (prev instanceof Namespace &amp;&amp; object instanceof Namespace &amp;&amp; !(prev instanceof Type || prev instanceof Service)) {
                // replace plain namespace but keep existing nested elements and options
                var nested = prev.nestedArray;
                for (var i = 0; i &lt; nested.length; ++i)
                    object.add(nested[i]);
                this.remove(prev);
                if (!this.nested)
                    this.nested = {};
                object.setOptions(prev.options, true);

            } else
                throw Error("duplicate name '" + object.name + "' in " + this);
        }
    }
    this.nested[object.name] = object;
    object.onAdd(this);
    return clearCache(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
...
var Root  = protobuf.Root,
    Type  = protobuf.Type,
    Field = protobuf.Field;

var AwesomeMessage = new Type("AwesomeMessage").<span class="apidocCodeKeywordSpan">add</span>(new Field("awesomeField
", 1, "string"));

var root = new Root().define("awesomepackage").add(AwesomeMessage);

// Continue at "Create a new message" above
...
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Namespace.prototype.addJSON" id="apidoc.element.protobufjs.Namespace.prototype.addJSON">
        function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>addJSON
        <span class="apidocSignatureSpan">(nestedJson)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addJSON(nestedJson) {
    var ns = this;
    /* istanbul ignore else */
    if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i &lt; names.length; ++i) {
            nested = nestedJson[names[i]];
            ns.add( // most to least likely
                ( nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : nested.id !== undefined
                ? Field.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Namespace.prototype.constructor" id="apidoc.element.protobufjs.Namespace.prototype.constructor">
        function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>constructor
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Namespace(name, options) {
    ReflectionObject.call(this, name, options);

    /**
     * Nested objects by name.
     * @type {Object.&lt;string,ReflectionObject&gt;|undefined}
     */
    this.nested = undefined; // toJSON

    /**
     * Cached nested objects as an array.
     * @type {?ReflectionObject[]}
     * @private
     */
    this._nestedArray = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Namespace.prototype.define" id="apidoc.element.protobufjs.Namespace.prototype.define">
        function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>define
        <span class="apidocSignatureSpan">(path, json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function define(path, json) {

    if (util.isString(path))
        path = path.split(".");
    else if (!Array.isArray(path))
        throw TypeError("illegal path");
    if (path &amp;&amp; path.length &amp;&amp; path[0] === "")
        throw Error("path must be relative");

    var ptr = this;
    while (path.length &gt; 0) {
        var part = path.shift();
        if (ptr.nested &amp;&amp; ptr.nested[part]) {
            ptr = ptr.nested[part];
            if (!(ptr instanceof Namespace))
                throw Error("path conflicts with non-namespace objects");
        } else
            ptr.add(ptr = new Namespace(part));
    }
    if (json)
        ptr.addJSON(json);
    return ptr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
...
var Root  = protobuf.Root,
    Type  = protobuf.Type,
    Field = protobuf.Field;

var AwesomeMessage = new Type("AwesomeMessage").add(new Field("awesomeField", 1, "string"));

var root = new Root().<span class="apidocCodeKeywordSpan">define</span>("awesomepackage").add(AwesomeMessage);

// Continue at "Create a new message" above
...
```

Detailed information on the reflection structure is available within the [documentation](#documentation).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Namespace.prototype.get" id="apidoc.element.protobufjs.Namespace.prototype.get">
        function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>get
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function get(name) {
    return this.nested &amp;&amp; this.nested[name]
        || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Namespace.prototype.getEnum" id="apidoc.element.protobufjs.Namespace.prototype.getEnum">
        function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>getEnum
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getEnum(name) {
    if (this.nested &amp;&amp; this.nested[name] instanceof Enum)
        return this.nested[name].values;
    throw Error("no such enum");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Namespace.prototype.lookup" id="apidoc.element.protobufjs.Namespace.prototype.lookup">
        function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>lookup
        <span class="apidocSignatureSpan">(path, filterTypes, parentAlreadyChecked)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lookup(path, filterTypes, parentAlreadyChecked) {

    /* istanbul ignore if */
    if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = undefined;
    } else if (filterTypes &amp;&amp; !Array.isArray(filterTypes))
        filterTypes = [ filterTypes ];

    if (util.isString(path) &amp;&amp; path.length) {
        if (path === ".")
            return this.root;
        path = path.split(".");
    } else if (!path.length)
        return this;

    // Start at root if path is absolute
    if (path[0] === "")
        return this.root.lookup(path.slice(1), filterTypes);
    // Test if the first part matches any nested object, and if so, traverse if path contains more
    var found = this.get(path[0]);
    if (found) {
        if (path.length === 1) {
            if (!filterTypes || filterTypes.indexOf(found.constructor) &gt; -1)
                return found;
        } else if (found instanceof Namespace &amp;&amp; (found = found.lookup(path.slice(1), filterTypes, true)))
            return found;
    }
    // If there hasn't been a match, try again at the parent
    if (this.parent === null || parentAlreadyChecked)
        return null;
    return this.parent.lookup(path, filterTypes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
message HelloReply {
    string message = 1;
}
```

```js
...
var Greeter = root.<span class="apidocCodeKeywordSpan">lookup</span>("Greeter");
var greeter = Greeter.create(/* see above */ rpcImpl, /* request delimited? */ false, /* response delimited? */ false);

greeter.sayHello({ name: 'you' }, function(err, response) {
    console.log('Greeting:', response.message);
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Namespace.prototype.lookupEnum" id="apidoc.element.protobufjs.Namespace.prototype.lookupEnum">
        function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>lookupEnum
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lookupEnum(path) {
    var found = this.lookup(path, [ Enum ]);
    if (!found)
        throw Error("no such Enum '" + path + "' in " + this);
    return found;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Namespace.prototype.lookupService" id="apidoc.element.protobufjs.Namespace.prototype.lookupService">
        function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>lookupService
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lookupService(path) {
    var found = this.lookup(path, [ Service ]);
    if (!found)
        throw Error("no such Service '" + path + "' in " + this);
    return found;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Namespace.prototype.lookupType" id="apidoc.element.protobufjs.Namespace.prototype.lookupType">
        function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>lookupType
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lookupType(path) {
    var found = this.lookup(path, [ Type ]);
    if (!found)
        throw Error("no such type");
    return found;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
protobuf.load("awesome.proto", function(err, root) {
if (err)
    throw err;

// Obtain a message type
var AwesomeMessage = root.<span class="apidocCodeKeywordSpan">lookupType</span>("awesomepackage.AwesomeMessage");

// Exemplary payload
var payload = { awesomeField: "AwesomeString" };

// Verify the payload if necessary (i.e. when possibly incomplete or invalid)
var errMsg = AwesomeMessage.verify(payload);
if (errMsg)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Namespace.prototype.lookupTypeOrEnum" id="apidoc.element.protobufjs.Namespace.prototype.lookupTypeOrEnum">
        function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>lookupTypeOrEnum
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lookupTypeOrEnum(path) {
    var found = this.lookup(path, [ Type, Enum ]);
    if (!found)
        throw Error("no such Type or Enum '" + path + "' in " + this);
    return found;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Namespace.prototype.remove" id="apidoc.element.protobufjs.Namespace.prototype.remove">
        function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>remove
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function remove(object) {

    if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
    if (object.parent !== this)
        throw Error(object + " is not a member of " + this);

    delete this.nested[object.name];
    if (!Object.keys(this.nested).length)
        this.nested = undefined;

    object.onRemove(this);
    return clearCache(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Namespace.prototype.resolveAll" id="apidoc.element.protobufjs.Namespace.prototype.resolveAll">
        function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>resolveAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolveAll() {
    var nested = this.nestedArray, i = 0;
    while (i &lt; nested.length)
        if (nested[i] instanceof Namespace)
            nested[i++].resolveAll();
        else
            nested[i++].resolve();
    return this.resolve();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (process.argv[2] === "fromjson") {
json = require("../tests/data/test.json");
if (process.argv.indexOf("--resolve") &lt; 0)
    for (var k = 0; k &lt; 10000; ++k)
        protobuf.Root.fromJSON(json);
else
    for (var l = 0; l &lt; 10000; ++l)
        protobuf.Root.fromJSON(json).<span class="apidocCodeKeywordSpan">resolveAll</span>();
return;
}

var Test, data, count;

if (process.argv.indexOf("--alt") &lt; 0) {
root = protobuf.parse(fs.readFileSync(require.resolve("../bench/bench.proto")).toString("utf8")).root;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Namespace.prototype.toJSON" id="apidoc.element.protobufjs.Namespace.prototype.toJSON">
        function <span class="apidocSignatureSpan">protobufjs.Namespace.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toJSON() {
    return {
        options : this.options,
        nested  : arrayToJSON(this.nestedArray)
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.OneOf" id="apidoc.module.protobufjs.OneOf">module protobufjs.OneOf</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.OneOf.OneOf" id="apidoc.element.protobufjs.OneOf.OneOf">
        function <span class="apidocSignatureSpan">protobufjs.</span>OneOf
        <span class="apidocSignatureSpan">(name, fieldNames, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OneOf(name, fieldNames, options) {
    if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = undefined;
    }
    ReflectionObject.call(this, name, options);

    /* istanbul ignore if */
    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");

    /**
     * Field names that belong to this oneof.
     * @type {string[]}
     */
    this.oneof = fieldNames || []; // toJSON, marker

    /**
     * Fields that belong to this oneof as an array for iteration.
     * @type {Field[]}
     * @readonly
     */
    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.OneOf.fromJSON" id="apidoc.element.protobufjs.OneOf.fromJSON">
        function <span class="apidocSignatureSpan">protobufjs.OneOf.</span>fromJSON
        <span class="apidocSignatureSpan">(name, json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromJSON(name, json) {
    return new OneOf(name, json.oneof, json.options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| Field              | *ReflectionObject* | rule, **type**, **id**
| MapField           | Field              | **keyType**
| OneOf              | *ReflectionObject* | **oneof** (array of field names)
| Service            | *Namespace*        | **methods**
| Method             | *ReflectionObject* | type, **requestType**, **responseType**, requestStream, responseStream

* **Bold properties** are required. *Italic types* are abstract.
* `T.<span class="apidocCodeKeywordSpan">fromJSON</span>(name, json)` creates the respective reflection object from a JSON descriptor
* `T#toJSON()` creates a JSON descriptor from the respective reflection object (its name is used as the key within the parent)

Exclusively using JSON descriptors instead of .proto files enables the use of just the light library (the parser isn't required
 in this case).

A JSON descriptor can either be loaded the usual way:

```js
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.OneOf.prototype" id="apidoc.module.protobufjs.OneOf.prototype">module protobufjs.OneOf.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.OneOf.prototype.add" id="apidoc.element.protobufjs.OneOf.prototype.add">
        function <span class="apidocSignatureSpan">protobufjs.OneOf.prototype.</span>add
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    if (field.parent &amp;&amp; field.parent !== this.parent)
        field.parent.remove(field);
    this.oneof.push(field.name);
    this.fieldsArray.push(field);
    field.partOf = this; // field.parent remains null
    addFieldsToParent(this);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
...
var Root  = protobuf.Root,
    Type  = protobuf.Type,
    Field = protobuf.Field;

var AwesomeMessage = new Type("AwesomeMessage").<span class="apidocCodeKeywordSpan">add</span>(new Field("awesomeField
", 1, "string"));

var root = new Root().define("awesomepackage").add(AwesomeMessage);

// Continue at "Create a new message" above
...
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.OneOf.prototype.constructor" id="apidoc.element.protobufjs.OneOf.prototype.constructor">
        function <span class="apidocSignatureSpan">protobufjs.OneOf.prototype.</span>constructor
        <span class="apidocSignatureSpan">(name, fieldNames, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OneOf(name, fieldNames, options) {
    if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = undefined;
    }
    ReflectionObject.call(this, name, options);

    /* istanbul ignore if */
    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");

    /**
     * Field names that belong to this oneof.
     * @type {string[]}
     */
    this.oneof = fieldNames || []; // toJSON, marker

    /**
     * Fields that belong to this oneof as an array for iteration.
     * @type {Field[]}
     * @readonly
     */
    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.OneOf.prototype.onAdd" id="apidoc.element.protobufjs.OneOf.prototype.onAdd">
        function <span class="apidocSignatureSpan">protobufjs.OneOf.prototype.</span>onAdd
        <span class="apidocSignatureSpan">(parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onAdd(parent) {
    ReflectionObject.prototype.onAdd.call(this, parent);
    var self = this;
    // Collect present fields
    for (var i = 0; i &lt; this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field &amp;&amp; !field.partOf) {
            field.partOf = self;
            self.fieldsArray.push(field);
        }
    }
    // Add not yet present fields
    addFieldsToParent(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.OneOf.prototype.onRemove" id="apidoc.element.protobufjs.OneOf.prototype.onRemove">
        function <span class="apidocSignatureSpan">protobufjs.OneOf.prototype.</span>onRemove
        <span class="apidocSignatureSpan">(parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onRemove(parent) {
    for (var i = 0, field; i &lt; this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
            field.parent.remove(field);
    ReflectionObject.prototype.onRemove.call(this, parent);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.OneOf.prototype.remove" id="apidoc.element.protobufjs.OneOf.prototype.remove">
        function <span class="apidocSignatureSpan">protobufjs.OneOf.prototype.</span>remove
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function remove(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    var index = this.fieldsArray.indexOf(field);

    /* istanbul ignore if */
    if (index &lt; 0)
        throw Error(field + " is not a member of " + this);

    this.fieldsArray.splice(index, 1);
    index = this.oneof.indexOf(field.name);

    /* istanbul ignore else */
    if (index &gt; -1) // theoretical
        this.oneof.splice(index, 1);

    field.partOf = null;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.OneOf.prototype.toJSON" id="apidoc.element.protobufjs.OneOf.prototype.toJSON">
        function <span class="apidocSignatureSpan">protobufjs.OneOf.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toJSON() {
    return {
        oneof   : this.oneof,
        options : this.options
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Reader" id="apidoc.module.protobufjs.Reader">module protobufjs.Reader</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Reader.Reader" id="apidoc.element.protobufjs.Reader.Reader">
        function <span class="apidocSignatureSpan">protobufjs.</span>Reader
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (process.argv.length &gt; 3 &amp;&amp; /^\d+$/.test(process.argv[3]))
count = parseInt(process.argv[3], 10);
process.stdout.write(" x " + count + "\n");

function setupBrowser() {
protobuf.Writer.create = function create_browser() { return new protobuf.Writer(); };
protobuf.Reader.create = function create_browser(buf) { return new protobuf.<span class="apidocCodeKeywordSpan">Reader</span>(buf
); };
}

switch (process.argv[2]) {
case "encode-browser":
    setupBrowser();
    // eslint-disable-line no-fallthrough
case "encode":
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Reader._configure" id="apidoc.element.protobufjs.Reader._configure">
        function <span class="apidocSignatureSpan">protobufjs.Reader.</span>_configure
        <span class="apidocSignatureSpan">(BufferReader_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_configure = function (BufferReader_) {
    BufferReader = BufferReader_;

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Reader.create" id="apidoc.element.protobufjs.Reader.create">
        function <span class="apidocSignatureSpan">protobufjs.Reader.</span>create
        <span class="apidocSignatureSpan">(buffer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create_buffer_setup(buffer) {
    return (Reader.create = function create_buffer(buffer) {
        return util.Buffer.isBuffer(buffer)
            ? new BufferReader(buffer)
            /* istanbul ignore next */
            : create_array(buffer);
    })(buffer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* **Message.decodeDelimited**(reader: `Reader|Uint8Array`): `Message`&lt;br /&gt;
works like `Message.decode` but additionally reads the length of the message prepended as a varint.

* **Message.create**(properties: `Object`): `Message`&lt;br /&gt;
quickly creates a new runtime message from known to be valid properties without any conversion being performed. Where applicable
, it is recommended to prefer `Message.create` over `Message.fromObject`.

```js
var message = AwesomeMessage.<span class="apidocCodeKeywordSpan">create</span>({ awesomeField: "AwesomeString" });
```

* **Message.fromObject**(object: `Object`): `Message`&lt;br /&gt;
converts any plain object to a runtime message. Tries to convert whatever is specified (use `Message.verify` before if necessary
).

```js
var message = AwesomeMessage.fromObject({ awesomeField: 42 });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Reader.prototype" id="apidoc.module.protobufjs.Reader.prototype">module protobufjs.Reader.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Reader.prototype._slice" id="apidoc.element.protobufjs.Reader.prototype._slice">
        function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>_slice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subarray() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Reader.prototype.bool" id="apidoc.element.protobufjs.Reader.prototype.bool">
        function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>bool
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read_bool() {
    return this.uint32() !== 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Reader.prototype.bytes" id="apidoc.element.protobufjs.Reader.prototype.bytes">
        function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>bytes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end &gt; this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Reader.prototype.double" id="apidoc.element.protobufjs.Reader.prototype.double">
        function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>double
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 &gt; this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Reader.prototype.fixed32" id="apidoc.element.protobufjs.Reader.prototype.fixed32">
        function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>fixed32
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 &gt; this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Reader.prototype.fixed64" id="apidoc.element.protobufjs.Reader.prototype.fixed64">
        function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>fixed64
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read_fixed64() {
    return readFixed64.call(this)[fn](true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Reader.prototype.float" id="apidoc.element.protobufjs.Reader.prototype.float">
        function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>float
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 &gt; this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Reader.prototype.int32" id="apidoc.element.protobufjs.Reader.prototype.int32">
        function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>int32
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read_int32() {
    return this.uint32() | 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Reader.prototype.int64" id="apidoc.element.protobufjs.Reader.prototype.int64">
        function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>int64
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read_int64() {
    return readLongVarint.call(this)[fn](false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Reader.prototype.sfixed32" id="apidoc.element.protobufjs.Reader.prototype.sfixed32">
        function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>sfixed32
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 &gt; this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Reader.prototype.sfixed64" id="apidoc.element.protobufjs.Reader.prototype.sfixed64">
        function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>sfixed64
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read_sfixed64() {
    return readFixed64.call(this)[fn](false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Reader.prototype.sint32" id="apidoc.element.protobufjs.Reader.prototype.sint32">
        function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>sint32
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read_sint32() {
    var value = this.uint32();
    return value &gt;&gt;&gt; 1 ^ -(value &amp; 1) | 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Reader.prototype.sint64" id="apidoc.element.protobufjs.Reader.prototype.sint64">
        function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>sint64
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read_sint64() {
    return readLongVarint.call(this).zzDecode()[fn](false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Reader.prototype.skip" id="apidoc.element.protobufjs.Reader.prototype.skip">
        function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>skip
        <span class="apidocSignatureSpan">(length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length &gt; this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos &gt;= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] &amp; 128);
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var field = mtype._fieldsArray[i].resolve(),
    type  = field.resolvedType instanceof Enum ? "uint32" : field.type,
    ref   = "m" + util.safeProp(field.name); gen
    ("case %d:", field.id);

// Map fields
if (field.map) { gen
        ("r.<span class="apidocCodeKeywordSpan">skip</span>().pos++") // assumes id 1 + key wireType
        ("if(%s===util.emptyObject)", ref)
            ("%s={}", ref)
        ("k=r.%s()", field.keyType)
        ("r.pos++"); // assumes id 2 + value wireType
    if (types.long[field.keyType] !== undefined) {
        if (types.basic[type] === undefined) gen
        ("%s[typeof k===\"object\"?util.longToHash(k):k]=types[%d].decode(r,r.uint32())", ref, i); // can'
;t be groups
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Reader.prototype.skipType" id="apidoc.element.protobufjs.Reader.prototype.skipType">
        function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>skipType
        <span class="apidocSignatureSpan">(wireType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipType = function (wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            do { // eslint-disable-line no-constant-condition
                if ((wireType = this.uint32() &amp; 7) === 4)
                    break;
                this.skipType(wireType);
            } while (true);
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    else gen
            ("%s=r.%s()", ref, type);
    gen
            ("break");
// Unknown fields
} gen
        ("default:")
            ("r.<span class="apidocCodeKeywordSpan">skipType</span>(t&amp;7)")
            ("break")

    ("}")
("}");

// Field presence
for (i = 0; i &lt; mtype._fieldsArray.length; ++i) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Reader.prototype.string" id="apidoc.element.protobufjs.Reader.prototype.string">
        function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>string
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Reader.prototype.uint32" id="apidoc.element.protobufjs.Reader.prototype.uint32">
        function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>uint32
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read_uint32() {
    value = (         this.buf[this.pos] &amp; 127       ) &gt;&gt;&gt; 0; if (this.buf[this.pos++] &lt; 128) return value;
    value = (value | (this.buf[this.pos] &amp; 127) &lt;&lt;  7) &gt;&gt;&gt; 0; if (this.buf[this.pos++] &lt; 128) return value;
    value = (value | (this.buf[this.pos] &amp; 127) &lt;&lt; 14) &gt;&gt;&gt; 0; if (this.buf[this.pos++] &lt; 128) return value;
    value = (value | (this.buf[this.pos] &amp; 127) &lt;&lt; 21) &gt;&gt;&gt; 0; if (this.buf[this.pos++] &lt; 128) return value;
    value = (value | (this.buf[this.pos] &amp;  15) &lt;&lt; 28) &gt;&gt;&gt; 0; if (this.buf[this.pos++] &lt; 128) return value;

    /* istanbul ignore if */
    if ((this.pos += 5) &gt; this.len) {
        this.pos = this.len;
        throw indexOutOfRange(this, 10);
    }
    return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function decoder(mtype) {
/* eslint-disable no-unexpected-multiline */
var gen = util.codegen("r", "l")
("if(!(r instanceof Reader))")
    ("r=Reader.create(r)")
("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).
length ? ",k" : ""))
("while(r.pos&lt;c){")
    ("var t=r.<span class="apidocCodeKeywordSpan">uint32</span>()");
if (mtype.group) gen
    ("if((t&amp;7)===4)")
        ("break");
gen
    ("switch(t&gt;&gt;&gt;3){");

var i = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Reader.prototype.uint64" id="apidoc.element.protobufjs.Reader.prototype.uint64">
        function <span class="apidocSignatureSpan">protobufjs.Reader.prototype.</span>uint64
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read_uint64() {
    return readLongVarint.call(this)[fn](true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.ReflectionObject" id="apidoc.module.protobufjs.ReflectionObject">module protobufjs.ReflectionObject</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.ReflectionObject.ReflectionObject" id="apidoc.element.protobufjs.ReflectionObject.ReflectionObject">
        function <span class="apidocSignatureSpan">protobufjs.</span>ReflectionObject
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReflectionObject(name, options) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (options &amp;&amp; !util.isObject(options))
        throw TypeError("options must be an object");

    /**
     * Options.
     * @type {Object.&lt;string,*&gt;|undefined}
     */
    this.options = options; // toJSON

    /**
     * Unique name within its namespace.
     * @type {string}
     */
    this.name = name;

    /**
     * Parent namespace.
     * @type {?Namespace}
     */
    this.parent = null;

    /**
     * Whether already resolved or not.
     * @type {boolean}
     */
    this.resolved = false;

    /**
     * Comment text, if any.
     * @type {?string}
     */
    this.comment = null;

    /**
     * Defining file name.
     * @type {?string}
     */
    this.filename = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.ReflectionObject._configure" id="apidoc.element.protobufjs.ReflectionObject._configure">
        function <span class="apidocSignatureSpan">protobufjs.ReflectionObject.</span>_configure
        <span class="apidocSignatureSpan">(Root_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_configure = function (Root_) {
    Root = Root_;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.ReflectionObject.prototype" id="apidoc.module.protobufjs.ReflectionObject.prototype">module protobufjs.ReflectionObject.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.ReflectionObject.prototype.getOption" id="apidoc.element.protobufjs.ReflectionObject.prototype.getOption">
        function <span class="apidocSignatureSpan">protobufjs.ReflectionObject.prototype.</span>getOption
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOption(name) {
    if (this.options)
        return this.options[name];
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.ReflectionObject.prototype.onAdd" id="apidoc.element.protobufjs.ReflectionObject.prototype.onAdd">
        function <span class="apidocSignatureSpan">protobufjs.ReflectionObject.prototype.</span>onAdd
        <span class="apidocSignatureSpan">(parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onAdd(parent) {
    if (this.parent &amp;&amp; this.parent !== parent)
        this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root = parent.root;
    if (root instanceof Root)
        root._handleAdd(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.ReflectionObject.prototype.onRemove" id="apidoc.element.protobufjs.ReflectionObject.prototype.onRemove">
        function <span class="apidocSignatureSpan">protobufjs.ReflectionObject.prototype.</span>onRemove
        <span class="apidocSignatureSpan">(parent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onRemove(parent) {
    var root = parent.root;
    if (root instanceof Root)
        root._handleRemove(this);
    this.parent = null;
    this.resolved = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.ReflectionObject.prototype.resolve" id="apidoc.element.protobufjs.ReflectionObject.prototype.resolve">
        function <span class="apidocSignatureSpan">protobufjs.ReflectionObject.prototype.</span>resolve
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolve() {
    if (this.resolved)
        return this;
    if (this.root instanceof Root)
        this.resolved = true; // only if part of a root
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        protobuf.Root.fromJSON(json).resolveAll();
return;
}

var Test, data, count;

if (process.argv.indexOf("--alt") &lt; 0) {
root = protobuf.parse(fs.readFileSync(require.<span class="apidocCodeKeywordSpan">resolve</span>("../bench/bench.proto"
;)).toString("utf8")).root;
Test = root.lookup("Test");
json = JSON.stringify(root);
data = require("../bench/bench.json");
count = 10000000;
process.stdout.write("bench.proto");
} else {
root = protobuf.parse(fs.readFileSync(require.resolve("../tests/data/mapbox/vector_tile.proto")).toString("utf8&amp;#
x22;)).root;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.ReflectionObject.prototype.setOption" id="apidoc.element.protobufjs.ReflectionObject.prototype.setOption">
        function <span class="apidocSignatureSpan">protobufjs.ReflectionObject.prototype.</span>setOption
        <span class="apidocSignatureSpan">(name, value, ifNotSet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setOption(name, value, ifNotSet) {
    if (!ifNotSet || !this.options || this.options[name] === undefined)
        (this.options || (this.options = {}))[name] = value;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
parent.add(field);

// JSON defaults to packed=true if not set so we have to set packed=false explicity when
// parsing proto2 descriptors without the option, where applicable. This must be done for
// any type (not just packable types) because enums also use varint encoding and it is not
// yet known whether a type is an enum or not.
if (!isProto3 &amp;&amp; field.repeated)
    field.<span class="apidocCodeKeywordSpan">setOption</span>("packed", false, /* ifNotSet */ true);
    }

    function parseGroup(parent, rule) {
var name = next();

/* istanbul ignore if */
if (!nameRe.test(name))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.ReflectionObject.prototype.setOptions" id="apidoc.element.protobufjs.ReflectionObject.prototype.setOptions">
        function <span class="apidocSignatureSpan">protobufjs.ReflectionObject.prototype.</span>setOptions
        <span class="apidocSignatureSpan">(options, ifNotSet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setOptions(options, ifNotSet) {
    if (options)
        for (var keys = Object.keys(options), i = 0; i &lt; keys.length; ++i)
            this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.ReflectionObject.prototype.toJSON" id="apidoc.element.protobufjs.ReflectionObject.prototype.toJSON">
        function <span class="apidocSignatureSpan">protobufjs.ReflectionObject.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toJSON() {
    throw Error(); // not implemented, shouldn't happen
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.ReflectionObject.prototype.toString" id="apidoc.element.protobufjs.ReflectionObject.prototype.toString">
        function <span class="apidocSignatureSpan">protobufjs.ReflectionObject.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toString() {
    var className = this.constructor.className,
        fullName  = this.fullName;
    if (fullName.length)
        return className + " " + fullName;
    return className;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        protobuf.Root.fromJSON(json).resolveAll();
return;
}

var Test, data, count;

if (process.argv.indexOf("--alt") &lt; 0) {
root = protobuf.parse(fs.readFileSync(require.resolve("../bench/bench.proto")).<span class="apidocCodeKeywordSpan">toString
</span>("utf8")).root;
Test = root.lookup("Test");
json = JSON.stringify(root);
data = require("../bench/bench.json");
count = 10000000;
process.stdout.write("bench.proto");
} else {
root = protobuf.parse(fs.readFileSync(require.resolve("../tests/data/mapbox/vector_tile.proto")).toString("utf8&amp;#
x22;)).root;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Root" id="apidoc.module.protobufjs.Root">module protobufjs.Root</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Root.Root" id="apidoc.element.protobufjs.Root.Root">
        function <span class="apidocSignatureSpan">protobufjs.</span>Root
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Root(options) {
    Namespace.call(this, "", options);

    /**
     * Deferred extension fields.
     * @type {Field[]}
     */
    this.deferred = [];

    /**
     * Resolved file names of loaded files.
     * @type {string[]}
     */
    this.files = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Root._configure" id="apidoc.element.protobufjs.Root._configure">
        function <span class="apidocSignatureSpan">protobufjs.Root.</span>_configure
        <span class="apidocSignatureSpan">(Type_, parse_, common_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_configure = function (Type_, parse_, common_) {
    Type = Type_;
    parse = parse_;
    common = common_;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Root.fromJSON" id="apidoc.element.protobufjs.Root.fromJSON">
        function <span class="apidocSignatureSpan">protobufjs.Root.</span>fromJSON
        <span class="apidocSignatureSpan">(json, root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromJSON(json, root) {
    if (!root)
        root = new Root();
    if (json.options)
        root.setOptions(json.options);
    return root.addJSON(json.nested);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| Field              | *ReflectionObject* | rule, **type**, **id**
| MapField           | Field              | **keyType**
| OneOf              | *ReflectionObject* | **oneof** (array of field names)
| Service            | *Namespace*        | **methods**
| Method             | *ReflectionObject* | type, **requestType**, **responseType**, requestStream, responseStream

* **Bold properties** are required. *Italic types* are abstract.
* `T.<span class="apidocCodeKeywordSpan">fromJSON</span>(name, json)` creates the respective reflection object from a JSON descriptor
* `T#toJSON()` creates a JSON descriptor from the respective reflection object (its name is used as the key within the parent)

Exclusively using JSON descriptors instead of .proto files enables the use of just the light library (the parser isn't required
 in this case).

A JSON descriptor can either be loaded the usual way:

```js
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Root.prototype" id="apidoc.module.protobufjs.Root.prototype">module protobufjs.Root.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Root.prototype._handleAdd" id="apidoc.element.protobufjs.Root.prototype._handleAdd">
        function <span class="apidocSignatureSpan">protobufjs.Root.prototype.</span>_handleAdd
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _handleAdd(object) {
    if (object instanceof Field) {

        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined &amp;&amp; /* not already handled */ !object
.extensionField)
            if (!tryHandleExtension(this, object))
                this.deferred.push(object);

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            object.parent[object.name] = object.values; // expose enum values as property of its parent

    } else /* everything else is a namespace */ {

        if (object instanceof Type) // Try to handle any deferred extensions
            for (var i = 0; i &lt; this.deferred.length;)
                if (tryHandleExtension(this, this.deferred[i]))
                    this.deferred.splice(i, 1);
                else
                    ++i;
        for (var j = 0; j &lt; /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace
            this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
            object.parent[object.name] = object; // expose namespace as property of its parent
    }

    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
    // properties of namespaces just like static code does. This allows using a .d.ts generated for
    // a static module with reflection-based solutions where the condition is met.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Root.prototype._handleRemove" id="apidoc.element.protobufjs.Root.prototype._handleRemove">
        function <span class="apidocSignatureSpan">protobufjs.Root.prototype.</span>_handleRemove
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _handleRemove(object) {
    if (object instanceof Field) {

        if (/* an extension field */ object.extend !== undefined) {
            if (/* already handled */ object.extensionField) { // remove its sister field
                object.extensionField.parent.remove(object.extensionField);
                object.extensionField = null;
            } else { // cancel the extension
                var index = this.deferred.indexOf(object);
                /* istanbul ignore else */
                if (index &gt; -1)
                    this.deferred.splice(index, 1);
            }
        }

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose enum values

    } else if (object instanceof Namespace) {

        for (var i = 0; i &lt; /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace
            this._handleRemove(object._nestedArray[i]);

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose namespaces

    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Root.prototype.constructor" id="apidoc.element.protobufjs.Root.prototype.constructor">
        function <span class="apidocSignatureSpan">protobufjs.Root.prototype.</span>constructor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Root(options) {
    Namespace.call(this, "", options);

    /**
     * Deferred extension fields.
     * @type {Field[]}
     */
    this.deferred = [];

    /**
     * Resolved file names of loaded files.
     * @type {string[]}
     */
    this.files = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Root.prototype.load" id="apidoc.element.protobufjs.Root.prototype.load">
        function <span class="apidocSignatureSpan">protobufjs.Root.prototype.</span>load
        <span class="apidocSignatureSpan">(filename, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function load(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    var self = this;
    if (!callback)
        return util.asPromise(load, self, filename, options);

    var sync = callback === SYNC; // undocumented

    // Finishes loading by calling the callback (exactly once)
    function finish(err, root) {
        /* istanbul ignore if */
        if (!callback)
            return;
        var cb = callback;
        callback = null;
        if (sync)
            throw err;
        cb(err, root);
    }

    // Processes a single file
    function process(filename, source) {
        try {
            if (util.isString(source) &amp;&amp; source.charAt(0) === "{")
                source = JSON.parse(source);
            if (!util.isString(source))
                self.setOptions(source.options).addJSON(source.nested);
            else {
                parse.filename = filename;
                var parsed = parse(source, self, options),
                    resolved,
                    i = 0;
                if (parsed.imports)
                    for (; i &lt; parsed.imports.length; ++i)
                        if (resolved = self.resolvePath(filename, parsed.imports[i]))
                            fetch(resolved);
                if (parsed.weakImports)
                    for (i = 0; i &lt; parsed.weakImports.length; ++i)
                        if (resolved = self.resolvePath(filename, parsed.weakImports[i]))
                            fetch(resolved, true);
            }
        } catch (err) {
            finish(err);
        }
        if (!sync &amp;&amp; !queued)
            finish(null, self); // only once anyway
    }

    // Fetches a single file
    function fetch(filename, weak) {

        // Strip path if this file references a bundled definition
        var idx = filename.lastIndexOf("google/protobuf/");
        if (idx &gt; -1) {
            var altname = filename.substring(idx);
            if (altname in common)
                filename = altname;
        }

        // Skip if already loaded / attempted
        if (self.files.indexOf(filename) &gt; -1)
            return;
        self.files.push(filename);

        // Shortcut bundled definitions
        if (filename in common) {
            if (sync)
                process(filename, common[filename]);
            else {
                ++queued;
                setTimeout(function() {
                    --queued;
                    process(filename, common[filename]);
                });
            }
            return;
        }

        // Otherwise fetch from disk or network
        if (sync) {
            var source;
            try {
                source = util.fs.readFileSync(filename).toString("utf8");
            } catch (err) {
                if (!weak)
                    finish(err);
                return;
            }
            process(filename, source);
        } else {
            ++queued;
            util.fetch(filename, function(err, source) {
                --queued;
                /* istanbul ignore if */
                if (!callback)
                    return; // terminated meanwhile
                if (err) {
                    /* istanbul ignore else */
                    if (!weak)
                        finish(err);
                    else if (!queued) // can't be covered reliably
                        finish(null, self);
                    return;
                }
                process(filename, source);
            });
        }
    }
    var queued = 0;

    // Assembling the root namespace doesn't require working type
    // references anymore, so we can load everything in parallel
    if (util.isString(filename))
        filename = [ filename ];
    for (var i = 0, resolved; i &lt; filename.length; ++i)
        if (resolved = self.resolvePath("", filename[i]))
            fetch(resolved);

    if (sync)
        return self; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

message AwesomeMessage {
string awesome_field = 1; // becomes awesomeField
}
```

```js
protobuf.<span class="apidocCodeKeywordSpan">load</span>("awesome.proto", function(err, root) {
if (err)
    throw err;

// Obtain a message type
var AwesomeMessage = root.lookupType("awesomepackage.AwesomeMessage");

// Exemplary payload
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Root.prototype.loadSync" id="apidoc.element.protobufjs.Root.prototype.loadSync">
        function <span class="apidocSignatureSpan">protobufjs.Root.prototype.</span>loadSync
        <span class="apidocSignatureSpan">(filename, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadSync(filename, options) {
    if (!util.isNode)
        throw Error("not supported");
    return this.load(filename, options, SYNC);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Root.prototype.resolveAll" id="apidoc.element.protobufjs.Root.prototype.resolveAll">
        function <span class="apidocSignatureSpan">protobufjs.Root.prototype.</span>resolveAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolveAll() {
    if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
            return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
    return Namespace.prototype.resolveAll.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (process.argv[2] === "fromjson") {
json = require("../tests/data/test.json");
if (process.argv.indexOf("--resolve") &lt; 0)
    for (var k = 0; k &lt; 10000; ++k)
        protobuf.Root.fromJSON(json);
else
    for (var l = 0; l &lt; 10000; ++l)
        protobuf.Root.fromJSON(json).<span class="apidocCodeKeywordSpan">resolveAll</span>();
return;
}

var Test, data, count;

if (process.argv.indexOf("--alt") &lt; 0) {
root = protobuf.parse(fs.readFileSync(require.resolve("../bench/bench.proto")).toString("utf8")).root;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Root.prototype.resolvePath" id="apidoc.element.protobufjs.Root.prototype.resolvePath">
        function <span class="apidocSignatureSpan">protobufjs.Root.prototype.</span>resolvePath
        <span class="apidocSignatureSpan">(originPath, includePath, alreadyNormalized)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolve(originPath, includePath, alreadyNormalized) {
    if (!alreadyNormalized)
        includePath = normalize(includePath);
    if (isAbsolute(includePath))
        return includePath;
    if (!alreadyNormalized)
        originPath = normalize(originPath);
    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath
;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Service" id="apidoc.module.protobufjs.Service">module protobufjs.Service</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Service.Service" id="apidoc.element.protobufjs.Service.Service">
        function <span class="apidocSignatureSpan">protobufjs.</span>Service
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Service(name, options) {
    Namespace.call(this, name, options);

    /**
     * Service methods.
     * @type {Object.&lt;string,Method&gt;}
     */
    this.methods = {}; // toJSON, marker

    /**
     * Cached methods as an array.
     * @type {?Method[]}
     * @private
     */
    this._methodsArray = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Service.fromJSON" id="apidoc.element.protobufjs.Service.fromJSON">
        function <span class="apidocSignatureSpan">protobufjs.Service.</span>fromJSON
        <span class="apidocSignatureSpan">(name, json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromJSON(name, json) {
    var service = new Service(name, json.options);
    /* istanbul ignore else */
    if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i &lt; names.length; ++i)
            service.add(Method.fromJSON(names[i], json.methods[names[i]]));
    if (json.nested)
        service.addJSON(json.nested);
    return service;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| Field              | *ReflectionObject* | rule, **type**, **id**
| MapField           | Field              | **keyType**
| OneOf              | *ReflectionObject* | **oneof** (array of field names)
| Service            | *Namespace*        | **methods**
| Method             | *ReflectionObject* | type, **requestType**, **responseType**, requestStream, responseStream

* **Bold properties** are required. *Italic types* are abstract.
* `T.<span class="apidocCodeKeywordSpan">fromJSON</span>(name, json)` creates the respective reflection object from a JSON descriptor
* `T#toJSON()` creates a JSON descriptor from the respective reflection object (its name is used as the key within the parent)

Exclusively using JSON descriptors instead of .proto files enables the use of just the light library (the parser isn't required
 in this case).

A JSON descriptor can either be loaded the usual way:

```js
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Service.prototype" id="apidoc.module.protobufjs.Service.prototype">module protobufjs.Service.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Service.prototype.add" id="apidoc.element.protobufjs.Service.prototype.add">
        function <span class="apidocSignatureSpan">protobufjs.Service.prototype.</span>add
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(object) {

    /* istanbul ignore if */
    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
...
var Root  = protobuf.Root,
    Type  = protobuf.Type,
    Field = protobuf.Field;

var AwesomeMessage = new Type("AwesomeMessage").<span class="apidocCodeKeywordSpan">add</span>(new Field("awesomeField
", 1, "string"));

var root = new Root().define("awesomepackage").add(AwesomeMessage);

// Continue at "Create a new message" above
...
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Service.prototype.constructor" id="apidoc.element.protobufjs.Service.prototype.constructor">
        function <span class="apidocSignatureSpan">protobufjs.Service.prototype.</span>constructor
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Service(name, options) {
    Namespace.call(this, name, options);

    /**
     * Service methods.
     * @type {Object.&lt;string,Method&gt;}
     */
    this.methods = {}; // toJSON, marker

    /**
     * Cached methods as an array.
     * @type {?Method[]}
     * @private
     */
    this._methodsArray = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Service.prototype.create" id="apidoc.element.protobufjs.Service.prototype.create">
        function <span class="apidocSignatureSpan">protobufjs.Service.prototype.</span>create
        <span class="apidocSignatureSpan">(rpcImpl, requestDelimited, responseDelimited)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(rpcImpl, requestDelimited, responseDelimited) {
    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
    for (var i = 0; i &lt; /* initializes */ this.methodsArray.length; ++i) {
        rpcService[util.lcFirst(this._methodsArray[i].resolve().name)] = util.codegen("r","c")("return this.rpcCall(m,q,s,r,c)").
eof(util.lcFirst(this._methodsArray[i].name), {
            m: this._methodsArray[i],
            q: this._methodsArray[i].resolvedRequestType.ctor,
            s: this._methodsArray[i].resolvedResponseType.ctor
        });
    }
    return rpcService;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* **Message.decodeDelimited**(reader: `Reader|Uint8Array`): `Message`&lt;br /&gt;
works like `Message.decode` but additionally reads the length of the message prepended as a varint.

* **Message.create**(properties: `Object`): `Message`&lt;br /&gt;
quickly creates a new runtime message from known to be valid properties without any conversion being performed. Where applicable
, it is recommended to prefer `Message.create` over `Message.fromObject`.

```js
var message = AwesomeMessage.<span class="apidocCodeKeywordSpan">create</span>({ awesomeField: "AwesomeString" });
```

* **Message.fromObject**(object: `Object`): `Message`&lt;br /&gt;
converts any plain object to a runtime message. Tries to convert whatever is specified (use `Message.verify` before if necessary
).

```js
var message = AwesomeMessage.fromObject({ awesomeField: 42 });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Service.prototype.get" id="apidoc.element.protobufjs.Service.prototype.get">
        function <span class="apidocSignatureSpan">protobufjs.Service.prototype.</span>get
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function get(name) {
    return this.methods[name]
        || Namespace.prototype.get.call(this, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Service.prototype.remove" id="apidoc.element.protobufjs.Service.prototype.remove">
        function <span class="apidocSignatureSpan">protobufjs.Service.prototype.</span>remove
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function remove(object) {
    if (object instanceof Method) {

        /* istanbul ignore if */
        if (this.methods[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Service.prototype.resolveAll" id="apidoc.element.protobufjs.Service.prototype.resolveAll">
        function <span class="apidocSignatureSpan">protobufjs.Service.prototype.</span>resolveAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolveAll() {
    var methods = this.methodsArray;
    for (var i = 0; i &lt; methods.length; ++i)
        methods[i].resolve();
    return Namespace.prototype.resolve.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (process.argv[2] === "fromjson") {
json = require("../tests/data/test.json");
if (process.argv.indexOf("--resolve") &lt; 0)
    for (var k = 0; k &lt; 10000; ++k)
        protobuf.Root.fromJSON(json);
else
    for (var l = 0; l &lt; 10000; ++l)
        protobuf.Root.fromJSON(json).<span class="apidocCodeKeywordSpan">resolveAll</span>();
return;
}

var Test, data, count;

if (process.argv.indexOf("--alt") &lt; 0) {
root = protobuf.parse(fs.readFileSync(require.resolve("../bench/bench.proto")).toString("utf8")).root;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Service.prototype.toJSON" id="apidoc.element.protobufjs.Service.prototype.toJSON">
        function <span class="apidocSignatureSpan">protobufjs.Service.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toJSON() {
    var inherited = Namespace.prototype.toJSON.call(this);
    return {
        options : inherited &amp;&amp; inherited.options || undefined,
        methods : Namespace.arrayToJSON(this.methodsArray) || /* istanbul ignore next */ {},
        nested  : inherited &amp;&amp; inherited.nested || undefined
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Type" id="apidoc.module.protobufjs.Type">module protobufjs.Type</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Type.Type" id="apidoc.element.protobufjs.Type.Type">
        function <span class="apidocSignatureSpan">protobufjs.</span>Type
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Type(name, options) {
    Namespace.call(this, name, options);

    /**
     * Message fields.
     * @type {Object.&lt;string,Field&gt;}
     */
    this.fields = {};  // toJSON, marker

    /**
     * Oneofs declared within this namespace, if any.
     * @type {Object.&lt;string,OneOf&gt;}
     */
    this.oneofs = undefined; // toJSON

    /**
     * Extension ranges, if any.
     * @type {number[][]}
     */
    this.extensions = undefined; // toJSON

    /**
     * Reserved ranges, if any.
     * @type {Array.&lt;number[]|string&gt;}
     */
    this.reserved = undefined; // toJSON

    /*?
     * Whether this type is a legacy group.
     * @type {boolean|undefined}
     */
    this.group = undefined; // toJSON

    /**
     * Cached fields by id.
     * @type {?Object.&lt;number,Field&gt;}
     * @private
     */
    this._fieldsById = null;

    /**
     * Cached fields as an array.
     * @type {?Field[]}
     * @private
     */
    this._fieldsArray = null;

    /**
     * Cached oneofs as an array.
     * @type {?OneOf[]}
     * @private
     */
    this._oneofsArray = null;

    /**
     * Cached constructor.
     * @type {*}
     * @private
     */
    this._ctor = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Type.fromJSON" id="apidoc.element.protobufjs.Type.fromJSON">
        function <span class="apidocSignatureSpan">protobufjs.Type.</span>fromJSON
        <span class="apidocSignatureSpan">(name, json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromJSON(name, json) {
    var type = new Type(name, json.options);
    type.extensions = json.extensions;
    type.reserved = json.reserved;
    var names = Object.keys(json.fields),
        i = 0;
    for (; i &lt; names.length; ++i)
        type.add(
            ( typeof json.fields[names[i]].keyType !== "undefined"
            ? MapField.fromJSON
            : Field.fromJSON )(names[i], json.fields[names[i]])
        );
    if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i &lt; names.length; ++i)
            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
    if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i &lt; names.length; ++i) {
            var nested = json.nested[names[i]];
            type.add( // most to least likely
                ( nested.id !== undefined
                ? Field.fromJSON
                : nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    if (json.extensions &amp;&amp; json.extensions.length)
        type.extensions = json.extensions;
    if (json.reserved &amp;&amp; json.reserved.length)
        type.reserved = json.reserved;
    if (json.group)
        type.group = true;
    return type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| Field              | *ReflectionObject* | rule, **type**, **id**
| MapField           | Field              | **keyType**
| OneOf              | *ReflectionObject* | **oneof** (array of field names)
| Service            | *Namespace*        | **methods**
| Method             | *ReflectionObject* | type, **requestType**, **responseType**, requestStream, responseStream

* **Bold properties** are required. *Italic types* are abstract.
* `T.<span class="apidocCodeKeywordSpan">fromJSON</span>(name, json)` creates the respective reflection object from a JSON descriptor
* `T#toJSON()` creates a JSON descriptor from the respective reflection object (its name is used as the key within the parent)

Exclusively using JSON descriptors instead of .proto files enables the use of just the light library (the parser isn't required
 in this case).

A JSON descriptor can either be loaded the usual way:

```js
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Type.prototype" id="apidoc.module.protobufjs.Type.prototype">module protobufjs.Type.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Type.prototype.add" id="apidoc.element.protobufjs.Type.prototype.add">
        function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>add
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(object) {

    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Field &amp;&amp; object.extend === undefined) {
        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
        // The root object takes care of adding distinct sister-fields to the respective extended
        // type instead.

        // avoids calling the getter if not absolutely necessary because it's called quite frequently
        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])
            throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
            throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
            throw Error("name '" + object.name + "' is reserved in " + this);

        if (object.parent)
            object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {
        if (!this.oneofs)
            this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
...
var Root  = protobuf.Root,
    Type  = protobuf.Type,
    Field = protobuf.Field;

var AwesomeMessage = new Type("AwesomeMessage").<span class="apidocCodeKeywordSpan">add</span>(new Field("awesomeField
", 1, "string"));

var root = new Root().define("awesomepackage").add(AwesomeMessage);

// Continue at "Create a new message" above
...
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Type.prototype.constructor" id="apidoc.element.protobufjs.Type.prototype.constructor">
        function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>constructor
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Type(name, options) {
    Namespace.call(this, name, options);

    /**
     * Message fields.
     * @type {Object.&lt;string,Field&gt;}
     */
    this.fields = {};  // toJSON, marker

    /**
     * Oneofs declared within this namespace, if any.
     * @type {Object.&lt;string,OneOf&gt;}
     */
    this.oneofs = undefined; // toJSON

    /**
     * Extension ranges, if any.
     * @type {number[][]}
     */
    this.extensions = undefined; // toJSON

    /**
     * Reserved ranges, if any.
     * @type {Array.&lt;number[]|string&gt;}
     */
    this.reserved = undefined; // toJSON

    /*?
     * Whether this type is a legacy group.
     * @type {boolean|undefined}
     */
    this.group = undefined; // toJSON

    /**
     * Cached fields by id.
     * @type {?Object.&lt;number,Field&gt;}
     * @private
     */
    this._fieldsById = null;

    /**
     * Cached fields as an array.
     * @type {?Field[]}
     * @private
     */
    this._fieldsArray = null;

    /**
     * Cached oneofs as an array.
     * @type {?OneOf[]}
     * @private
     */
    this._oneofsArray = null;

    /**
     * Cached constructor.
     * @type {*}
     * @private
     */
    this._ctor = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Type.prototype.create" id="apidoc.element.protobufjs.Type.prototype.create">
        function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>create
        <span class="apidocSignatureSpan">(properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(properties) {
    return new this.ctor(properties);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* **Message.decodeDelimited**(reader: `Reader|Uint8Array`): `Message`&lt;br /&gt;
works like `Message.decode` but additionally reads the length of the message prepended as a varint.

* **Message.create**(properties: `Object`): `Message`&lt;br /&gt;
quickly creates a new runtime message from known to be valid properties without any conversion being performed. Where applicable
, it is recommended to prefer `Message.create` over `Message.fromObject`.

```js
var message = AwesomeMessage.<span class="apidocCodeKeywordSpan">create</span>({ awesomeField: "AwesomeString" });
```

* **Message.fromObject**(object: `Object`): `Message`&lt;br /&gt;
converts any plain object to a runtime message. Tries to convert whatever is specified (use `Message.verify` before if necessary
).

```js
var message = AwesomeMessage.fromObject({ awesomeField: 42 });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Type.prototype.decode" id="apidoc.element.protobufjs.Type.prototype.decode">
        function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>decode
        <span class="apidocSignatureSpan">(reader, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decode_setup(reader, length) {
    return this.setup().decode(reader, length); // overrides this method
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
works like `Message.encode` but additionally prepends the length of the message as a varint.

* **Message.decode**(reader: `Reader|Uint8Array`): `Message`&lt;br /&gt;
is an automatically generated message specific decoder. If required fields are missing, it throws a `util.ProtocolError` with an
 `instance` property set to the so far decoded message. If the wire format is invalid, it throws an `Error`. The result is a runtime
 message.

```js
try {
  var decodedMessage = AwesomeMessage.<span class="apidocCodeKeywordSpan">decode</span>(buffer);
} catch (e) {
    if (e instanceof protobuf.util.ProtocolError) {
      // e.instance holds the so far decoded message with missing required fields
    } else {
      // wire format is invalid
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Type.prototype.decodeDelimited" id="apidoc.element.protobufjs.Type.prototype.decodeDelimited">
        function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>decodeDelimited
        <span class="apidocSignatureSpan">(reader)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decodeDelimited(reader) {
    if (!(reader instanceof Reader))
        reader = Reader.create(reader);
    return this.decode(reader, reader.uint32());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Type.prototype.encode" id="apidoc.element.protobufjs.Type.prototype.encode">
        function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>encode
        <span class="apidocSignatureSpan">(message, writer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encode_setup(message, writer) {
    return this.setup().encode(message, writer); // overrides this method
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  throw Error(err);
```

* **Message.encode**(message: `Message|Object` [, writer: `Writer`]): `Writer`&lt;br /&gt;
is an automatically generated message specific encoder expecting a valid message or plain object. Note that this method does not
 implicitly verify the message and that it's up to the user to make sure that the data can actually be encoded properly.

```js
var buffer = AwesomeMessage.<span class="apidocCodeKeywordSpan">encode</span>(message).finish();
```

* **Message.encodeDelimited**(message: `Message|Object` [, writer: `Writer`]): `Writer`&lt;br /&gt;
works like `Message.encode` but additionally prepends the length of the message as a varint.

* **Message.decode**(reader: `Reader|Uint8Array`): `Message`&lt;br /&gt;
is an automatically generated message specific decoder. If required fields are missing, it throws a `util.ProtocolError` with an
 `instance` property set to the so far decoded message. If the wire format is invalid, it throws an `Error`. The result is a runtime
 message.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Type.prototype.encodeDelimited" id="apidoc.element.protobufjs.Type.prototype.encodeDelimited">
        function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>encodeDelimited
        <span class="apidocSignatureSpan">(message, writer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encodeDelimited(message, writer) {
    return this.encode(message, writer &amp;&amp; writer.len ? writer.fork() : writer).ldelim();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Type.prototype.from" id="apidoc.element.protobufjs.Type.prototype.from">
        function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>from
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromObject(object) {
    return this.setup().fromObject(object);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Type.prototype.fromObject" id="apidoc.element.protobufjs.Type.prototype.fromObject">
        function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>fromObject
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromObject(object) {
    return this.setup().fromObject(object);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var message = AwesomeMessage.create({ awesomeField: "AwesomeString" });
```

* **Message.fromObject**(object: `Object`): `Message`&lt;br /&gt;
converts any plain object to a runtime message. Tries to convert whatever is specified (use `Message.verify` before if necessary
).

```js
var message = AwesomeMessage.<span class="apidocCodeKeywordSpan">fromObject</span>({ awesomeField: 42 });
// converts awesomeField to a string
```

* **Message.toObject**(message: `Message` [, options: `ConversionOptions`]): `Object`&lt;br /&gt;
converts a runtime message to a plain object.

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Type.prototype.get" id="apidoc.element.protobufjs.Type.prototype.get">
        function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>get
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function get(name) {
    return this.fields[name]
        || this.oneofs &amp;&amp; this.oneofs[name]
        || this.nested &amp;&amp; this.nested[name]
        || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Type.prototype.isReservedId" id="apidoc.element.protobufjs.Type.prototype.isReservedId">
        function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>isReservedId
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isReservedId(id) {
    if (this.reserved)
        for (var i = 0; i &lt; this.reserved.length; ++i)
            if (typeof this.reserved[i] !== "string" &amp;&amp; this.reserved[i][0] &lt;= id &amp;&amp; this.reserved[i][1] &gt;= id)
                return true;
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Type.prototype.isReservedName" id="apidoc.element.protobufjs.Type.prototype.isReservedName">
        function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>isReservedName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isReservedName(name) {
    if (this.reserved)
        for (var i = 0; i &lt; this.reserved.length; ++i)
            if (this.reserved[i] === name)
                return true;
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Type.prototype.remove" id="apidoc.element.protobufjs.Type.prototype.remove">
        function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>remove
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function remove(object) {
    if (object instanceof Field &amp;&amp; object.extend === undefined) {
        // See Type#add for the reason why extension fields are excluded here.

        /* istanbul ignore if */
        if (!this.fields || this.fields[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {

        /* istanbul ignore if */
        if (!this.oneofs || this.oneofs[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Type.prototype.resolveAll" id="apidoc.element.protobufjs.Type.prototype.resolveAll">
        function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>resolveAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolveAll() {
    var fields = this.fieldsArray, i = 0;
    while (i &lt; fields.length)
        fields[i++].resolve();
    var oneofs = this.oneofsArray; i = 0;
    while (i &lt; oneofs.length)
        oneofs[i++].resolve();
    return Namespace.prototype.resolve.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (process.argv[2] === "fromjson") {
json = require("../tests/data/test.json");
if (process.argv.indexOf("--resolve") &lt; 0)
    for (var k = 0; k &lt; 10000; ++k)
        protobuf.Root.fromJSON(json);
else
    for (var l = 0; l &lt; 10000; ++l)
        protobuf.Root.fromJSON(json).<span class="apidocCodeKeywordSpan">resolveAll</span>();
return;
}

var Test, data, count;

if (process.argv.indexOf("--alt") &lt; 0) {
root = protobuf.parse(fs.readFileSync(require.resolve("../bench/bench.proto")).toString("utf8")).root;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Type.prototype.setup" id="apidoc.element.protobufjs.Type.prototype.setup">
        function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>setup
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setup() {
    // Sets up everything at once so that the prototype chain does not have to be re-evaluated
    // multiple times (V8, soft-deopt prototype-check).
    var fullName = this.fullName,
        types    = [];
    for (var i = 0; i &lt; /* initializes */ this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);
    this.encode = encoder(this).eof(fullName + "$encode", {
        Writer : Writer,
        types  : types,
        util   : util
    });
    this.decode = decoder(this).eof(fullName + "$decode", {
        Reader : Reader,
        types  : types,
        util   : util
    });
    this.verify = verifier(this).eof(fullName + "$verify", {
        types : types,
        util  : util
    });
    this.fromObject = this.from = converter.fromObject(this).eof(fullName + "$fromObject", {
        types : types,
        util  : util
    });
    this.toObject = converter.toObject(this).eof(fullName + "$toObject", {
        types : types,
        util  : util
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Type.prototype.toJSON" id="apidoc.element.protobufjs.Type.prototype.toJSON">
        function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toJSON() {
    var inherited = Namespace.prototype.toJSON.call(this);
    return {
        options    : inherited &amp;&amp; inherited.options || undefined,
        oneofs     : Namespace.arrayToJSON(this.oneofsArray),
        fields     : Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; })) || {},
        extensions : this.extensions &amp;&amp; this.extensions.length ? this.extensions : undefined,
        reserved   : this.reserved &amp;&amp; this.reserved.length ? this.reserved : undefined,
        group      : this.group || undefined,
        nested     : inherited &amp;&amp; inherited.nested || undefined
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Type.prototype.toObject" id="apidoc.element.protobufjs.Type.prototype.toObject">
        function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>toObject
        <span class="apidocSignatureSpan">(message, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toObject(message, options) {
    return this.setup().toObject(message, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// converts awesomeField to a string
```

* **Message.toObject**(message: `Message` [, options: `ConversionOptions`]): `Object`&lt;br /&gt;
converts a runtime message to a plain object.

```js
var object = AwesomeMessage.<span class="apidocCodeKeywordSpan">toObject</span>(message, {
  enums: String,  // enums as string names
  longs: String,  // longs as strings (requires long.js)
  bytes: String,  // bytes as base64 encoded strings
  defaults: true, // includes default values
  arrays: true,   // populates empty arrays (repeated fields) even if defaults=false
  objects: true,  // populates empty objects (map fields) even if defaults=false
  oneofs: true    // includes virtual oneof fields set to the present field's name
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Type.prototype.verify" id="apidoc.element.protobufjs.Type.prototype.verify">
        function <span class="apidocSignatureSpan">protobufjs.Type.prototype.</span>verify
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function verify_setup(message) {
    return this.setup().verify(message); // overrides this method
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Note that **Message** below refers to any message type. See the next section for the definition of a [valid message](#valid-message
).

* **Message.verify**(message: `Object`): `null|string`&lt;br /&gt;
explicitly performs verification prior to encoding a plain object. Instead of throwing, it returns the error message as a string
, if any.

```js
var payload = "invalid (not an object)";
var err = AwesomeMessage.<span class="apidocCodeKeywordSpan">verify</span>(payload);
if (err)
  throw Error(err);
```

* **Message.encode**(message: `Message|Object` [, writer: `Writer`]): `Writer`&lt;br /&gt;
is an automatically generated message specific encoder expecting a valid message or plain object. Note that this method does not
 implicitly verify the message and that it's up to the user to make sure that the data can actually be encoded properly.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Writer" id="apidoc.module.protobufjs.Writer">module protobufjs.Writer</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Writer.Writer" id="apidoc.element.protobufjs.Writer.Writer">
        function <span class="apidocSignatureSpan">protobufjs.</span>Writer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {?Object}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (process.argv.length &gt; 3 &amp;&amp; /^\d+$/.test(process.argv[3]))
count = parseInt(process.argv[3], 10);
process.stdout.write(" x " + count + "\n");

function setupBrowser() {
protobuf.Writer.create = function create_browser() { return new protobuf.<span class="apidocCodeKeywordSpan">Writer</span>(); };
protobuf.Reader.create = function create_browser(buf) { return new protobuf.Reader(buf); };
}

switch (process.argv[2]) {
case "encode-browser":
    setupBrowser();
    // eslint-disable-line no-fallthrough
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer._configure" id="apidoc.element.protobufjs.Writer._configure">
        function <span class="apidocSignatureSpan">protobufjs.Writer.</span>_configure
        <span class="apidocSignatureSpan">(BufferWriter_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_configure = function (BufferWriter_) {
    BufferWriter = BufferWriter_;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.alloc" id="apidoc.element.protobufjs.Writer.alloc">
        function <span class="apidocSignatureSpan">protobufjs.Writer.</span>alloc
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pool_alloc(size) {
    if (size &lt; 1 || size &gt; MAX)
        return alloc(size);
    if (offset + size &gt; SIZE) {
        slab = alloc(SIZE);
        offset = 0;
    }
    var buf = slice.call(slab, offset, offset += size);
    if (offset &amp; 7) // align to 32 bit
        offset = (offset | 7) + 1;
    return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.create" id="apidoc.element.protobufjs.Writer.create">
        function <span class="apidocSignatureSpan">protobufjs.Writer.</span>create
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create_buffer_setup() {
    return (Writer.create = function create_buffer() {
        return new BufferWriter();
    })();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* **Message.decodeDelimited**(reader: `Reader|Uint8Array`): `Message`&lt;br /&gt;
works like `Message.decode` but additionally reads the length of the message prepended as a varint.

* **Message.create**(properties: `Object`): `Message`&lt;br /&gt;
quickly creates a new runtime message from known to be valid properties without any conversion being performed. Where applicable
, it is recommended to prefer `Message.create` over `Message.fromObject`.

```js
var message = AwesomeMessage.<span class="apidocCodeKeywordSpan">create</span>({ awesomeField: "AwesomeString" });
```

* **Message.fromObject**(object: `Object`): `Message`&lt;br /&gt;
converts any plain object to a runtime message. Tries to convert whatever is specified (use `Message.verify` before if necessary
).

```js
var message = AwesomeMessage.fromObject({ awesomeField: 42 });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.Writer.prototype" id="apidoc.module.protobufjs.Writer.prototype">module protobufjs.Writer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.Writer.prototype.bool" id="apidoc.element.protobufjs.Writer.prototype.bool">
        function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>bool
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write_bool(value) {
    return this.push(writeByte, 1, value ? 1 : 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.prototype.bytes" id="apidoc.element.protobufjs.Writer.prototype.bytes">
        function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>bytes
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write_bytes(value) {
    var len = value.length &gt;&gt;&gt; 0;
    if (!len)
        return this.push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len).push(writeBytes, len, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.prototype.double" id="apidoc.element.protobufjs.Writer.prototype.double">
        function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>double
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write_double(value) {
    return this.push(util.float.writeDoubleLE, 8, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.prototype.finish" id="apidoc.element.protobufjs.Writer.prototype.finish">
        function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>finish
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  throw Error(err);
```

* **Message.encode**(message: `Message|Object` [, writer: `Writer`]): `Writer`&lt;br /&gt;
is an automatically generated message specific encoder expecting a valid message or plain object. Note that this method does not
 implicitly verify the message and that it's up to the user to make sure that the data can actually be encoded properly.

```js
var buffer = AwesomeMessage.encode(message).<span class="apidocCodeKeywordSpan">finish</span>();
```

* **Message.encodeDelimited**(message: `Message|Object` [, writer: `Writer`]): `Writer`&lt;br /&gt;
works like `Message.encode` but additionally prepends the length of the message as a varint.

* **Message.decode**(reader: `Reader|Uint8Array`): `Message`&lt;br /&gt;
is an automatically generated message specific decoder. If required fields are missing, it throws a `util.ProtocolError` with an
 `instance` property set to the so far decoded message. If the wire format is invalid, it throws an `Error`. The result is a runtime
 message.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.prototype.fixed32" id="apidoc.element.protobufjs.Writer.prototype.fixed32">
        function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>fixed32
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write_fixed32(value) {
    return this.push(writeFixed32, 4, value &gt;&gt;&gt; 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.prototype.fixed64" id="apidoc.element.protobufjs.Writer.prototype.fixed64">
        function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>fixed64
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this.push(writeFixed32, 4, bits.lo).push(writeFixed32, 4, bits.hi);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.prototype.float" id="apidoc.element.protobufjs.Writer.prototype.float">
        function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>float
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write_float(value) {
    return this.push(util.float.writeFloatLE, 4, value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.prototype.fork" id="apidoc.element.protobufjs.Writer.prototype.fork">
        function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>fork
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {string} ref Variable reference
* @returns {Codegen} Codegen instance
* @ignore
*/
function genTypePartial(gen, field, fieldIndex, ref) {
   return field.resolvedType.group
       ? gen("types[%d].encode(%s,w.uint32(%d)).uint32(%d)", fieldIndex, ref, (field.id &lt;&lt; 3 | 3) &gt;&gt;
;&gt; 0, (field.id &lt;&lt; 3 | 4) &gt;&gt;&gt; 0)
       : gen("types[%d].encode(%s,w.uint32(%d).<span class="apidocCodeKeywordSpan">fork</span>()).ldelim()", fieldIndex
, ref, (field.id &lt;&lt; 3 | 2) &gt;&gt;&gt; 0);
}

/**
* Generates an encoder specific to the specified message type.
* @param {Type} mtype Message type
* @returns {Codegen} Codegen instance
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.prototype.int32" id="apidoc.element.protobufjs.Writer.prototype.int32">
        function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>int32
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write_int32(value) {
    return value &lt; 0
        ? this.push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.prototype.int64" id="apidoc.element.protobufjs.Writer.prototype.int64">
        function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>int64
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write_uint64(value) {
    var bits = LongBits.from(value);
    return this.push(writeVarint64, bits.length(), bits);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.prototype.ldelim" id="apidoc.element.protobufjs.Writer.prototype.ldelim">
        function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>ldelim
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {string} ref Variable reference
* @returns {Codegen} Codegen instance
* @ignore
*/
function genTypePartial(gen, field, fieldIndex, ref) {
   return field.resolvedType.group
       ? gen("types[%d].encode(%s,w.uint32(%d)).uint32(%d)", fieldIndex, ref, (field.id &lt;&lt; 3 | 3) &gt;&gt;
;&gt; 0, (field.id &lt;&lt; 3 | 4) &gt;&gt;&gt; 0)
       : gen("types[%d].encode(%s,w.uint32(%d).fork()).<span class="apidocCodeKeywordSpan">ldelim</span>()", fieldIndex
, ref, (field.id &lt;&lt; 3 | 2) &gt;&gt;&gt; 0);
}

/**
* Generates an encoder specific to the specified message type.
* @param {Type} mtype Message type
* @returns {Codegen} Codegen instance
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.prototype.push" id="apidoc.element.protobufjs.Writer.prototype.push">
        function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>push
        <span class="apidocSignatureSpan">(fn, len, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys
if (!Object.keys) {
  Object.keys = function (o) {
    if (o !== Object(o)) { throw TypeError('Object.keys called on non-object'); }
    var ret = [], p;
    for (p in o) {
      if (Object.prototype.hasOwnProperty.call(o, p)) {
        ret.<span class="apidocCodeKeywordSpan">push</span>(p);
      }
    }
    return ret;
  };
}

// ES5 15.4.3.2 Array.isArray ( arg )
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.prototype.reset" id="apidoc.element.protobufjs.Writer.prototype.reset">
        function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.prototype.sfixed32" id="apidoc.element.protobufjs.Writer.prototype.sfixed32">
        function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>sfixed32
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write_fixed32(value) {
    return this.push(writeFixed32, 4, value &gt;&gt;&gt; 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.prototype.sfixed64" id="apidoc.element.protobufjs.Writer.prototype.sfixed64">
        function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>sfixed64
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this.push(writeFixed32, 4, bits.lo).push(writeFixed32, 4, bits.hi);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.prototype.sint32" id="apidoc.element.protobufjs.Writer.prototype.sint32">
        function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>sint32
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write_sint32(value) {
    return this.uint32((value &lt;&lt; 1 ^ value &gt;&gt; 31) &gt;&gt;&gt; 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.prototype.sint64" id="apidoc.element.protobufjs.Writer.prototype.sint64">
        function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>sint64
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this.push(writeVarint64, bits.length(), bits);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.prototype.string" id="apidoc.element.protobufjs.Writer.prototype.string">
        function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>string
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len).push(utf8.write, len, value)
        : this.push(writeByte, 1, 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.prototype.uint32" id="apidoc.element.protobufjs.Writer.prototype.uint32">
        function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>uint32
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value &gt;&gt;&gt; 0)
                &lt; 128       ? 1
        : value &lt; 16384     ? 2
        : value &lt; 2097152   ? 3
        : value &lt; 268435456 ? 4
        :                     5,
    value)).len;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function decoder(mtype) {
/* eslint-disable no-unexpected-multiline */
var gen = util.codegen("r", "l")
("if(!(r instanceof Reader))")
    ("r=Reader.create(r)")
("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).
length ? ",k" : ""))
("while(r.pos&lt;c){")
    ("var t=r.<span class="apidocCodeKeywordSpan">uint32</span>()");
if (mtype.group) gen
    ("if((t&amp;7)===4)")
        ("break");
gen
    ("switch(t&gt;&gt;&gt;3){");

var i = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.Writer.prototype.uint64" id="apidoc.element.protobufjs.Writer.prototype.uint64">
        function <span class="apidocSignatureSpan">protobufjs.Writer.prototype.</span>uint64
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write_uint64(value) {
    var bits = LongBits.from(value);
    return this.push(writeVarint64, bits.length(), bits);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.converter" id="apidoc.module.protobufjs.converter">module protobufjs.converter</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.converter.fromObject" id="apidoc.element.protobufjs.converter.fromObject">
        function <span class="apidocSignatureSpan">protobufjs.converter.</span>fromObject
        <span class="apidocSignatureSpan">(mtype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray;
    var gen = util.codegen("d")
    ("if(d instanceof this.ctor)")
        ("return d");
    if (!fields.length) return gen
    ("return new this.ctor");
    gen
    ("var m=new this.ctor");
    for (var i = 0; i &lt; fields.length; ++i) {
        var field  = fields[i].resolve(),
            prop   = util.safeProp(field.name);

        // Map fields
        if (field.map) { gen
    ("if(d%s){", prop)
        ("if(typeof d%s!==\"object\")", prop)
            ("throw TypeError(%j)", field.fullName + ": object expected")
        ("m%s={}", prop)
        ("for(var ks=Object.keys(d%s),i=0;i&lt;ks.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[ks[i]]")
        ("}")
    ("}");

        // Repeated fields
        } else if (field.repeated) { gen
    ("if(d%s){", prop)
        ("if(!Array.isArray(d%s))", prop)
            ("throw TypeError(%j)", field.fullName + ": array expected")
        ("m%s=[]", prop)
        ("for(var i=0;i&lt;d%s.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[i]")
        ("}")
    ("}");

        // Non-repeated fields
        } else {
            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
    ("if(d%s!=null){", prop); // !== undefined &amp;&amp; !== null
        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);
            if (!(field.resolvedType instanceof Enum)) gen
    ("}");
        }
    } return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var message = AwesomeMessage.create({ awesomeField: "AwesomeString" });
```

* **Message.fromObject**(object: `Object`): `Message`&lt;br /&gt;
converts any plain object to a runtime message. Tries to convert whatever is specified (use `Message.verify` before if necessary
).

```js
var message = AwesomeMessage.<span class="apidocCodeKeywordSpan">fromObject</span>({ awesomeField: 42 });
// converts awesomeField to a string
```

* **Message.toObject**(message: `Message` [, options: `ConversionOptions`]): `Object`&lt;br /&gt;
converts a runtime message to a plain object.

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.converter.toObject" id="apidoc.element.protobufjs.converter.toObject">
        function <span class="apidocSignatureSpan">protobufjs.converter.</span>toObject
        <span class="apidocSignatureSpan">(mtype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    if (!fields.length)
        return util.codegen()("return {}");
    var gen = util.codegen("m", "o")
    ("if(!o)")
        ("o={}")
    ("var d={}");

    var repeatedFields = [],
        mapFields = [],
        normalFields = [],
        i = 0;
    for (; i &lt; fields.length; ++i)
        if (!fields[i].partOf)
            ( fields[i].resolve().repeated ? repeatedFields
            : fields[i].map ? mapFields
            : normalFields).push(fields[i]);

    if (repeatedFields.length) { gen
    ("if(o.arrays||o.defaults){");
        for (i = 0; i &lt; repeatedFields.length; ++i) gen
        ("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen
    ("}");
    }

    if (mapFields.length) { gen
    ("if(o.objects||o.defaults){");
        for (i = 0; i &lt; mapFields.length; ++i) gen
        ("d%s={}", util.safeProp(mapFields[i].name));
        gen
    ("}");
    }

    if (normalFields.length) { gen
    ("if(o.defaults){");
        for (i = 0; i &lt; normalFields.length; ++i) {
            var field = normalFields[i],
                prop  = util.safeProp(field.name);
            if (field.resolvedType instanceof Enum) gen
        ("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
            else if (field.long) gen
        ("if(util.Long){")
            ("var n=new util.Long(%d,%d,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)
            ("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)
        ("}else")
            ("d%s=o.longs===String?%j:%d", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
            else if (field.bytes) gen
        ("d%s=o.bytes===String?%j:%s", prop, String.fromCharCode.apply(String, field.typeDefault), "[" + Array.prototype.slice.call
(field.typeDefault).join(",") + "]");
            else gen
        ("d%s=%j", prop, field.typeDefault); // also messages (=null)
        } gen
    ("}");
    }
    var hasKs2 = false;
    for (i = 0; i &lt; fields.length; ++i) {
        var field = fields[i],
            index = mtype._fieldsArray.indexOf(field),
            prop  = util.safeProp(field.name);
        if (field.map) {
            if (!hasKs2) { hasKs2 = true; gen
    ("var ks2");
            } gen
    ("if(m%s&amp;&amp;(ks2=Object.keys(m%s)).length){", prop, prop)
        ("d%s={}", prop)
        ("for(var j=0;j&lt;ks2.length;++j){");
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[ks2[j]]")
        ("}");
        } else if (field.repeated) { gen
    ("if(m%s&amp;&amp;m%s.length){", prop, prop)
        ("d%s=[]", prop)
        ("for(var j=0;j&lt;m%s.length;++j){", prop);
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[j]")
        ("}");
        } else { gen
    ("if(m%s!=null&amp;&amp;m.hasOwnProperty(%j)){", prop, field.name); // !== undefined &amp;&amp; !== null
        genValuePartial_toObject(gen, field, /* sorted */ index, prop);
        if (field.partOf) gen
        ("if(o.oneofs)")
            ("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen
    ("}");
    }
    return gen
    ("return d");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// converts awesomeField to a string
```

* **Message.toObject**(message: `Message` [, options: `ConversionOptions`]): `Object`&lt;br /&gt;
converts a runtime message to a plain object.

```js
var object = AwesomeMessage.<span class="apidocCodeKeywordSpan">toObject</span>(message, {
  enums: String,  // enums as string names
  longs: String,  // longs as strings (requires long.js)
  bytes: String,  // bytes as base64 encoded strings
  defaults: true, // includes default values
  arrays: true,   // populates empty arrays (repeated fields) even if defaults=false
  objects: true,  // populates empty objects (map fields) even if defaults=false
  oneofs: true    // includes virtual oneof fields set to the present field's name
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.rpc" id="apidoc.module.protobufjs.rpc">module protobufjs.rpc</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.rpc.Service" id="apidoc.element.protobufjs.rpc.Service">
        function <span class="apidocSignatureSpan">protobufjs.rpc.</span>Service
        <span class="apidocSignatureSpan">(rpcImpl, requestDelimited, responseDelimited)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {?RPCImpl}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.rpc.Service" id="apidoc.module.protobufjs.rpc.Service">module protobufjs.rpc.Service</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.rpc.Service.Service" id="apidoc.element.protobufjs.rpc.Service.Service">
        function <span class="apidocSignatureSpan">protobufjs.rpc.</span>Service
        <span class="apidocSignatureSpan">(rpcImpl, requestDelimited, responseDelimited)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {?RPCImpl}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.rpc.Service.prototype" id="apidoc.module.protobufjs.rpc.Service.prototype">module protobufjs.rpc.Service.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.rpc.Service.prototype.constructor" id="apidoc.element.protobufjs.rpc.Service.prototype.constructor">
        function <span class="apidocSignatureSpan">protobufjs.rpc.Service.prototype.</span>constructor
        <span class="apidocSignatureSpan">(rpcImpl, requestDelimited, responseDelimited)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {?RPCImpl}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.rpc.Service.prototype.end" id="apidoc.element.protobufjs.rpc.Service.prototype.end">
        function <span class="apidocSignatureSpan">protobufjs.rpc.Service.prototype.</span>end
        <span class="apidocSignatureSpan">(endedByRPC)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.rpc.Service.prototype.rpcCall" id="apidoc.element.protobufjs.rpc.Service.prototype.rpcCall">
        function <span class="apidocSignatureSpan">protobufjs.rpc.Service.prototype.</span>rpcCall
        <span class="apidocSignatureSpan">(method, requestCtor, responseCtor, request, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.tokenize" id="apidoc.module.protobufjs.tokenize">module protobufjs.tokenize</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.tokenize.tokenize" id="apidoc.element.protobufjs.tokenize.tokenize">
        function <span class="apidocSignatureSpan">protobufjs.</span>tokenize
        <span class="apidocSignatureSpan">(source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tokenize(source) {
    /* eslint-disable callback-return */
    source = source.toString();

    var offset = 0,
        length = source.length,
        line = 1,
        commentType = null,
        commentText = null,
        commentLine = 0;

    var stack = [];

    var stringDelim = null;

    /* istanbul ignore next */
    /**
     * Creates an error for illegal syntax.
     * @param {string} subject Subject
     * @returns {Error} Error created
     * @inner
     */
    function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
    }

    /**
     * Reads a string till its end.
     * @returns {string} String read
     * @inner
     */
    function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
            throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape(match[1]);
    }

    /**
     * Gets the character at `pos` within the source.
     * @param {number} pos Position
     * @returns {string} Character
     * @inner
     */
    function charAt(pos) {
        return source.charAt(pos);
    }

    /**
     * Sets the current comment text.
     * @param {number} start Start offset
     * @param {number} end End offset
     * @returns {undefined}
     * @inner
     */
    function setComment(start, end) {
        commentType = source.charAt(start++);
        commentLine = line;
        var lines = source
            .substring(start, end)
            .split(setCommentSplitRe);
        for (var i = 0; i &lt; lines.length; ++i)
            lines[i] = lines[i].replace(setCommentRe, "").trim();
        commentText = lines
            .join("\n")
            .trim();
    }

    /**
     * Obtains the next token.
     * @returns {?string} Next token or `null` on eof
     * @inner
     */
    function next() {
        if (stack.length &gt; 0)
            return stack.shift();
        if (stringDelim)
            return readString();
        var repeat,
            prev,
            curr,
            start,
            isComment;
        do {
            if (offset === length)
                return null;
            repeat = false;
            while (whitespaceRe.test(curr = charAt(offset))) {
                if (curr === "\n")
                    ++line;
                if (++offset === length)
                    return null;
            }
            if (charAt(offset) === "/") {
                if (++offset === length)
                    throw illegal("comment");
                if (charAt(offset) === "/") { // Line
                    isComment = charAt(start = offset + 1) === "/";
                    while (charAt(++offset) !== "\n")
                        if (offset === length)
                            return null;
                    ++offset;
                    if (isComment)
                        setComment(start, offset - 1);
                    ++line;
                    repeat = true;
                } else if ((curr = charAt(offset)) === "*") { /* Block */
                    isComment = charAt(start = offset + 1) === "*";
                    do {
                        if (curr === "\n")
                            ++line;
                        if (++offset === length)
                            throw illegal("comment");
                        prev = curr;
                        curr = charAt(offset);
                    } while (prev !== "*" || curr !== "/");
                    ++offset;
                    if (isComment)
                        setComment(start, offset - 2);
                    repeat = true;
                } else
                    return "/";
            }
        } while (repeat);

        // offset !== length if we got here

        var end = offset;
        delimRe.lastIndex = 0; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.tokenize.unescape" id="apidoc.element.protobufjs.tokenize.unescape">
        function <span class="apidocSignatureSpan">protobufjs.tokenize.</span>unescape
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unescape(str) {
    return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
            case "\\":
            case "":
                return $1;
            default:
                return unescapeMap[$1] || "";
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.util" id="apidoc.module.protobufjs.util">module protobufjs.util</a></h1>




    <h2>
        <a href="#apidoc.element.protobufjs.util.Array" id="apidoc.element.protobufjs.util.Array">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>Array
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Uint8Array() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer" id="apidoc.element.protobufjs.util.Buffer">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>Buffer
        <span class="apidocSignatureSpan">(arg, encodingOrOffset, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      );
    }
    return Buffer.allocUnsafe(arg);
  }
  return Buffer.from(arg, encodingOrOffset, length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.EventEmitter" id="apidoc.element.protobufjs.util.EventEmitter">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>EventEmitter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.&lt;string,*&gt;}
     * @private
     */
    this._listeners = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long" id="apidoc.element.protobufjs.util.Long">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>Long
        <span class="apidocSignatureSpan">(low, high, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.LongBits" id="apidoc.element.protobufjs.util.LongBits">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>LongBits
        <span class="apidocSignatureSpan">(lo, hi)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo &gt;&gt;&gt; 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi &gt;&gt;&gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.ProtocolError" id="apidoc.element.protobufjs.util.ProtocolError">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>ProtocolError
        <span class="apidocSignatureSpan">(message, properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CustomError(message, properties) {

    if (!(this instanceof CustomError))
        return new CustomError(message, properties);

    // Error.call(this, message);
    // ^ just returns a new error instance because the ctor can be called as a function

    Object.defineProperty(this, "message", { get: function() { return message; } });

    /* istanbul ignore next */
    if (Error.captureStackTrace) // node
        Error.captureStackTrace(this, CustomError);
    else
        Object.defineProperty(this, "stack", { value: (new Error()).stack || "" });

    if (properties)
        merge(this, properties);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util._Buffer_allocUnsafe" id="apidoc.element.protobufjs.util._Buffer_allocUnsafe">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>_Buffer_allocUnsafe
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_Buffer_allocUnsafe = function (size) {
  assertSize(size);
  return allocate(size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util._Buffer_from" id="apidoc.element.protobufjs.util._Buffer_from">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>_Buffer_from
        <span class="apidocSignatureSpan">(value, encodingOrOffset, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_Buffer_from = function (value, encodingOrOffset, length) {
  if (typeof value === 'number')
    throw new TypeError('"value" argument must not be a number');

  if (isArrayBuffer(value) || isSharedArrayBuffer(value))
    return fromArrayBuffer(value, encodingOrOffset, length);

  if (typeof value === 'string')
    return fromString(value, encodingOrOffset);

  return fromObject(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util._configure" id="apidoc.element.protobufjs.util._configure">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>_configure
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_configure = function () {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible &amp; immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from &amp;&amp; Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.asPromise" id="apidoc.element.protobufjs.util.asPromise">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>asPromise
        <span class="apidocSignatureSpan">(fn, ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asPromise(fn, ctx) {
    var params = [];
    for (var i = 2; i &lt; arguments.length;)
        params.push(arguments[i++]);
    var pending = true;
    return new Promise(function asPromiseExecutor(resolve, reject) {
        params.push(function asPromiseCallback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var args = [];
                    for (var i = 1; i &lt; arguments.length;)
                        args.push(arguments[i++]);
                    resolve.apply(null, args);
                }
            }
        });
        try {
            fn.apply(ctx || this, params); // eslint-disable-line no-invalid-this
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.codegen" id="apidoc.element.protobufjs.util.codegen">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>codegen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function codegen() {
    var params = [],
        src    = [],
        indent = 1,
        inCase = false;
    for (var i = 0; i &lt; arguments.length;)
        params.push(arguments[i++]);

    /**
     * A codegen instance as returned by {@link codegen}, that also is a sprintf-like appender function.
     * @typedef Codegen
     * @type {function}
     * @param {string} format Format string
     * @param {...*} args Replacements
     * @returns {Codegen} Itself
     * @property {function(string=):string} str Stringifies the so far generated function source.
     * @property {function(string=, Object=):function} eof Ends generation and builds the function whilst applying a scope.
     */
    /**/
    function gen() {
        var args = [],
            i = 0;
        for (; i &lt; arguments.length;)
            args.push(arguments[i++]);
        var line = sprintf.apply(null, args);
        var level = indent;
        if (src.length) {
            var prev = src[src.length - 1];

            // block open or one time branch
            if (blockOpenRe.test(prev))
                level = ++indent; // keep
            else if (branchRe.test(prev))
                ++level; // once

            // casing
            if (casingRe.test(prev) &amp;&amp; !casingRe.test(line)) {
                level = ++indent;
                inCase = true;
            } else if (inCase &amp;&amp; breakRe.test(prev)) {
                level = --indent;
                inCase = false;
            }

            // block close
            if (blockCloseRe.test(line))
                level = --indent;
        }
        for (i = 0; i &lt; level; ++i)
            line = "\t" + line;
        src.push(line);
        return gen;
    }

    /**
     * Stringifies the so far generated function source.
     * @param {string} [name] Function name, defaults to generate an anonymous function
     * @returns {string} Function source using tabs for indentation
     * @inner
     */
    function str(name) {
        return "function" + (name ? " " + name.replace(/[^\w_$]/g, "_") : "") + "(" + params.join(",") + ") {\n" + src.join("\n") + "\n}";
    }

    gen.str = str;

    /**
     * Ends generation and builds the function whilst applying a scope.
     * @param {string} [name] Function name, defaults to generate an anonymous function
     * @param {Object.&lt;string,*&gt;} [scope] Function scope
     * @returns {function} The generated function, with scope applied if specified
     * @inner
     */
    function eof(name, scope) {
        if (typeof name === "object") {
            scope = name;
            name = undefined;
        }
        var source = gen.str(name);
        if (codegen.verbose)
            console.log("--- codegen ---\n" + source.replace(/^/mg, "&gt; ").replace(/\t/g, "  ")); // eslint-disable-line no-console
        var keys = Object.keys(scope || (scope = {}));
        return Function.apply(null, keys.concat("return " + source)).apply(null, keys.map(function(key) { return scope[key]; })); //
eslint-disable-line no-new-func
        //     ^ Creates a wrapper function with the scoped variable names as its parameters,
        //       calls it with the respective scoped variable values ^
        //       and returns our brand-new properly scoped function.
        //
        // This works because "Invoking the Function constructor as a function (without using the
        // new operator) has the same effect as invoking it as a constructor."
        // https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Function
    }

    gen.eof = eof;

    return gen;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Generates a decoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function decoder(mtype) {
/* eslint-disable no-unexpected-multiline */
var gen = util.<span class="apidocCodeKeywordSpan">codegen</span>("r", "l")
("if(!(r instanceof Reader))")
    ("r=Reader.create(r)")
("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).
length ? ",k" : ""))
("while(r.pos&lt;c){")
    ("var t=r.uint32()");
if (mtype.group) gen
    ("if((t&amp;7)===4)")
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.compareFieldsById" id="apidoc.element.protobufjs.util.compareFieldsById">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>compareFieldsById
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compareFieldsById(a, b) {
    return a.id - b.id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.fetch" id="apidoc.element.protobufjs.util.fetch">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>fetch
        <span class="apidocSignatureSpan">(filename, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fetch(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    } else if (!options)
        options = {};

    if (!callback)
        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
    if (!options.xhr &amp;&amp; fs &amp;&amp; fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
            return err &amp;&amp; typeof XMLHttpRequest !== "undefined"
                ? fetch.xhr(filename, options, callback)
                : err
                ? callback(err)
                : callback(null, options.binary ? contents : contents.toString("utf8"));
        });

    // use the XHR version otherwise.
    return fetch.xhr(filename, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.float" id="apidoc.element.protobufjs.util.float">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>float
        <span class="apidocSignatureSpan">(exports)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val &lt; 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val &gt; 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val &gt; 3.4028234663852886e+38) // +-Infinity
                writeUint((sign &lt;&lt; 31 | 2139095040) &gt;&gt;&gt; 0, buf, pos);
            else if (val &lt; 1.1754943508222875e-38) // denormal
                writeUint((sign &lt;&lt; 31 | Math.round(val / 1.401298464324817e-45)) &gt;&gt;&gt; 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) &amp; 8388607;
                writeUint((sign &lt;&lt; 31 | exponent + 127 &lt;&lt; 23 | mantissa) &gt;&gt;&gt; 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint &gt;&gt; 31) * 2 + 1,
                exponent = uint &gt;&gt;&gt; 23 &amp; 255,
                mantissa = uint &amp; 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6] ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.inquire" id="apidoc.element.protobufjs.util.inquire">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>inquire
        <span class="apidocSignatureSpan">(moduleName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod &amp;&amp; (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.isInteger" id="apidoc.element.protobufjs.util.isInteger">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>isInteger
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isInteger() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else {
switch (field.type) {
    case "int32":
    case "uint32":
    case "sint32":
    case "fixed32":
    case "sfixed32": gen
        ("if(!util.<span class="apidocCodeKeywordSpan">isInteger</span>(%s))", ref)
            ("return%j", invalid(field, "integer"));
        break;
    case "int64":
    case "uint64":
    case "sint64":
    case "fixed64":
    case "sfixed64": gen
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.isObject" id="apidoc.element.protobufjs.util.isObject">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>isObject
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isObject(value) {
    return value &amp;&amp; typeof value === "object";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (var i = 0; i &lt; /* initializes */ mtype.fieldsArray.length; ++i) {
var field = mtype._fieldsArray[i].resolve(),
    ref   = "m" + util.safeProp(field.name);

// map fields
if (field.map) { gen
    ("if(%s!=null){", ref) // !== undefined &amp;&amp; !== null
        ("if(!util.<span class="apidocCodeKeywordSpan">isObject</span>(%s))", ref)
            ("return%j", invalid(field, "object"))
        ("var k=Object.keys(%s)", ref)
        ("for(var i=0;i&lt;k.length;++i){");
            genVerifyKey(gen, field, "k[i]");
            genVerifyValue(gen, field, i, ref + "[k[i]]")
        ("}")
    ("}");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.isSet" id="apidoc.element.protobufjs.util.isSet">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>isSet
        <span class="apidocSignatureSpan">(obj, prop)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null &amp;&amp; obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) &gt; 0;
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.isString" id="apidoc.element.protobufjs.util.isString">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>isString
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isString(value) {
    return typeof value === "string" || value instanceof String;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            ("return%j", invalid(field, "number"));
        break;
    case "bool": gen
        ("if(typeof %s!==\"boolean\")", ref)
            ("return%j", invalid(field, "boolean"));
        break;
    case "string": gen
        ("if(!util.<span class="apidocCodeKeywordSpan">isString</span>(%s))", ref)
            ("return%j", invalid(field, "string"));
        break;
    case "bytes": gen
        ("if(!(%s&amp;&amp;typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)
            ("return%j", invalid(field, "buffer"));
        break;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.isset" id="apidoc.element.protobufjs.util.isset">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>isset
        <span class="apidocSignatureSpan">(obj, prop)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null &amp;&amp; obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) &gt; 0;
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.lazyResolve" id="apidoc.element.protobufjs.util.lazyResolve">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>lazyResolve
        <span class="apidocSignatureSpan">(root, lazyTypes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lazyResolve(root, lazyTypes) {
    for (var i = 0; i &lt; lazyTypes.length; ++i) {
        for (var keys = Object.keys(lazyTypes[i]), j = 0; j &lt; keys.length; ++j) {
            var path = lazyTypes[i][keys[j]].split("."),
                ptr  = root;
            while (path.length)
                ptr = ptr[path.shift()];
            lazyTypes[i][keys[j]] = ptr;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.lcFirst" id="apidoc.element.protobufjs.util.lcFirst">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>lcFirst
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    function parseGroup(parent, rule) {
var name = next();

/* istanbul ignore if */
if (!nameRe.test(name))
    throw illegal(name, "name");

var fieldName = util.<span class="apidocCodeKeywordSpan">lcFirst</span>(name);
if (name === fieldName)
    name = util.ucFirst(name);
skip("=");
var id = parseId(next());
var type = new Type(name);
type.group = true;
var field = new Field(fieldName, id, name, rule);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.longFromHash" id="apidoc.element.protobufjs.util.longFromHash">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>longFromHash
        <span class="apidocSignatureSpan">(hash, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.longToHash" id="apidoc.element.protobufjs.util.longToHash">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>longToHash
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ("r.skip().pos++") // assumes id 1 + key wireType
    ("if(%s===util.emptyObject)", ref)
        ("%s={}", ref)
    ("k=r.%s()", field.keyType)
    ("r.pos++"); // assumes id 2 + value wireType
if (types.long[field.keyType] !== undefined) {
    if (types.basic[type] === undefined) gen
    ("%s[typeof k===\"object\"?util.<span class="apidocCodeKeywordSpan">longToHash</span>(k):k]=types[%d].decode(
r,r.uint32())", ref, i); // can't be groups
    else gen
    ("%s[typeof k===\"object\"?util.longToHash(k):k]=r.%s()", ref, type);
} else {
    if (types.basic[type] === undefined) gen
    ("%s[k]=types[%d].decode(r,r.uint32())", ref, i); // can't be groups
    else gen
    ("%s[k]=r.%s()", ref, type);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.merge" id="apidoc.element.protobufjs.util.merge">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>merge
        <span class="apidocSignatureSpan">(dst, src, ifNotSet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i &lt; keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.newBuffer" id="apidoc.element.protobufjs.util.newBuffer">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>newBuffer
        <span class="apidocSignatureSpan">(sizeOrArray)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.newError" id="apidoc.element.protobufjs.util.newError">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>newError
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: (new Error()).stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.oneOfGetter" id="apidoc.element.protobufjs.util.oneOfGetter">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>oneOfGetter
        <span class="apidocSignatureSpan">(fieldNames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i &lt; fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i &gt; -1; --i)
            if (fieldMap[keys[i]] === 1 &amp;&amp; this[keys[i]] !== undefined &amp;&amp; this[keys[i]] !== null)
                return keys[i];
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.oneOfSetter" id="apidoc.element.protobufjs.util.oneOfSetter">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>oneOfSetter
        <span class="apidocSignatureSpan">(fieldNames)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i &lt; fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.pool" id="apidoc.element.protobufjs.util.pool">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>pool
        <span class="apidocSignatureSpan">(alloc, slice, size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE &gt;&gt;&gt; 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size &lt; 1 || size &gt; MAX)
            return alloc(size);
        if (offset + size &gt; SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset &amp; 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.safeProp" id="apidoc.element.protobufjs.util.safeProp">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>safeProp
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function safeProp_dn(name) {
    return !/^[$\w]+$/.test(name) || exports.reserved(name)
        ? safeProp(name)
        : "." + name;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    gen
("switch(t&gt;&gt;&gt;3){");

    var i = 0;
    for (; i &lt; /* initializes */ mtype.fieldsArray.length; ++i) {
var field = mtype._fieldsArray[i].resolve(),
    type  = field.resolvedType instanceof Enum ? "uint32" : field.type,
    ref   = "m" + util.<span class="apidocCodeKeywordSpan">safeProp</span>(field.name); gen
    ("case %d:", field.id);

// Map fields
if (field.map) { gen
        ("r.skip().pos++") // assumes id 1 + key wireType
        ("if(%s===util.emptyObject)", ref)
            ("%s={}", ref)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.toArray" id="apidoc.element.protobufjs.util.toArray">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>toArray
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toArray(object) {
    var array = [];
    if (object)
        for (var keys = Object.keys(object), i = 0; i &lt; keys.length; ++i)
            array.push(object[keys[i]]);
    return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.ucFirst" id="apidoc.element.protobufjs.util.ucFirst">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>ucFirst
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/* istanbul ignore if */
if (!nameRe.test(name))
    throw illegal(name, "name");

var fieldName = util.lcFirst(name);
if (name === fieldName)
    name = util.<span class="apidocCodeKeywordSpan">ucFirst</span>(name);
skip("=");
var id = parseId(next());
var type = new Type(name);
type.group = true;
var field = new Field(fieldName, id, name, rule);
field.filename = parse.filename;
ifBlock(type, function parseGroup_block(token) {
...</pre></li>
    </ul>




















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.util.Buffer" id="apidoc.module.protobufjs.util.Buffer">module protobufjs.util.Buffer</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.Buffer" id="apidoc.element.protobufjs.util.Buffer.Buffer">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>Buffer
        <span class="apidocSignatureSpan">(arg, encodingOrOffset, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      );
    }
    return Buffer.allocUnsafe(arg);
  }
  return Buffer.from(arg, encodingOrOffset, length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.alloc" id="apidoc.element.protobufjs.util.Buffer.alloc">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.</span>alloc
        <span class="apidocSignatureSpan">(size, fill, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">alloc = function (size, fill, encoding) {
  assertSize(size);
  if (size &gt; 0 &amp;&amp; fill !== undefined) {
    // Since we are filling anyway, don't zero fill initially.
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    if (typeof encoding !== 'string')
      encoding = undefined;
    return createUnsafeBuffer(size).fill(fill, encoding);
  }
  return new FastBuffer(size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.allocUnsafe" id="apidoc.element.protobufjs.util.Buffer.allocUnsafe">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.</span>allocUnsafe
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allocUnsafe = function (size) {
  assertSize(size);
  return allocate(size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.allocUnsafeSlow" id="apidoc.element.protobufjs.util.Buffer.allocUnsafeSlow">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.</span>allocUnsafeSlow
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allocUnsafeSlow = function (size) {
  assertSize(size);
  return createUnsafeBuffer(size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.byteLength" id="apidoc.element.protobufjs.util.Buffer.byteLength">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.</span>byteLength
        <span class="apidocSignatureSpan">(string, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function byteLength(string, encoding) {
  if (typeof string !== 'string') {
    if (ArrayBuffer.isView(string) || isArrayBuffer(string) ||
        isSharedArrayBuffer(string)) {
      return string.byteLength;
    }

    string = '' + string;
  }

  var len = string.length;
  if (len === 0)
    return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return binding.byteLengthUtf8(string);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len &gt;&gt;&gt; 1;

      case 'base64':
        return base64ByteLength(string, len);

      default:
        // The C++ binding defaulted to UTF8, we should too.
        if (loweredCase)
          return binding.byteLengthUtf8(string);

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.compare" id="apidoc.element.protobufjs.util.Buffer.compare">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.</span>compare
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compare(a, b) {
  if (!(a instanceof Buffer) ||
      !(b instanceof Buffer)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) {
    return 0;
  }

  return binding.compare(a, b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.concat" id="apidoc.element.protobufjs.util.Buffer.concat">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.</span>concat
        <span class="apidocSignatureSpan">(list, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function (list, length) {
  var i;
  if (!Array.isArray(list))
    throw new TypeError('"list" argument must be an Array of Buffers');

  if (list.length === 0)
    return new FastBuffer();

  if (length === undefined) {
    length = 0;
    for (i = 0; i &lt; list.length; i++)
      length += list[i].length;
  } else {
    length = length &gt;&gt;&gt; 0;
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i &lt; list.length; i++) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf))
      throw new TypeError('"list" argument must be an Array of Buffers');
    buf.copy(buffer, pos);
    pos += buf.length;
  }

  // Note: `length` is always equal to `buffer.length` at this point
  if (pos &lt; length) {
    // Zero-fill the remaining bytes if the specified `length` was more than
    // the actual total length, i.e. if we have some remaining allocated bytes
    // there were not initialized.
    buffer.fill(0, pos, length);
  }

  return buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.from" id="apidoc.element.protobufjs.util.Buffer.from">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.</span>from
        <span class="apidocSignatureSpan">(value, encodingOrOffset, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">from = function (value, encodingOrOffset, length) {
  if (typeof value === 'number')
    throw new TypeError('"value" argument must not be a number');

  if (isArrayBuffer(value) || isSharedArrayBuffer(value))
    return fromArrayBuffer(value, encodingOrOffset, length);

  if (typeof value === 'string')
    return fromString(value, encodingOrOffset);

  return fromObject(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.isBuffer" id="apidoc.element.protobufjs.util.Buffer.isBuffer">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.</span>isBuffer
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isBuffer(b) {
  return b instanceof Buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.isEncoding" id="apidoc.element.protobufjs.util.Buffer.isEncoding">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.</span>isEncoding
        <span class="apidocSignatureSpan">(encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEncoding = function (encoding) {
  return typeof encoding === 'string' &amp;&amp;
         typeof internalUtil.normalizeEncoding(encoding) === 'string';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.util.Buffer.prototype" id="apidoc.module.protobufjs.util.Buffer.prototype">module protobufjs.util.Buffer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.asciiSlice" id="apidoc.element.protobufjs.util.Buffer.prototype.asciiSlice">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>asciiSlice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asciiSlice() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.asciiWrite" id="apidoc.element.protobufjs.util.Buffer.prototype.asciiWrite">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>asciiWrite
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asciiWrite() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.base64Slice" id="apidoc.element.protobufjs.util.Buffer.prototype.base64Slice">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>base64Slice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function base64Slice() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.base64Write" id="apidoc.element.protobufjs.util.Buffer.prototype.base64Write">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>base64Write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function base64Write() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.compare" id="apidoc.element.protobufjs.util.Buffer.prototype.compare">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>compare
        <span class="apidocSignatureSpan">(target, start, end, thisStart, thisEnd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compare(target, start, end, thisStart, thisEnd) {

  if (!(target instanceof Buffer))
    throw new TypeError('Argument must be a Buffer');
  if (arguments.length === 1)
    return compare_(this, target);

  if (start === undefined)
    start = 0;
  else if (start &lt; 0)
    throw new RangeError('out of range index');
  else
    start &gt;&gt;&gt;= 0;

  if (end === undefined)
    end = target.length;
  else if (end &gt; target.length)
    throw new RangeError('out of range index');
  else
    end &gt;&gt;&gt;= 0;

  if (thisStart === undefined)
    thisStart = 0;
  else if (thisStart &lt; 0)
    throw new RangeError('out of range index');
  else
    thisStart &gt;&gt;&gt;= 0;

  if (thisEnd === undefined)
    thisEnd = this.length;
  else if (thisEnd &gt; this.length)
    throw new RangeError('out of range index');
  else
    thisEnd &gt;&gt;&gt;= 0;

  if (thisStart &gt;= thisEnd)
    return (start &gt;= end ? 0 : -1);
  else if (start &gt;= end)
    return 1;

  return compareOffset(this, target, start, thisStart, end, thisEnd);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.copy" id="apidoc.element.protobufjs.util.Buffer.prototype.copy">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>copy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function copy() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.equals" id="apidoc.element.protobufjs.util.Buffer.prototype.equals">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>equals
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function equals(b) {
  if (!(b instanceof Buffer))
    throw new TypeError('Argument must be a Buffer');

  if (this === b)
    return true;

  return binding.compare(this, b) === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.fill" id="apidoc.element.protobufjs.util.Buffer.prototype.fill">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>fill
        <span class="apidocSignatureSpan">(val, start, end, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (encoding !== undefined &amp;&amp; typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    var normalizedEncoding = internalUtil.normalizeEncoding(encoding);
    if (normalizedEncoding === undefined) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }

    if (val.length === 0) {
      // Previously, if val === '', the Buffer would not fill,
      // which is rather surprising.
      val = 0;
    } else if (val.length === 1) {
      var code = val.charCodeAt(0);
      if ((normalizedEncoding === 'utf8' &amp;&amp; code &lt; 128) ||
          normalizedEncoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code;
      }
    }
  } else if (typeof val === 'number') {
    val = val &amp; 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start &lt; 0 || end &gt; this.length)
    throw new RangeError('Out of range index');

  if (end &lt;= start)
    return this;

  start = start &gt;&gt;&gt; 0;
  end = end === undefined ? this.length : end &gt;&gt;&gt; 0;

  binding.fill(this, val, start, end, encoding);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.hexSlice" id="apidoc.element.protobufjs.util.Buffer.prototype.hexSlice">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>hexSlice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hexSlice() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.hexWrite" id="apidoc.element.protobufjs.util.Buffer.prototype.hexWrite">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>hexWrite
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hexWrite() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.includes" id="apidoc.element.protobufjs.util.Buffer.prototype.includes">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>includes
        <span class="apidocSignatureSpan">(val, byteOffset, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.indexOf" id="apidoc.element.protobufjs.util.Buffer.prototype.indexOf">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>indexOf
        <span class="apidocSignatureSpan">(val, byteOffset, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var fs   = require("fs"),
path = require("path");

// A profiling stub to measure encoding / decoding performance using benchmark data.

var commands = ["encode", "decode", "encode-browser", "decode-browser", "fromjson&amp;#
x22;];
if (commands.<span class="apidocCodeKeywordSpan">indexOf</span>(process.argv[2]) &lt; 0) { // 0: node, 1: prof.js
process.stderr.write("usage: " + path.basename(process.argv[1]) + " &lt;" + commands.join("|") + &amp;#
x22;&gt; [iterations=10000000]\n");
return;
}

// Spin up a node process with profiling enabled and process the generated log
if (process.execArgv.indexOf("--prof") &lt; 0) {
process.stdout.write("cleaning up old logs ...\n");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.inspect" id="apidoc.element.protobufjs.util.Buffer.prototype.inspect">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length &gt; 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length &gt; max)
      str += ' ... ';
  }
  return '&lt;' + this.constructor.name + ' ' + str + '&gt;';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.lastIndexOf" id="apidoc.element.protobufjs.util.Buffer.prototype.lastIndexOf">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>lastIndexOf
        <span class="apidocSignatureSpan">(val, byteOffset, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.latin1Slice" id="apidoc.element.protobufjs.util.Buffer.prototype.latin1Slice">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>latin1Slice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function latin1Slice() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.latin1Write" id="apidoc.element.protobufjs.util.Buffer.prototype.latin1Write">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>latin1Write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function latin1Write() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.readDoubleBE" id="apidoc.element.protobufjs.util.Buffer.prototype.readDoubleBE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readDoubleBE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readDoubleBE(offset, noAssert) {
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return binding.readDoubleBE(this, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.readDoubleLE" id="apidoc.element.protobufjs.util.Buffer.prototype.readDoubleLE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readDoubleLE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readDoubleLE(offset, noAssert) {
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return binding.readDoubleLE(this, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.readFloatBE" id="apidoc.element.protobufjs.util.Buffer.prototype.readFloatBE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readFloatBE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readFloatBE(offset, noAssert) {
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return binding.readFloatBE(this, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.readFloatLE" id="apidoc.element.protobufjs.util.Buffer.prototype.readFloatLE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readFloatLE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readFloatLE(offset, noAssert) {
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return binding.readFloatLE(this, offset);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.readInt16BE" id="apidoc.element.protobufjs.util.Buffer.prototype.readInt16BE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readInt16BE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt16BE = function (offset, noAssert) {
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | (this[offset] &lt;&lt; 8);
  return (val &amp; 0x8000) ? val | 0xFFFF0000 : val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.readInt16LE" id="apidoc.element.protobufjs.util.Buffer.prototype.readInt16LE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readInt16LE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt16LE = function (offset, noAssert) {
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset] | (this[offset + 1] &lt;&lt; 8);
  return (val &amp; 0x8000) ? val | 0xFFFF0000 : val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.readInt32BE" id="apidoc.element.protobufjs.util.Buffer.prototype.readInt32BE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readInt32BE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt32BE = function (offset, noAssert) {
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);

  return (this[offset] &lt;&lt; 24) |
      (this[offset + 1] &lt;&lt; 16) |
      (this[offset + 2] &lt;&lt; 8) |
      (this[offset + 3]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.readInt32LE" id="apidoc.element.protobufjs.util.Buffer.prototype.readInt32LE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readInt32LE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt32LE = function (offset, noAssert) {
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);

  return (this[offset]) |
      (this[offset + 1] &lt;&lt; 8) |
      (this[offset + 2] &lt;&lt; 16) |
      (this[offset + 3] &lt;&lt; 24);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.readInt8" id="apidoc.element.protobufjs.util.Buffer.prototype.readInt8">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readInt8
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt8 = function (offset, noAssert) {
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  var val = this[offset];
  return !(val &amp; 0x80) ? val : (0xff - val + 1) * -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.readIntBE" id="apidoc.element.protobufjs.util.Buffer.prototype.readIntBE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readIntBE
        <span class="apidocSignatureSpan">(offset, byteLength, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readIntBE = function (offset, byteLength, noAssert) {
  offset = offset &gt;&gt;&gt; 0;
  byteLength = byteLength &gt;&gt;&gt; 0;
  if (!noAssert)
    checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i &gt; 0 &amp;&amp; (mul *= 0x100))
    val += this[offset + --i] * mul;
  mul *= 0x80;

  if (val &gt;= mul)
    val -= Math.pow(2, 8 * byteLength);

  return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.readIntLE" id="apidoc.element.protobufjs.util.Buffer.prototype.readIntLE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readIntLE
        <span class="apidocSignatureSpan">(offset, byteLength, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readIntLE = function (offset, byteLength, noAssert) {
  offset = offset &gt;&gt;&gt; 0;
  byteLength = byteLength &gt;&gt;&gt; 0;
  if (!noAssert)
    checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i &lt; byteLength &amp;&amp; (mul *= 0x100))
    val += this[offset + i] * mul;
  mul *= 0x80;

  if (val &gt;= mul)
    val -= Math.pow(2, 8 * byteLength);

  return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.readUInt16BE" id="apidoc.element.protobufjs.util.Buffer.prototype.readUInt16BE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readUInt16BE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUInt16BE = function (offset, noAssert) {
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return (this[offset] &lt;&lt; 8) | this[offset + 1];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.readUInt16LE" id="apidoc.element.protobufjs.util.Buffer.prototype.readUInt16LE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readUInt16LE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUInt16LE = function (offset, noAssert) {
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] | (this[offset + 1] &lt;&lt; 8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.readUInt32BE" id="apidoc.element.protobufjs.util.Buffer.prototype.readUInt32BE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readUInt32BE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUInt32BE = function (offset, noAssert) {
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] &lt;&lt; 16) |
      (this[offset + 2] &lt;&lt; 8) |
      this[offset + 3]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.readUInt32LE" id="apidoc.element.protobufjs.util.Buffer.prototype.readUInt32LE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readUInt32LE
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUInt32LE = function (offset, noAssert) {
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkOffset(offset, 4, this.length);

  return ((this[offset]) |
      (this[offset + 1] &lt;&lt; 8) |
      (this[offset + 2] &lt;&lt; 16)) +
      (this[offset + 3] * 0x1000000);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.readUInt8" id="apidoc.element.protobufjs.util.Buffer.prototype.readUInt8">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readUInt8
        <span class="apidocSignatureSpan">(offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUInt8 = function (offset, noAssert) {
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  return this[offset];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.readUIntBE" id="apidoc.element.protobufjs.util.Buffer.prototype.readUIntBE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readUIntBE
        <span class="apidocSignatureSpan">(offset, byteLength, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUIntBE = function (offset, byteLength, noAssert) {
  offset = offset &gt;&gt;&gt; 0;
  byteLength = byteLength &gt;&gt;&gt; 0;
  if (!noAssert)
    checkOffset(offset, byteLength, this.length);

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength &gt; 0 &amp;&amp; (mul *= 0x100))
    val += this[offset + --byteLength] * mul;

  return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.readUIntLE" id="apidoc.element.protobufjs.util.Buffer.prototype.readUIntLE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>readUIntLE
        <span class="apidocSignatureSpan">(offset, byteLength, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readUIntLE = function (offset, byteLength, noAssert) {
  offset = offset &gt;&gt;&gt; 0;
  byteLength = byteLength &gt;&gt;&gt; 0;
  if (!noAssert)
    checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i &lt; byteLength &amp;&amp; (mul *= 0x100))
    val += this[offset + i] * mul;

  return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.slice" id="apidoc.element.protobufjs.util.Buffer.prototype.slice">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>slice
        <span class="apidocSignatureSpan">(start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function slice(start, end) {
  const srcLength = this.length;
  start = adjustOffset(start, srcLength);
  end = end !== undefined ? adjustOffset(end, srcLength) : srcLength;
  const newLength = end &gt; start ? end - start : 0;
  return new FastBuffer(this.buffer, this.byteOffset + start, newLength);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var child_process = require("child_process");
var logRe = /^isolate-[0-9A-F]+-v8\.log$/;
fs.readdirSync(process.cwd()).forEach(function readdirSync_it(file) {
    if (logRe.test(file))
        fs.unlink(file);
});
process.stdout.write("generating profile (may take a while) ...\n");
child_process.execSync("node --prof --trace-deopt " + process.execArgv.join(" ") + " " + process.argv
.<span class="apidocCodeKeywordSpan">slice</span>(1).join(" "), {
    cwd: process.cwd(),
    stdio: "inherit"
});
process.stdout.write("processing profile ...\n");
fs.readdirSync(process.cwd()).forEach(function readdirSync_it(file) {
    if (logRe.test(file)) {
        child_process.execSync("node --prof-process " + file, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.swap16" id="apidoc.element.protobufjs.util.Buffer.prototype.swap16">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>swap16
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function swap16() {
  // For Buffer.length &lt; 128, it's generally faster to
  // do the swap in javascript. For larger buffers,
  // dropping down to the native code is faster.
  const len = this.length;
  if (len % 2 !== 0)
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  if (len &lt; 128) {
    for (var i = 0; i &lt; len; i += 2)
      swap(this, i, i + 1);
    return this;
  }
  return swap16n(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.swap32" id="apidoc.element.protobufjs.util.Buffer.prototype.swap32">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>swap32
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function swap32() {
  // For Buffer.length &lt; 192, it's generally faster to
  // do the swap in javascript. For larger buffers,
  // dropping down to the native code is faster.
  const len = this.length;
  if (len % 4 !== 0)
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  if (len &lt; 192) {
    for (var i = 0; i &lt; len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  }
  return swap32n(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.swap64" id="apidoc.element.protobufjs.util.Buffer.prototype.swap64">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>swap64
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function swap64() {
  // For Buffer.length &lt; 192, it's generally faster to
  // do the swap in javascript. For larger buffers,
  // dropping down to the native code is faster.
  const len = this.length;
  if (len % 8 !== 0)
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  if (len &lt; 192) {
    for (var i = 0; i &lt; len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  }
  return swap64n(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.toJSON" id="apidoc.element.protobufjs.util.Buffer.prototype.toJSON">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  if (this.length) {
    const data = [];
    for (var i = 0; i &lt; this.length; ++i)
      data[i] = this[i];
    return { type: 'Buffer', data };
  } else {
    return { type: 'Buffer', data: [] };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.toString" id="apidoc.element.protobufjs.util.Buffer.prototype.toString">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  let result;
  if (arguments.length === 0) {
    result = this.utf8Slice(0, this.length);
  } else {
    result = slowToString.apply(this, arguments);
  }
  if (result === undefined)
    throw new Error('"toString()" failed');
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        protobuf.Root.fromJSON(json).resolveAll();
return;
}

var Test, data, count;

if (process.argv.indexOf("--alt") &lt; 0) {
root = protobuf.parse(fs.readFileSync(require.resolve("../bench/bench.proto")).<span class="apidocCodeKeywordSpan">toString
</span>("utf8")).root;
Test = root.lookup("Test");
json = JSON.stringify(root);
data = require("../bench/bench.json");
count = 10000000;
process.stdout.write("bench.proto");
} else {
root = protobuf.parse(fs.readFileSync(require.resolve("../tests/data/mapbox/vector_tile.proto")).toString("utf8&amp;#
x22;)).root;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.ucs2Slice" id="apidoc.element.protobufjs.util.Buffer.prototype.ucs2Slice">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>ucs2Slice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ucs2Slice() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.ucs2Write" id="apidoc.element.protobufjs.util.Buffer.prototype.ucs2Write">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>ucs2Write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ucs2Write() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.utf8Slice" id="apidoc.element.protobufjs.util.Buffer.prototype.utf8Slice">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>utf8Slice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function utf8Slice() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.utf8Write" id="apidoc.element.protobufjs.util.Buffer.prototype.utf8Write">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>utf8Write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function utf8Write() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.write" id="apidoc.element.protobufjs.util.Buffer.prototype.write">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>write
        <span class="apidocSignatureSpan">(string, offset, length, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (string, offset, length, encoding) {
  // Buffer#write(string);
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;

  // Buffer#write(string, encoding)
  } else if (length === undefined &amp;&amp; typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;

  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset &gt;&gt;&gt; 0;
    if (isFinite(length)) {
      length = length &gt;&gt;&gt; 0;
      if (encoding === undefined)
        encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    // if someone is still calling the obsolete form of write(), tell them.
    // we don't want eg buf.write("foo", "utf8", 10) to silently turn into
    // buf.write("foo", "utf8"), so we can't ignore extra args
    throw new Error('Buffer.write(string, encoding, offset[, length]) ' +
                    'is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length &gt; remaining)
    length = remaining;

  if (string.length &gt; 0 &amp;&amp; (length &lt; 0 || offset &lt; 0))
    throw new RangeError('Attempt to write outside buffer bounds');

  if (!encoding)
    encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return this.hexWrite(string, offset, length);

      case 'utf8':
      case 'utf-8':
        return this.utf8Write(string, offset, length);

      case 'ascii':
        return this.asciiWrite(string, offset, length);

      case 'latin1':
      case 'binary':
        return this.latin1Write(string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return this.base64Write(string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return this.ucs2Write(string, offset, length);

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs   = require("fs"),
path = require("path");

// A profiling stub to measure encoding / decoding performance using benchmark data.

var commands = ["encode", "decode", "encode-browser", "decode-browser", "fromjson&amp;#
x22;];
if (commands.indexOf(process.argv[2]) &lt; 0) { // 0: node, 1: prof.js
process.stderr.<span class="apidocCodeKeywordSpan">write</span>("usage: " + path.basename(process.argv[1]) + " &amp;#
x3c;" + commands.join("|") + "&gt; [iterations=10000000]\n");
return;
}

// Spin up a node process with profiling enabled and process the generated log
if (process.execArgv.indexOf("--prof") &lt; 0) {
process.stdout.write("cleaning up old logs ...\n");
var child_process = require("child_process");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.writeDoubleBE" id="apidoc.element.protobufjs.util.Buffer.prototype.writeDoubleBE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeDoubleBE
        <span class="apidocSignatureSpan">(val, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeDoubleBE(val, offset, noAssert) {
  val = +val;
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    binding.writeDoubleBE(this, val, offset);
  else
    binding.writeDoubleBE(this, val, offset, true);
  return offset + 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.writeDoubleLE" id="apidoc.element.protobufjs.util.Buffer.prototype.writeDoubleLE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeDoubleLE
        <span class="apidocSignatureSpan">(val, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeDoubleLE(val, offset, noAssert) {
  val = +val;
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    binding.writeDoubleLE(this, val, offset);
  else
    binding.writeDoubleLE(this, val, offset, true);
  return offset + 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.writeFloatBE" id="apidoc.element.protobufjs.util.Buffer.prototype.writeFloatBE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeFloatBE
        <span class="apidocSignatureSpan">(val, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeFloatBE(val, offset, noAssert) {
  val = +val;
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    binding.writeFloatBE(this, val, offset);
  else
    binding.writeFloatBE(this, val, offset, true);
  return offset + 4;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.writeFloatLE" id="apidoc.element.protobufjs.util.Buffer.prototype.writeFloatLE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeFloatLE
        <span class="apidocSignatureSpan">(val, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeFloatLE(val, offset, noAssert) {
  val = +val;
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    binding.writeFloatLE(this, val, offset);
  else
    binding.writeFloatLE(this, val, offset, true);
  return offset + 4;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.writeInt16BE" id="apidoc.element.protobufjs.util.Buffer.prototype.writeInt16BE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeInt16BE
        <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt16BE = function (value, offset, noAssert) {
  value = +value;
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = (value &gt;&gt;&gt; 8);
  this[offset + 1] = value;
  return offset + 2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.writeInt16LE" id="apidoc.element.protobufjs.util.Buffer.prototype.writeInt16LE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeInt16LE
        <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt16LE = function (value, offset, noAssert) {
  value = +value;
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value;
  this[offset + 1] = (value &gt;&gt;&gt; 8);
  return offset + 2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.writeInt32BE" id="apidoc.element.protobufjs.util.Buffer.prototype.writeInt32BE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeInt32BE
        <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt32BE = function (value, offset, noAssert) {
  value = +value;
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = (value &gt;&gt;&gt; 24);
  this[offset + 1] = (value &gt;&gt;&gt; 16);
  this[offset + 2] = (value &gt;&gt;&gt; 8);
  this[offset + 3] = value;
  return offset + 4;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.writeInt32LE" id="apidoc.element.protobufjs.util.Buffer.prototype.writeInt32LE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeInt32LE
        <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt32LE = function (value, offset, noAssert) {
  value = +value;
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value;
  this[offset + 1] = (value &gt;&gt;&gt; 8);
  this[offset + 2] = (value &gt;&gt;&gt; 16);
  this[offset + 3] = (value &gt;&gt;&gt; 24);
  return offset + 4;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.writeInt8" id="apidoc.element.protobufjs.util.Buffer.prototype.writeInt8">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeInt8
        <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeInt8 = function (value, offset, noAssert) {
  value = +value;
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80);
  this[offset] = value;
  return offset + 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.writeIntBE" id="apidoc.element.protobufjs.util.Buffer.prototype.writeIntBE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeIntBE
        <span class="apidocSignatureSpan">(value, offset, byteLength, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeIntBE = function (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert) {
    checkInt(this,
             value,
             offset,
             byteLength,
             Math.pow(2, 8 * byteLength - 1) - 1,
             -Math.pow(2, 8 * byteLength - 1));
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value;
  while (--i &gt;= 0 &amp;&amp; (mul *= 0x100)) {
    if (value &lt; 0 &amp;&amp; sub === 0 &amp;&amp; this[offset + i + 1] !== 0)
      sub = 1;
    this[offset + i] = ((value / mul) &gt;&gt; 0) - sub;
  }

  return offset + byteLength;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.writeIntLE" id="apidoc.element.protobufjs.util.Buffer.prototype.writeIntLE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeIntLE
        <span class="apidocSignatureSpan">(value, offset, byteLength, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeIntLE = function (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert) {
    checkInt(this,
             value,
             offset,
             byteLength,
             Math.pow(2, 8 * byteLength - 1) - 1,
             -Math.pow(2, 8 * byteLength - 1));
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value;
  while (++i &lt; byteLength &amp;&amp; (mul *= 0x100)) {
    if (value &lt; 0 &amp;&amp; sub === 0 &amp;&amp; this[offset + i - 1] !== 0)
      sub = 1;
    this[offset + i] = ((value / mul) &gt;&gt; 0) - sub;
  }

  return offset + byteLength;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.writeUInt16BE" id="apidoc.element.protobufjs.util.Buffer.prototype.writeUInt16BE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeUInt16BE
        <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUInt16BE = function (value, offset, noAssert) {
  value = +value;
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = (value &gt;&gt;&gt; 8);
  this[offset + 1] = value;
  return offset + 2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.writeUInt16LE" id="apidoc.element.protobufjs.util.Buffer.prototype.writeUInt16LE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeUInt16LE
        <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUInt16LE = function (value, offset, noAssert) {
  value = +value;
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value;
  this[offset + 1] = (value &gt;&gt;&gt; 8);
  return offset + 2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.writeUInt32BE" id="apidoc.element.protobufjs.util.Buffer.prototype.writeUInt32BE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeUInt32BE
        <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUInt32BE = function (value, offset, noAssert) {
  value = +value;
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = (value &gt;&gt;&gt; 24);
  this[offset + 1] = (value &gt;&gt;&gt; 16);
  this[offset + 2] = (value &gt;&gt;&gt; 8);
  this[offset + 3] = value;
  return offset + 4;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.writeUInt32LE" id="apidoc.element.protobufjs.util.Buffer.prototype.writeUInt32LE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeUInt32LE
        <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUInt32LE = function (value, offset, noAssert) {
  value = +value;
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = (value &gt;&gt;&gt; 24);
  this[offset + 2] = (value &gt;&gt;&gt; 16);
  this[offset + 1] = (value &gt;&gt;&gt; 8);
  this[offset] = value;
  return offset + 4;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.writeUInt8" id="apidoc.element.protobufjs.util.Buffer.prototype.writeUInt8">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeUInt8
        <span class="apidocSignatureSpan">(value, offset, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUInt8 = function (value, offset, noAssert) {
  value = +value;
  offset = offset &gt;&gt;&gt; 0;
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value;
  return offset + 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.writeUIntBE" id="apidoc.element.protobufjs.util.Buffer.prototype.writeUIntBE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeUIntBE
        <span class="apidocSignatureSpan">(value, offset, byteLength, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUIntBE = function (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset &gt;&gt;&gt; 0;
  byteLength = byteLength &gt;&gt;&gt; 0;
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value;
  while (--i &gt;= 0 &amp;&amp; (mul *= 0x100))
    this[offset + i] = (value / mul) &gt;&gt;&gt; 0;

  return offset + byteLength;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Buffer.prototype.writeUIntLE" id="apidoc.element.protobufjs.util.Buffer.prototype.writeUIntLE">
        function <span class="apidocSignatureSpan">protobufjs.util.Buffer.prototype.</span>writeUIntLE
        <span class="apidocSignatureSpan">(value, offset, byteLength, noAssert)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeUIntLE = function (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset &gt;&gt;&gt; 0;
  byteLength = byteLength &gt;&gt;&gt; 0;
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value;
  while (++i &lt; byteLength &amp;&amp; (mul *= 0x100))
    this[offset + i] = (value / mul) &gt;&gt;&gt; 0;

  return offset + byteLength;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.util.EventEmitter" id="apidoc.module.protobufjs.util.EventEmitter">module protobufjs.util.EventEmitter</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.util.EventEmitter.EventEmitter" id="apidoc.element.protobufjs.util.EventEmitter.EventEmitter">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>EventEmitter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.&lt;string,*&gt;}
     * @private
     */
    this._listeners = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.util.EventEmitter.prototype" id="apidoc.module.protobufjs.util.EventEmitter.prototype">module protobufjs.util.EventEmitter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.util.EventEmitter.prototype.emit" id="apidoc.element.protobufjs.util.EventEmitter.prototype.emit">
        function <span class="apidocSignatureSpan">protobufjs.util.EventEmitter.prototype.</span>emit
        <span class="apidocSignatureSpan">(evt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i &lt; arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i &lt; listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.EventEmitter.prototype.off" id="apidoc.element.protobufjs.util.EventEmitter.prototype.off">
        function <span class="apidocSignatureSpan">protobufjs.util.EventEmitter.prototype.</span>off
        <span class="apidocSignatureSpan">(evt, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i &lt; listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.EventEmitter.prototype.on" id="apidoc.element.protobufjs.util.EventEmitter.prototype.on">
        function <span class="apidocSignatureSpan">protobufjs.util.EventEmitter.prototype.</span>on
        <span class="apidocSignatureSpan">(evt, fn, ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.util.Long" id="apidoc.module.protobufjs.util.Long">module protobufjs.util.Long</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.Long" id="apidoc.element.protobufjs.util.Long.Long">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>Long
        <span class="apidocSignatureSpan">(low, high, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.fromBits" id="apidoc.element.protobufjs.util.Long.fromBits">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.</span>fromBits
        <span class="apidocSignatureSpan">(lowBits, highBits, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.fromInt" id="apidoc.element.protobufjs.util.Long.fromInt">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.</span>fromInt
        <span class="apidocSignatureSpan">(value, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value &gt;&gt;&gt;= 0;
        if (cache = (0 &lt;= value &amp;&amp; value &lt; 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) &lt; 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 &lt;= value &amp;&amp; value &lt; 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value &lt; 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.fromNumber" id="apidoc.element.protobufjs.util.Long.fromNumber">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.</span>fromNumber
        <span class="apidocSignatureSpan">(value, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromNumber(value, unsigned) {
    if (isNaN(value) || !isFinite(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value &lt; 0)
            return UZERO;
        if (value &gt;= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value &lt;= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 &gt;= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value &lt; 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.fromString" id="apidoc.element.protobufjs.util.Long.fromString">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.</span>fromString
        <span class="apidocSignatureSpan">(str, unsigned, radix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix &lt; 2 || 36 &lt; radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) &gt; 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i &lt; str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size &lt; 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.fromValue" id="apidoc.element.protobufjs.util.Long.fromValue">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.</span>fromValue
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromValue(val) {
    if (val /* is compatible */ instanceof Long)
        return val;
    if (typeof val === 'number')
        return fromNumber(val);
    if (typeof val === 'string')
        return fromString(val);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, val.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Calling `Message.verify` with any object returns `null` if the object can be encoded as-is and otherwise the error as a string
.
* Calling `Message.create` or `Message.encode` must be called with a valid message.
* Calling `Message.fromObject` with any object naively converts all values to the optimal JS type.

| Field type | Expected JS type (create, encode) | Naive conversion (fromObject)
|------------|-----------------------------------|------------------------------
| s-/u-/int32&lt;br /&gt;s-/fixed32 | `Number` (32 bit integer) | `value | 0` if signed&lt;br /&gt; `value &gt;&gt;&amp;#
x3e; 0` if unsigned
| s-/u-/int64&lt;br /&gt;s-/fixed64 | `Long`-like (optimal)&lt;br /&gt;`Number` (53 bit integer) | `Long.<span class="apidocCodeKeywordSpan
">fromValue</span>(value)` with long.js&lt;br /&gt;`parseInt(value, 10)` otherwise
| float&lt;br /&gt;double | `Number` | `Number(value)`
| bool | `Boolean` | `Boolean(value)`
| string | `String` | `String(value)`
| bytes | `Uint8Array` (optimal)&lt;br /&gt;`Buffer` (optimal under node)&lt;br /&gt;`Array.&lt;Number&gt;` (8 bit integers
)&lt;br /&gt;`String` (base64) | `base64.decode(value)` if a String&lt;br /&gt;`Object` with non-zero `.length` is kept
| enum | `Number` (32 bit integer) | Looks up the numeric id if a string
| message | Valid message | `Message.fromObject(value)`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.isLong" id="apidoc.element.protobufjs.util.Long.isLong">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.</span>isLong
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isLong(obj) {
    return (obj &amp;&amp; obj["__isLong__"]) === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.util.Long.prototype" id="apidoc.module.protobufjs.util.Long.prototype">module protobufjs.util.Long.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.add" id="apidoc.element.protobufjs.util.Long.prototype.add">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>add
        <span class="apidocSignatureSpan">(addend)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high &gt;&gt;&gt; 16;
    var a32 = this.high &amp; 0xFFFF;
    var a16 = this.low &gt;&gt;&gt; 16;
    var a00 = this.low &amp; 0xFFFF;

    var b48 = addend.high &gt;&gt;&gt; 16;
    var b32 = addend.high &amp; 0xFFFF;
    var b16 = addend.low &gt;&gt;&gt; 16;
    var b00 = addend.low &amp; 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 &gt;&gt;&gt; 16;
    c00 &amp;= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 &gt;&gt;&gt; 16;
    c16 &amp;= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 &gt;&gt;&gt; 16;
    c32 &amp;= 0xFFFF;
    c48 += a48 + b48;
    c48 &amp;= 0xFFFF;
    return fromBits((c16 &lt;&lt; 16) | c00, (c48 &lt;&lt; 16) | c32, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
...
var Root  = protobuf.Root,
    Type  = protobuf.Type,
    Field = protobuf.Field;

var AwesomeMessage = new Type("AwesomeMessage").<span class="apidocCodeKeywordSpan">add</span>(new Field("awesomeField
", 1, "string"));

var root = new Root().define("awesomepackage").add(AwesomeMessage);

// Continue at "Create a new message" above
...
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.and" id="apidoc.element.protobufjs.util.Long.prototype.and">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>and
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low &amp; other.low, this.high &amp; other.high, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.comp" id="apidoc.element.protobufjs.util.Long.prototype.comp">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>comp
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg &amp;&amp; !otherNeg)
        return -1;
    if (!thisNeg &amp;&amp; otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high &gt;&gt;&gt; 0) &gt; (this.high &gt;&gt;&gt; 0) || (other.high === this.high &amp;&amp; (other.low &gt;&gt;&gt; 0) &gt; (this.low &gt;&gt;&gt; 0)) ? -1 : 1
;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.compare" id="apidoc.element.protobufjs.util.Long.prototype.compare">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>compare
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg &amp;&amp; !otherNeg)
        return -1;
    if (!thisNeg &amp;&amp; otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high &gt;&gt;&gt; 0) &gt; (this.high &gt;&gt;&gt; 0) || (other.high === this.high &amp;&amp; (other.low &gt;&gt;&gt; 0) &gt; (this.low &gt;&gt;&gt; 0)) ? -1 : 1
;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.div" id="apidoc.element.protobufjs.util.Long.prototype.div">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>div
        <span class="apidocSignatureSpan">(divisor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');
    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| &gt;= 2, so |this/other| &lt; |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 &gt;&gt;&gt; 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 &lt;= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.divide" id="apidoc.element.protobufjs.util.Long.prototype.divide">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>divide
        <span class="apidocSignatureSpan">(divisor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');
    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| &gt;= 2, so |this/other| &lt; |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 &gt;&gt;&gt; 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 &lt;= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.eq" id="apidoc.element.protobufjs.util.Long.prototype.eq">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>eq
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned &amp;&amp; (this.high &gt;&gt;&gt; 31) === 1 &amp;&amp; (other.high &gt;&gt;&gt; 31) === 1)
        return false;
    return this.high === other.high &amp;&amp; this.low === other.low;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.equals" id="apidoc.element.protobufjs.util.Long.prototype.equals">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>equals
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned &amp;&amp; (this.high &gt;&gt;&gt; 31) === 1 &amp;&amp; (other.high &gt;&gt;&gt; 31) === 1)
        return false;
    return this.high === other.high &amp;&amp; this.low === other.low;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.getHighBits" id="apidoc.element.protobufjs.util.Long.prototype.getHighBits">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>getHighBits
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getHighBits() {
    return this.high;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.getHighBitsUnsigned" id="apidoc.element.protobufjs.util.Long.prototype.getHighBitsUnsigned">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>getHighBitsUnsigned
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getHighBitsUnsigned() {
    return this.high &gt;&gt;&gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.getLowBits" id="apidoc.element.protobufjs.util.Long.prototype.getLowBits">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>getLowBits
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLowBits() {
    return this.low;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.getLowBitsUnsigned" id="apidoc.element.protobufjs.util.Long.prototype.getLowBitsUnsigned">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>getLowBitsUnsigned
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLowBitsUnsigned() {
    return this.low &gt;&gt;&gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.getNumBitsAbs" id="apidoc.element.protobufjs.util.Long.prototype.getNumBitsAbs">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>getNumBitsAbs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit &gt; 0; bit--)
        if ((val &amp; (1 &lt;&lt; bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.greaterThan" id="apidoc.element.protobufjs.util.Long.prototype.greaterThan">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>greaterThan
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function greaterThan(other) {
    return this.comp(/* validates */ other) &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.greaterThanOrEqual" id="apidoc.element.protobufjs.util.Long.prototype.greaterThanOrEqual">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>greaterThanOrEqual
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) &gt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.gt" id="apidoc.element.protobufjs.util.Long.prototype.gt">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>gt
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function greaterThan(other) {
    return this.comp(/* validates */ other) &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.gte" id="apidoc.element.protobufjs.util.Long.prototype.gte">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>gte
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) &gt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.isEven" id="apidoc.element.protobufjs.util.Long.prototype.isEven">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>isEven
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isEven() {
    return (this.low &amp; 1) === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.isNegative" id="apidoc.element.protobufjs.util.Long.prototype.isNegative">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>isNegative
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNegative() {
    return !this.unsigned &amp;&amp; this.high &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.isOdd" id="apidoc.element.protobufjs.util.Long.prototype.isOdd">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>isOdd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isOdd() {
    return (this.low &amp; 1) === 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.isPositive" id="apidoc.element.protobufjs.util.Long.prototype.isPositive">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>isPositive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPositive() {
    return this.unsigned || this.high &gt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.isZero" id="apidoc.element.protobufjs.util.Long.prototype.isZero">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>isZero
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isZero() {
    return this.high === 0 &amp;&amp; this.low === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.lessThan" id="apidoc.element.protobufjs.util.Long.prototype.lessThan">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>lessThan
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lessThan(other) {
    return this.comp(/* validates */ other) &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.lessThanOrEqual" id="apidoc.element.protobufjs.util.Long.prototype.lessThanOrEqual">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>lessThanOrEqual
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) &lt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.lt" id="apidoc.element.protobufjs.util.Long.prototype.lt">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>lt
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lessThan(other) {
    return this.comp(/* validates */ other) &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.lte" id="apidoc.element.protobufjs.util.Long.prototype.lte">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>lte
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) &lt;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.mod" id="apidoc.element.protobufjs.util.Long.prototype.mod">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>mod
        <span class="apidocSignatureSpan">(divisor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    return this.sub(this.div(divisor).mul(divisor));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.modulo" id="apidoc.element.protobufjs.util.Long.prototype.modulo">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>modulo
        <span class="apidocSignatureSpan">(divisor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    return this.sub(this.div(divisor).mul(divisor));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.mul" id="apidoc.element.protobufjs.util.Long.prototype.mul">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>mul
        <span class="apidocSignatureSpan">(multiplier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) &amp;&amp; multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high &gt;&gt;&gt; 16;
    var a32 = this.high &amp; 0xFFFF;
    var a16 = this.low &gt;&gt;&gt; 16;
    var a00 = this.low &amp; 0xFFFF;

    var b48 = multiplier.high &gt;&gt;&gt; 16;
    var b32 = multiplier.high &amp; 0xFFFF;
    var b16 = multiplier.low &gt;&gt;&gt; 16;
    var b00 = multiplier.low &amp; 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 &gt;&gt;&gt; 16;
    c00 &amp;= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 &gt;&gt;&gt; 16;
    c16 &amp;= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 &gt;&gt;&gt; 16;
    c16 &amp;= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 &gt;&gt;&gt; 16;
    c32 &amp;= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 &gt;&gt;&gt; 16;
    c32 &amp;= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 &gt;&gt;&gt; 16;
    c32 &amp;= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &amp;= 0xFFFF;
    return fromBits((c16 &lt;&lt; 16) | c00, (c48 &lt;&lt; 16) | c32, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.multiply" id="apidoc.element.protobufjs.util.Long.prototype.multiply">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>multiply
        <span class="apidocSignatureSpan">(multiplier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) &amp;&amp; multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high &gt;&gt;&gt; 16;
    var a32 = this.high &amp; 0xFFFF;
    var a16 = this.low &gt;&gt;&gt; 16;
    var a00 = this.low &amp; 0xFFFF;

    var b48 = multiplier.high &gt;&gt;&gt; 16;
    var b32 = multiplier.high &amp; 0xFFFF;
    var b16 = multiplier.low &gt;&gt;&gt; 16;
    var b00 = multiplier.low &amp; 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 &gt;&gt;&gt; 16;
    c00 &amp;= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 &gt;&gt;&gt; 16;
    c16 &amp;= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 &gt;&gt;&gt; 16;
    c16 &amp;= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 &gt;&gt;&gt; 16;
    c32 &amp;= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 &gt;&gt;&gt; 16;
    c32 &amp;= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 &gt;&gt;&gt; 16;
    c32 &amp;= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &amp;= 0xFFFF;
    return fromBits((c16 &lt;&lt; 16) | c00, (c48 &lt;&lt; 16) | c32, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.neg" id="apidoc.element.protobufjs.util.Long.prototype.neg">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>neg
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function negate() {
    if (!this.unsigned &amp;&amp; this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.negate" id="apidoc.element.protobufjs.util.Long.prototype.negate">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>negate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function negate() {
    if (!this.unsigned &amp;&amp; this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.neq" id="apidoc.element.protobufjs.util.Long.prototype.neq">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>neq
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function notEquals(other) {
    return !this.eq(/* validates */ other);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.not" id="apidoc.element.protobufjs.util.Long.prototype.not">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>not
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.notEquals" id="apidoc.element.protobufjs.util.Long.prototype.notEquals">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>notEquals
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function notEquals(other) {
    return !this.eq(/* validates */ other);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.or" id="apidoc.element.protobufjs.util.Long.prototype.or">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>or
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.shiftLeft" id="apidoc.element.protobufjs.util.Long.prototype.shiftLeft">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>shiftLeft
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &amp;= 63) === 0)
        return this;
    else if (numBits &lt; 32)
        return fromBits(this.low &lt;&lt; numBits, (this.high &lt;&lt; numBits) | (this.low &gt;&gt;&gt; (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low &lt;&lt; (numBits - 32), this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.shiftRight" id="apidoc.element.protobufjs.util.Long.prototype.shiftRight">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>shiftRight
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &amp;= 63) === 0)
        return this;
    else if (numBits &lt; 32)
        return fromBits((this.low &gt;&gt;&gt; numBits) | (this.high &lt;&lt; (32 - numBits)), this.high &gt;&gt; numBits, this.unsigned);
    else
        return fromBits(this.high &gt;&gt; (numBits - 32), this.high &gt;= 0 ? 0 : -1, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.shiftRightUnsigned" id="apidoc.element.protobufjs.util.Long.prototype.shiftRightUnsigned">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>shiftRightUnsigned
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &amp;= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits &lt; 32) {
            var low = this.low;
            return fromBits((low &gt;&gt;&gt; numBits) | (high &lt;&lt; (32 - numBits)), high &gt;&gt;&gt; numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high &gt;&gt;&gt; (numBits - 32), 0, this.unsigned);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.shl" id="apidoc.element.protobufjs.util.Long.prototype.shl">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>shl
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &amp;= 63) === 0)
        return this;
    else if (numBits &lt; 32)
        return fromBits(this.low &lt;&lt; numBits, (this.high &lt;&lt; numBits) | (this.low &gt;&gt;&gt; (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low &lt;&lt; (numBits - 32), this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.shr" id="apidoc.element.protobufjs.util.Long.prototype.shr">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>shr
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &amp;= 63) === 0)
        return this;
    else if (numBits &lt; 32)
        return fromBits((this.low &gt;&gt;&gt; numBits) | (this.high &lt;&lt; (32 - numBits)), this.high &gt;&gt; numBits, this.unsigned);
    else
        return fromBits(this.high &gt;&gt; (numBits - 32), this.high &gt;= 0 ? 0 : -1, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.shru" id="apidoc.element.protobufjs.util.Long.prototype.shru">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>shru
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &amp;= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits &lt; 32) {
            var low = this.low;
            return fromBits((low &gt;&gt;&gt; numBits) | (high &lt;&lt; (32 - numBits)), high &gt;&gt;&gt; numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high &gt;&gt;&gt; (numBits - 32), 0, this.unsigned);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.sub" id="apidoc.element.protobufjs.util.Long.prototype.sub">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>sub
        <span class="apidocSignatureSpan">(subtrahend)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.subtract" id="apidoc.element.protobufjs.util.Long.prototype.subtract">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>subtract
        <span class="apidocSignatureSpan">(subtrahend)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.toBytes" id="apidoc.element.protobufjs.util.Long.prototype.toBytes">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>toBytes
        <span class="apidocSignatureSpan">(le)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBytes = function (le) {
    return le ? this.toBytesLE() : this.toBytesBE();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.toBytesBE" id="apidoc.element.protobufjs.util.Long.prototype.toBytesBE">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>toBytesBE
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBytesBE = function () {
    var hi = this.high,
        lo = this.low;
    return [
        (hi &gt;&gt;&gt; 24) &amp; 0xff,
        (hi &gt;&gt;&gt; 16) &amp; 0xff,
        (hi &gt;&gt;&gt;  8) &amp; 0xff,
         hi         &amp; 0xff,
        (lo &gt;&gt;&gt; 24) &amp; 0xff,
        (lo &gt;&gt;&gt; 16) &amp; 0xff,
        (lo &gt;&gt;&gt;  8) &amp; 0xff,
         lo         &amp; 0xff
    ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.toBytesLE" id="apidoc.element.protobufjs.util.Long.prototype.toBytesLE">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>toBytesLE
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBytesLE = function () {
    var hi = this.high,
        lo = this.low;
    return [
         lo         &amp; 0xff,
        (lo &gt;&gt;&gt;  8) &amp; 0xff,
        (lo &gt;&gt;&gt; 16) &amp; 0xff,
        (lo &gt;&gt;&gt; 24) &amp; 0xff,
         hi         &amp; 0xff,
        (hi &gt;&gt;&gt;  8) &amp; 0xff,
        (hi &gt;&gt;&gt; 16) &amp; 0xff,
        (hi &gt;&gt;&gt; 24) &amp; 0xff
    ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.toInt" id="apidoc.element.protobufjs.util.Long.prototype.toInt">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>toInt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toInt() {
    return this.unsigned ? this.low &gt;&gt;&gt; 0 : this.low;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.toNumber" id="apidoc.element.protobufjs.util.Long.prototype.toNumber">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>toNumber
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toNumber() {
    if (this.unsigned)
        return ((this.high &gt;&gt;&gt; 0) * TWO_PWR_32_DBL) + (this.low &gt;&gt;&gt; 0);
    return this.high * TWO_PWR_32_DBL + (this.low &gt;&gt;&gt; 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.toSigned" id="apidoc.element.protobufjs.util.Long.prototype.toSigned">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>toSigned
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.toString" id="apidoc.element.protobufjs.util.Long.prototype.toString">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>toString
        <span class="apidocSignatureSpan">(radix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toString(radix) {
    radix = radix || 10;
    if (radix &lt; 2 || 36 &lt; radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() &gt;&gt;&gt; 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length &lt; 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        protobuf.Root.fromJSON(json).resolveAll();
return;
}

var Test, data, count;

if (process.argv.indexOf("--alt") &lt; 0) {
root = protobuf.parse(fs.readFileSync(require.resolve("../bench/bench.proto")).<span class="apidocCodeKeywordSpan">toString
</span>("utf8")).root;
Test = root.lookup("Test");
json = JSON.stringify(root);
data = require("../bench/bench.json");
count = 10000000;
process.stdout.write("bench.proto");
} else {
root = protobuf.parse(fs.readFileSync(require.resolve("../tests/data/mapbox/vector_tile.proto")).toString("utf8&amp;#
x22;)).root;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.toUnsigned" id="apidoc.element.protobufjs.util.Long.prototype.toUnsigned">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>toUnsigned
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.Long.prototype.xor" id="apidoc.element.protobufjs.util.Long.prototype.xor">
        function <span class="apidocSignatureSpan">protobufjs.util.Long.prototype.</span>xor
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.util.LongBits" id="apidoc.module.protobufjs.util.LongBits">module protobufjs.util.LongBits</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.util.LongBits.LongBits" id="apidoc.element.protobufjs.util.LongBits.LongBits">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>LongBits
        <span class="apidocSignatureSpan">(lo, hi)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo &gt;&gt;&gt; 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi &gt;&gt;&gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.LongBits.from" id="apidoc.element.protobufjs.util.LongBits.from">
        function <span class="apidocSignatureSpan">protobufjs.util.LongBits.</span>from
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low &gt;&gt;&gt; 0, value.high &gt;&gt;&gt; 0) : zero;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.LongBits.fromHash" id="apidoc.element.protobufjs.util.LongBits.fromHash">
        function <span class="apidocSignatureSpan">protobufjs.util.LongBits.</span>fromHash
        <span class="apidocSignatureSpan">(hash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) &lt;&lt; 8
        | charCodeAt.call(hash, 2) &lt;&lt; 16
        | charCodeAt.call(hash, 3) &lt;&lt; 24) &gt;&gt;&gt; 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) &lt;&lt; 8
        | charCodeAt.call(hash, 6) &lt;&lt; 16
        | charCodeAt.call(hash, 7) &lt;&lt; 24) &gt;&gt;&gt; 0
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.LongBits.fromNumber" id="apidoc.element.protobufjs.util.LongBits.fromNumber">
        function <span class="apidocSignatureSpan">protobufjs.util.LongBits.</span>fromNumber
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value &lt; 0;
    if (sign)
        value = -value;
    var lo = value &gt;&gt;&gt; 0,
        hi = (value - lo) / 4294967296 &gt;&gt;&gt; 0;
    if (sign) {
        hi = ~hi &gt;&gt;&gt; 0;
        lo = ~lo &gt;&gt;&gt; 0;
        if (++lo &gt; 4294967295) {
            lo = 0;
            if (++hi &gt; 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.util.LongBits.prototype" id="apidoc.module.protobufjs.util.LongBits.prototype">module protobufjs.util.LongBits.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.util.LongBits.prototype.length" id="apidoc.element.protobufjs.util.LongBits.prototype.length">
        function <span class="apidocSignatureSpan">protobufjs.util.LongBits.prototype.</span>length
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function length() {
    var part0 =  this.lo,
        part1 = (this.lo &gt;&gt;&gt; 28 | this.hi &lt;&lt; 4) &gt;&gt;&gt; 0,
        part2 =  this.hi &gt;&gt;&gt; 24;
    return part2 === 0
         ? part1 === 0
           ? part0 &lt; 16384
             ? part0 &lt; 128 ? 1 : 2
             : part0 &lt; 2097152 ? 3 : 4
           : part1 &lt; 16384
             ? part1 &lt; 128 ? 5 : 6
             : part1 &lt; 2097152 ? 7 : 8
         : part2 &lt; 128 ? 9 : 10;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.LongBits.prototype.toHash" id="apidoc.element.protobufjs.util.LongBits.prototype.toHash">
        function <span class="apidocSignatureSpan">protobufjs.util.LongBits.prototype.</span>toHash
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toHash() {
    return String.fromCharCode(
        this.lo        &amp; 255,
        this.lo &gt;&gt;&gt; 8  &amp; 255,
        this.lo &gt;&gt;&gt; 16 &amp; 255,
        this.lo &gt;&gt;&gt; 24      ,
        this.hi        &amp; 255,
        this.hi &gt;&gt;&gt; 8  &amp; 255,
        this.hi &gt;&gt;&gt; 16 &amp; 255,
        this.hi &gt;&gt;&gt; 24
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.LongBits.prototype.toLong" id="apidoc.element.protobufjs.util.LongBits.prototype.toLong">
        function <span class="apidocSignatureSpan">protobufjs.util.LongBits.prototype.</span>toLong
        <span class="apidocSignatureSpan">(unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.LongBits.prototype.toNumber" id="apidoc.element.protobufjs.util.LongBits.prototype.toNumber">
        function <span class="apidocSignatureSpan">protobufjs.util.LongBits.prototype.</span>toNumber
        <span class="apidocSignatureSpan">(unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toNumber(unsigned) {
    if (!unsigned &amp;&amp; this.hi &gt;&gt;&gt; 31) {
        var lo = ~this.lo + 1 &gt;&gt;&gt; 0,
            hi = ~this.hi     &gt;&gt;&gt; 0;
        if (!lo)
            hi = hi + 1 &gt;&gt;&gt; 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.LongBits.prototype.zzDecode" id="apidoc.element.protobufjs.util.LongBits.prototype.zzDecode">
        function <span class="apidocSignatureSpan">protobufjs.util.LongBits.prototype.</span>zzDecode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function zzDecode() {
    var mask = -(this.lo &amp; 1);
    this.lo  = ((this.lo &gt;&gt;&gt; 1 | this.hi &lt;&lt; 31) ^ mask) &gt;&gt;&gt; 0;
    this.hi  = ( this.hi &gt;&gt;&gt; 1                  ^ mask) &gt;&gt;&gt; 0;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.LongBits.prototype.zzEncode" id="apidoc.element.protobufjs.util.LongBits.prototype.zzEncode">
        function <span class="apidocSignatureSpan">protobufjs.util.LongBits.prototype.</span>zzEncode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function zzEncode() {
    var mask =   this.hi &gt;&gt; 31;
    this.hi  = ((this.hi &lt;&lt; 1 | this.lo &gt;&gt;&gt; 31) ^ mask) &gt;&gt;&gt; 0;
    this.lo  = ( this.lo &lt;&lt; 1                   ^ mask) &gt;&gt;&gt; 0;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.util.ProtocolError" id="apidoc.module.protobufjs.util.ProtocolError">module protobufjs.util.ProtocolError</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.util.ProtocolError.ProtocolError" id="apidoc.element.protobufjs.util.ProtocolError.ProtocolError">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>ProtocolError
        <span class="apidocSignatureSpan">(message, properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CustomError(message, properties) {

    if (!(this instanceof CustomError))
        return new CustomError(message, properties);

    // Error.call(this, message);
    // ^ just returns a new error instance because the ctor can be called as a function

    Object.defineProperty(this, "message", { get: function() { return message; } });

    /* istanbul ignore next */
    if (Error.captureStackTrace) // node
        Error.captureStackTrace(this, CustomError);
    else
        Object.defineProperty(this, "stack", { value: (new Error()).stack || "" });

    if (properties)
        merge(this, properties);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.util.ProtocolError.prototype" id="apidoc.module.protobufjs.util.ProtocolError.prototype">module protobufjs.util.ProtocolError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.util.ProtocolError.prototype.constructor" id="apidoc.element.protobufjs.util.ProtocolError.prototype.constructor">
        function <span class="apidocSignatureSpan">protobufjs.util.ProtocolError.prototype.</span>constructor
        <span class="apidocSignatureSpan">(message, properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CustomError(message, properties) {

    if (!(this instanceof CustomError))
        return new CustomError(message, properties);

    // Error.call(this, message);
    // ^ just returns a new error instance because the ctor can be called as a function

    Object.defineProperty(this, "message", { get: function() { return message; } });

    /* istanbul ignore next */
    if (Error.captureStackTrace) // node
        Error.captureStackTrace(this, CustomError);
    else
        Object.defineProperty(this, "stack", { value: (new Error()).stack || "" });

    if (properties)
        merge(this, properties);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.ProtocolError.prototype.toString" id="apidoc.element.protobufjs.util.ProtocolError.prototype.toString">
        function <span class="apidocSignatureSpan">protobufjs.util.ProtocolError.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toString() {
    return this.name + ": " + this.message;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        protobuf.Root.fromJSON(json).resolveAll();
return;
}

var Test, data, count;

if (process.argv.indexOf("--alt") &lt; 0) {
root = protobuf.parse(fs.readFileSync(require.resolve("../bench/bench.proto")).<span class="apidocCodeKeywordSpan">toString
</span>("utf8")).root;
Test = root.lookup("Test");
json = JSON.stringify(root);
data = require("../bench/bench.json");
count = 10000000;
process.stdout.write("bench.proto");
} else {
root = protobuf.parse(fs.readFileSync(require.resolve("../tests/data/mapbox/vector_tile.proto")).toString("utf8&amp;#
x22;)).root;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.util.base64" id="apidoc.module.protobufjs.util.base64">module protobufjs.util.base64</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.util.base64.decode" id="apidoc.element.protobufjs.util.base64.decode">
        function <span class="apidocSignatureSpan">protobufjs.util.base64.</span>decode
        <span class="apidocSignatureSpan">(string, buffer, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i &lt; string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 &amp;&amp; j &gt; 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t &lt;&lt; 2 | (c &amp; 48) &gt;&gt; 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t &amp; 15) &lt;&lt; 4 | (c &amp; 60) &gt;&gt; 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t &amp; 3) &lt;&lt; 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
works like `Message.encode` but additionally prepends the length of the message as a varint.

* **Message.decode**(reader: `Reader|Uint8Array`): `Message`&lt;br /&gt;
is an automatically generated message specific decoder. If required fields are missing, it throws a `util.ProtocolError` with an
 `instance` property set to the so far decoded message. If the wire format is invalid, it throws an `Error`. The result is a runtime
 message.

```js
try {
  var decodedMessage = AwesomeMessage.<span class="apidocCodeKeywordSpan">decode</span>(buffer);
} catch (e) {
    if (e instanceof protobuf.util.ProtocolError) {
      // e.instance holds the so far decoded message with missing required fields
    } else {
      // wire format is invalid
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.base64.encode" id="apidoc.element.protobufjs.util.base64.encode">
        function <span class="apidocSignatureSpan">protobufjs.util.base64.</span>encode
        <span class="apidocSignatureSpan">(buffer, start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encode(buffer, start, end) {
    var string = []; // alt: new Array(Math.ceil((end - start) / 3) * 4);
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start &lt; end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                string[i++] = b64[b &gt;&gt; 2];
                t = (b &amp; 3) &lt;&lt; 4;
                j = 1;
                break;
            case 1:
                string[i++] = b64[t | b &gt;&gt; 4];
                t = (b &amp; 15) &lt;&lt; 2;
                j = 2;
                break;
            case 2:
                string[i++] = b64[t | b &gt;&gt; 6];
                string[i++] = b64[b &amp; 63];
                j = 0;
                break;
        }
    }
    if (j) {
        string[i++] = b64[t];
        string[i  ] = 61;
        if (j === 1)
            string[i + 1] = 61;
    }
    return String.fromCharCode.apply(String, string);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  throw Error(err);
```

* **Message.encode**(message: `Message|Object` [, writer: `Writer`]): `Writer`&lt;br /&gt;
is an automatically generated message specific encoder expecting a valid message or plain object. Note that this method does not
 implicitly verify the message and that it's up to the user to make sure that the data can actually be encoded properly.

```js
var buffer = AwesomeMessage.<span class="apidocCodeKeywordSpan">encode</span>(message).finish();
```

* **Message.encodeDelimited**(message: `Message|Object` [, writer: `Writer`]): `Writer`&lt;br /&gt;
works like `Message.encode` but additionally prepends the length of the message as a varint.

* **Message.decode**(reader: `Reader|Uint8Array`): `Message`&lt;br /&gt;
is an automatically generated message specific decoder. If required fields are missing, it throws a `util.ProtocolError` with an
 `instance` property set to the so far decoded message. If the wire format is invalid, it throws an `Error`. The result is a runtime
 message.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.base64.length" id="apidoc.element.protobufjs.util.base64.length">
        function <span class="apidocSignatureSpan">protobufjs.util.base64.</span>length
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 &gt; 1 &amp;&amp; string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.base64.test" id="apidoc.element.protobufjs.util.base64.test">
        function <span class="apidocSignatureSpan">protobufjs.util.base64.</span>test
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Spin up a node process with profiling enabled and process the generated log
if (process.execArgv.indexOf("--prof") &lt; 0) {
process.stdout.write("cleaning up old logs ...\n");
var child_process = require("child_process");
var logRe = /^isolate-[0-9A-F]+-v8\.log$/;
fs.readdirSync(process.cwd()).forEach(function readdirSync_it(file) {
    if (logRe.<span class="apidocCodeKeywordSpan">test</span>(file))
        fs.unlink(file);
});
process.stdout.write("generating profile (may take a while) ...\n");
child_process.execSync("node --prof --trace-deopt " + process.execArgv.join(" ") + " " + process.argv
.slice(1).join(" "), {
    cwd: process.cwd(),
    stdio: "inherit"
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.util.codegen" id="apidoc.module.protobufjs.util.codegen">module protobufjs.util.codegen</a></h1>






    <h2>
        <a href="#apidoc.element.protobufjs.util.codegen.codegen" id="apidoc.element.protobufjs.util.codegen.codegen">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>codegen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function codegen() {
    var params = [],
        src    = [],
        indent = 1,
        inCase = false;
    for (var i = 0; i &lt; arguments.length;)
        params.push(arguments[i++]);

    /**
     * A codegen instance as returned by {@link codegen}, that also is a sprintf-like appender function.
     * @typedef Codegen
     * @type {function}
     * @param {string} format Format string
     * @param {...*} args Replacements
     * @returns {Codegen} Itself
     * @property {function(string=):string} str Stringifies the so far generated function source.
     * @property {function(string=, Object=):function} eof Ends generation and builds the function whilst applying a scope.
     */
    /**/
    function gen() {
        var args = [],
            i = 0;
        for (; i &lt; arguments.length;)
            args.push(arguments[i++]);
        var line = sprintf.apply(null, args);
        var level = indent;
        if (src.length) {
            var prev = src[src.length - 1];

            // block open or one time branch
            if (blockOpenRe.test(prev))
                level = ++indent; // keep
            else if (branchRe.test(prev))
                ++level; // once

            // casing
            if (casingRe.test(prev) &amp;&amp; !casingRe.test(line)) {
                level = ++indent;
                inCase = true;
            } else if (inCase &amp;&amp; breakRe.test(prev)) {
                level = --indent;
                inCase = false;
            }

            // block close
            if (blockCloseRe.test(line))
                level = --indent;
        }
        for (i = 0; i &lt; level; ++i)
            line = "\t" + line;
        src.push(line);
        return gen;
    }

    /**
     * Stringifies the so far generated function source.
     * @param {string} [name] Function name, defaults to generate an anonymous function
     * @returns {string} Function source using tabs for indentation
     * @inner
     */
    function str(name) {
        return "function" + (name ? " " + name.replace(/[^\w_$]/g, "_") : "") + "(" + params.join(",") + ") {\n" + src.join("\n") + "\n}";
    }

    gen.str = str;

    /**
     * Ends generation and builds the function whilst applying a scope.
     * @param {string} [name] Function name, defaults to generate an anonymous function
     * @param {Object.&lt;string,*&gt;} [scope] Function scope
     * @returns {function} The generated function, with scope applied if specified
     * @inner
     */
    function eof(name, scope) {
        if (typeof name === "object") {
            scope = name;
            name = undefined;
        }
        var source = gen.str(name);
        if (codegen.verbose)
            console.log("--- codegen ---\n" + source.replace(/^/mg, "&gt; ").replace(/\t/g, "  ")); // eslint-disable-line no-console
        var keys = Object.keys(scope || (scope = {}));
        return Function.apply(null, keys.concat("return " + source)).apply(null, keys.map(function(key) { return scope[key]; })); //
eslint-disable-line no-new-func
        //     ^ Creates a wrapper function with the scoped variable names as its parameters,
        //       calls it with the respective scoped variable values ^
        //       and returns our brand-new properly scoped function.
        //
        // This works because "Invoking the Function constructor as a function (without using the
        // new operator) has the same effect as invoking it as a constructor."
        // https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Function
    }

    gen.eof = eof;

    return gen;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Generates a decoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function decoder(mtype) {
/* eslint-disable no-unexpected-multiline */
var gen = util.<span class="apidocCodeKeywordSpan">codegen</span>("r", "l")
("if(!(r instanceof Reader))")
    ("r=Reader.create(r)")
("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).
length ? ",k" : ""))
("while(r.pos&lt;c){")
    ("var t=r.uint32()");
if (mtype.group) gen
    ("if((t&amp;7)===4)")
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.codegen.sprintf" id="apidoc.element.protobufjs.util.codegen.sprintf">
        function <span class="apidocSignatureSpan">protobufjs.util.codegen.</span>sprintf
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sprintf(format) {
    var args = [],
        i = 1;
    for (; i &lt; arguments.length;)
        args.push(arguments[i++]);
    i = 0;
    format = format.replace(/%([dfjs])/g, function($0, $1) {
        switch ($1) {
            case "d":
                return Math.floor(args[i++]);
            case "f":
                return Number(args[i++]);
            case "j":
                return JSON.stringify(args[i++]);
            default:
                return args[i++];
        }
    });
    if (i !== args.length)
        throw Error("argument count mismatch");
    return format;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.util.fetch" id="apidoc.module.protobufjs.util.fetch">module protobufjs.util.fetch</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.util.fetch.fetch" id="apidoc.element.protobufjs.util.fetch.fetch">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>fetch
        <span class="apidocSignatureSpan">(filename, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fetch(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    } else if (!options)
        options = {};

    if (!callback)
        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
    if (!options.xhr &amp;&amp; fs &amp;&amp; fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
            return err &amp;&amp; typeof XMLHttpRequest !== "undefined"
                ? fetch.xhr(filename, options, callback)
                : err
                ? callback(err)
                : callback(null, options.binary ? contents : contents.toString("utf8"));
        });

    // use the XHR version otherwise.
    return fetch.xhr(filename, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.fetch.xhr" id="apidoc.element.protobufjs.util.fetch.xhr">
        function <span class="apidocSignatureSpan">protobufjs.util.fetch.</span>xhr
        <span class="apidocSignatureSpan">(filename, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fetch_xhr(filename, options, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {

        if (xhr.readyState !== 4)
            return undefined;

        // local cors security errors return status 0 / empty string, too. afaik this cannot be
        // reliably distinguished from an actually empty file for security reasons. feel free
        // to send a pull request if you are aware of a solution.
        if (xhr.status !== 0 &amp;&amp; xhr.status !== 200)
            return callback(Error("status " + xhr.status));

        // if binary data is expected, make sure that some sort of array is returned, even if
        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.
        if (options.binary) {
            var buffer = xhr.response;
            if (!buffer) {
                buffer = [];
                for (var i = 0; i &lt; xhr.responseText.length; ++i)
                    buffer.push(xhr.responseText.charCodeAt(i) &amp; 255);
            }
            return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
    };

    if (options.binary) {
        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
        if ("overrideMimeType" in xhr)
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
    }

    xhr.open("GET", filename);
    xhr.send();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.util.float" id="apidoc.module.protobufjs.util.float">module protobufjs.util.float</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.util.float.float" id="apidoc.element.protobufjs.util.float.float">
        function <span class="apidocSignatureSpan">protobufjs.util.</span>float
        <span class="apidocSignatureSpan">(exports)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val &lt; 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val &gt; 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val &gt; 3.4028234663852886e+38) // +-Infinity
                writeUint((sign &lt;&lt; 31 | 2139095040) &gt;&gt;&gt; 0, buf, pos);
            else if (val &lt; 1.1754943508222875e-38) // denormal
                writeUint((sign &lt;&lt; 31 | Math.round(val / 1.401298464324817e-45)) &gt;&gt;&gt; 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) &amp; 8388607;
                writeUint((sign &lt;&lt; 31 | exponent + 127 &lt;&lt; 23 | mantissa) &gt;&gt;&gt; 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint &gt;&gt; 31) * 2 + 1,
                exponent = uint &gt;&gt;&gt; 23 &amp; 255,
                mantissa = uint &amp; 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6] ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.float.readDoubleBE" id="apidoc.element.protobufjs.util.float.readDoubleBE">
        function <span class="apidocSignatureSpan">protobufjs.util.float.</span>readDoubleBE
        <span class="apidocSignatureSpan">(buf, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readDouble_f64_rev(buf, pos) {
    f8b[7] = buf[pos    ];
    f8b[6] = buf[pos + 1];
    f8b[5] = buf[pos + 2];
    f8b[4] = buf[pos + 3];
    f8b[3] = buf[pos + 4];
    f8b[2] = buf[pos + 5];
    f8b[1] = buf[pos + 6];
    f8b[0] = buf[pos + 7];
    return f64[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.float.readDoubleLE" id="apidoc.element.protobufjs.util.float.readDoubleLE">
        function <span class="apidocSignatureSpan">protobufjs.util.float.</span>readDoubleLE
        <span class="apidocSignatureSpan">(buf, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readDouble_f64_cpy(buf, pos) {
    f8b[0] = buf[pos    ];
    f8b[1] = buf[pos + 1];
    f8b[2] = buf[pos + 2];
    f8b[3] = buf[pos + 3];
    f8b[4] = buf[pos + 4];
    f8b[5] = buf[pos + 5];
    f8b[6] = buf[pos + 6];
    f8b[7] = buf[pos + 7];
    return f64[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.float.readFloatBE" id="apidoc.element.protobufjs.util.float.readFloatBE">
        function <span class="apidocSignatureSpan">protobufjs.util.float.</span>readFloatBE
        <span class="apidocSignatureSpan">(buf, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readFloat_f32_rev(buf, pos) {
    f8b[3] = buf[pos    ];
    f8b[2] = buf[pos + 1];
    f8b[1] = buf[pos + 2];
    f8b[0] = buf[pos + 3];
    return f32[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.float.readFloatLE" id="apidoc.element.protobufjs.util.float.readFloatLE">
        function <span class="apidocSignatureSpan">protobufjs.util.float.</span>readFloatLE
        <span class="apidocSignatureSpan">(buf, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readFloat_f32_cpy(buf, pos) {
    f8b[0] = buf[pos    ];
    f8b[1] = buf[pos + 1];
    f8b[2] = buf[pos + 2];
    f8b[3] = buf[pos + 3];
    return f32[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.float.writeDoubleBE" id="apidoc.element.protobufjs.util.float.writeDoubleBE">
        function <span class="apidocSignatureSpan">protobufjs.util.float.</span>writeDoubleBE
        <span class="apidocSignatureSpan">(val, buf, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeDouble_f64_rev(val, buf, pos) {
    f64[0] = val;
    buf[pos    ] = f8b[7];
    buf[pos + 1] = f8b[6];
    buf[pos + 2] = f8b[5];
    buf[pos + 3] = f8b[4];
    buf[pos + 4] = f8b[3];
    buf[pos + 5] = f8b[2];
    buf[pos + 6] = f8b[1];
    buf[pos + 7] = f8b[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.float.writeDoubleLE" id="apidoc.element.protobufjs.util.float.writeDoubleLE">
        function <span class="apidocSignatureSpan">protobufjs.util.float.</span>writeDoubleLE
        <span class="apidocSignatureSpan">(val, buf, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeDouble_f64_cpy(val, buf, pos) {
    f64[0] = val;
    buf[pos    ] = f8b[0];
    buf[pos + 1] = f8b[1];
    buf[pos + 2] = f8b[2];
    buf[pos + 3] = f8b[3];
    buf[pos + 4] = f8b[4];
    buf[pos + 5] = f8b[5];
    buf[pos + 6] = f8b[6];
    buf[pos + 7] = f8b[7];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.float.writeFloatBE" id="apidoc.element.protobufjs.util.float.writeFloatBE">
        function <span class="apidocSignatureSpan">protobufjs.util.float.</span>writeFloatBE
        <span class="apidocSignatureSpan">(val, buf, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeFloat_f32_rev(val, buf, pos) {
    f32[0] = val;
    buf[pos    ] = f8b[3];
    buf[pos + 1] = f8b[2];
    buf[pos + 2] = f8b[1];
    buf[pos + 3] = f8b[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.float.writeFloatLE" id="apidoc.element.protobufjs.util.float.writeFloatLE">
        function <span class="apidocSignatureSpan">protobufjs.util.float.</span>writeFloatLE
        <span class="apidocSignatureSpan">(val, buf, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeFloat_f32_cpy(val, buf, pos) {
    f32[0] = val;
    buf[pos    ] = f8b[0];
    buf[pos + 1] = f8b[1];
    buf[pos + 2] = f8b[2];
    buf[pos + 3] = f8b[3];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.util.path" id="apidoc.module.protobufjs.util.path">module protobufjs.util.path</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.util.path.isAbsolute" id="apidoc.element.protobufjs.util.path.isAbsolute">
        function <span class="apidocSignatureSpan">protobufjs.util.path.</span>isAbsolute
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAbsolute(path) {
    return /^(?:\/|\w+:)/.test(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.path.normalize" id="apidoc.element.protobufjs.util.path.normalize">
        function <span class="apidocSignatureSpan">protobufjs.util.path.</span>normalize
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalize(path) {
    path = path.replace(/\\/g, "/")
               .replace(/\/{2,}/g, "/");
    var parts    = path.split("/"),
        absolute = isAbsolute(path),
        prefix   = "";
    if (absolute)
        prefix = parts.shift() + "/";
    for (var i = 0; i &lt; parts.length;) {
        if (parts[i] === "..") {
            if (i &gt; 0 &amp;&amp; parts[i - 1] !== "..")
                parts.splice(--i, 2);
            else if (absolute)
                parts.splice(i, 1);
            else
                ++i;
        } else if (parts[i] === ".")
            parts.splice(i, 1);
        else
            ++i;
    }
    return prefix + parts.join("/");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.path.resolve" id="apidoc.element.protobufjs.util.path.resolve">
        function <span class="apidocSignatureSpan">protobufjs.util.path.</span>resolve
        <span class="apidocSignatureSpan">(originPath, includePath, alreadyNormalized)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolve(originPath, includePath, alreadyNormalized) {
    if (!alreadyNormalized)
        includePath = normalize(includePath);
    if (isAbsolute(includePath))
        return includePath;
    if (!alreadyNormalized)
        originPath = normalize(originPath);
    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath
;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        protobuf.Root.fromJSON(json).resolveAll();
return;
}

var Test, data, count;

if (process.argv.indexOf("--alt") &lt; 0) {
root = protobuf.parse(fs.readFileSync(require.<span class="apidocCodeKeywordSpan">resolve</span>("../bench/bench.proto"
;)).toString("utf8")).root;
Test = root.lookup("Test");
json = JSON.stringify(root);
data = require("../bench/bench.json");
count = 10000000;
process.stdout.write("bench.proto");
} else {
root = protobuf.parse(fs.readFileSync(require.resolve("../tests/data/mapbox/vector_tile.proto")).toString("utf8&amp;#
x22;)).root;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.util.toJSONOptions" id="apidoc.module.protobufjs.util.toJSONOptions">module protobufjs.util.toJSONOptions</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.util.toJSONOptions.bytes" id="apidoc.element.protobufjs.util.toJSONOptions.bytes">
        function <span class="apidocSignatureSpan">protobufjs.util.toJSONOptions.</span>bytes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function String() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.toJSONOptions.enums" id="apidoc.element.protobufjs.util.toJSONOptions.enums">
        function <span class="apidocSignatureSpan">protobufjs.util.toJSONOptions.</span>enums
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function String() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.toJSONOptions.longs" id="apidoc.element.protobufjs.util.toJSONOptions.longs">
        function <span class="apidocSignatureSpan">protobufjs.util.toJSONOptions.</span>longs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function String() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.util.toJSONOptions.longs.prototype" id="apidoc.module.protobufjs.util.toJSONOptions.longs.prototype">module protobufjs.util.toJSONOptions.longs.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.util.toJSONOptions.longs.prototype.entityify" id="apidoc.element.protobufjs.util.toJSONOptions.longs.prototype.entityify">
        function <span class="apidocSignatureSpan">protobufjs.util.toJSONOptions.longs.prototype.</span>entityify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">entityify = function (){return this.replace(/&amp;/g,"&amp;amp;").replace(/&lt;/g,"&amp;lt;").replace(/&gt;/g,"&amp;gt;"
)}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.toJSONOptions.longs.prototype.isAlpha" id="apidoc.element.protobufjs.util.toJSONOptions.longs.prototype.isAlpha">
        function <span class="apidocSignatureSpan">protobufjs.util.toJSONOptions.longs.prototype.</span>isAlpha
        <span class="apidocSignatureSpan">( )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAlpha = function ( ){return this&gt;="a"&amp;&amp;this&lt;="z\uffff"||this&gt;="A"&amp;&amp;this&lt;="Z\uffff"}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.toJSONOptions.longs.prototype.isDigit" id="apidoc.element.protobufjs.util.toJSONOptions.longs.prototype.isDigit">
        function <span class="apidocSignatureSpan">protobufjs.util.toJSONOptions.longs.prototype.</span>isDigit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDigit = function (){return this&gt;="0"&amp;&amp;
this&lt;="9"}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.toJSONOptions.longs.prototype.supplant" id="apidoc.element.protobufjs.util.toJSONOptions.longs.prototype.supplant">
        function <span class="apidocSignatureSpan">protobufjs.util.toJSONOptions.longs.prototype.</span>supplant
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">supplant = function (e){return this.replace(/\{([^{}]*)\}/g,function(t,n){var r=e[n];return typeof
r=="string"||typeof r=="number"?r:t})}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.protobufjs.util.utf8" id="apidoc.module.protobufjs.util.utf8">module protobufjs.util.utf8</a></h1>


    <h2>
        <a href="#apidoc.element.protobufjs.util.utf8.length" id="apidoc.element.protobufjs.util.utf8.length">
        function <span class="apidocSignatureSpan">protobufjs.util.utf8.</span>length
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i &lt; string.length; ++i) {
        c = string.charCodeAt(i);
        if (c &lt; 128)
            len += 1;
        else if (c &lt; 2048)
            len += 2;
        else if ((c &amp; 0xFC00) === 0xD800 &amp;&amp; (string.charCodeAt(i + 1) &amp; 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.utf8.read" id="apidoc.element.protobufjs.util.utf8.read">
        function <span class="apidocSignatureSpan">protobufjs.util.utf8.</span>read
        <span class="apidocSignatureSpan">(buffer, start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len &lt; 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start &lt; end) {
        t = buffer[start++];
        if (t &lt; 128)
            chunk[i++] = t;
        else if (t &gt; 191 &amp;&amp; t &lt; 224)
            chunk[i++] = (t &amp; 31) &lt;&lt; 6 | buffer[start++] &amp; 63;
        else if (t &gt; 239 &amp;&amp; t &lt; 365) {
            t = ((t &amp; 7) &lt;&lt; 18 | (buffer[start++] &amp; 63) &lt;&lt; 12 | (buffer[start++] &amp; 63) &lt;&lt; 6 | buffer[start++] &amp; 63) - 0x10000;
            chunk[i++] = 0xD800 + (t &gt;&gt; 10);
            chunk[i++] = 0xDC00 + (t &amp; 1023);
        } else
            chunk[i++] = (t &amp; 15) &lt;&lt; 12 | (buffer[start++] &amp; 63) &lt;&lt; 6 | buffer[start++] &amp; 63;
        if (i &gt; 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.protobufjs.util.utf8.write" id="apidoc.element.protobufjs.util.utf8.write">
        function <span class="apidocSignatureSpan">protobufjs.util.utf8.</span>write
        <span class="apidocSignatureSpan">(string, buffer, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i &lt; string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 &lt; 128) {
            buffer[offset++] = c1;
        } else if (c1 &lt; 2048) {
            buffer[offset++] = c1 &gt;&gt; 6       | 192;
            buffer[offset++] = c1       &amp; 63 | 128;
        } else if ((c1 &amp; 0xFC00) === 0xD800 &amp;&amp; ((c2 = string.charCodeAt(i + 1)) &amp; 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 &amp; 0x03FF) &lt;&lt; 10) + (c2 &amp; 0x03FF);
            ++i;
            buffer[offset++] = c1 &gt;&gt; 18      | 240;
            buffer[offset++] = c1 &gt;&gt; 12 &amp; 63 | 128;
            buffer[offset++] = c1 &gt;&gt; 6  &amp; 63 | 128;
            buffer[offset++] = c1       &amp; 63 | 128;
        } else {
            buffer[offset++] = c1 &gt;&gt; 12      | 224;
            buffer[offset++] = c1 &gt;&gt; 6  &amp; 63 | 128;
            buffer[offset++] = c1       &amp; 63 | 128;
        }
    }
    return offset - start;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var fs   = require("fs"),
path = require("path");

// A profiling stub to measure encoding / decoding performance using benchmark data.

var commands = ["encode", "decode", "encode-browser", "decode-browser", "fromjson&amp;#
x22;];
if (commands.indexOf(process.argv[2]) &lt; 0) { // 0: node, 1: prof.js
process.stderr.<span class="apidocCodeKeywordSpan">write</span>("usage: " + path.basename(process.argv[1]) + " &amp;#
x3c;" + commands.join("|") + "&gt; [iterations=10000000]\n");
return;
}

// Spin up a node process with profiling enabled and process the generated log
if (process.execArgv.indexOf("--prof") &lt; 0) {
process.stdout.write("cleaning up old logs ...\n");
var child_process = require("child_process");
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>